<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="kotlin 协程原理分析 - 启动方式比较分析"><meta name="keywords" content="协程,协程启动"><meta name="author" content="Li Shuaiqi"><meta name="copyright" content="Li Shuaiqi"><title>kotlin 协程原理分析 - 启动方式比较分析 | Li Shuaiqi's Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '8.0.0'
} </script><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="Li Shuaiqi's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E5%89%8D%E8%A8%80"><span class="toc-text">0 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-launch-%E5%90%AF%E5%8A%A8"><span class="toc-text">1 launch 启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StandaloneCoroutine"><span class="toc-text">StandaloneCoroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LazyStandaloneCoroutine"><span class="toc-text">LazyStandaloneCoroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#onStart"><span class="toc-text">onStart()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CoroutineStart"><span class="toc-text">CoroutineStart</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LAZY-%E6%A8%A1%E5%BC%8F%E9%80%9A%E8%BF%87-start-%E5%90%AF%E5%8A%A8"><span class="toc-text">LAZY 模式通过 start 启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JobSupport-start"><span class="toc-text">JobSupport.start</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join-%E6%96%B9%E6%B3%95"><span class="toc-text">join 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-text">原理分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JobSupport"><span class="toc-text">JobSupport</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#join-%E2%80%93-gt-joinSuspend"><span class="toc-text">join –&gt; joinSuspend</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#makeNode"><span class="toc-text">makeNode</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#invokeOnCompletion-%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%88%90%E5%9B%9E%E8%B0%83%E5%AF%B9%E8%B1%A1"><span class="toc-text">invokeOnCompletion 注册一个完成回调对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#completeStateFinalization"><span class="toc-text">completeStateFinalization</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-async-%E5%90%AF%E5%8A%A8"><span class="toc-text">2 async 启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%BD%93%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-text">协程体的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LAZY-%E6%A8%A1%E5%BC%8F%E9%80%9A%E8%BF%87-start-%E5%90%AF%E5%8A%A8-1"><span class="toc-text">LAZY 模式通过 start 启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeferredCoroutine"><span class="toc-text">DeferredCoroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await"><span class="toc-text">await()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-runBlocking-%E5%90%AF%E5%8A%A8"><span class="toc-text">3 runBlocking 启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-text">核心逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingEventLoop"><span class="toc-text">BlockingEventLoop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enqueue"><span class="toc-text">enqueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#joinBlocking"><span class="toc-text">joinBlocking</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A-Dispathers"><span class="toc-text">指定 Dispathers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockingCoroutine"><span class="toc-text">BlockingCoroutine</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-text">4 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Li Shuaiqi</div><div class="author-info__description text-center">“Hi，我是李帅奇，Android 开发工程师。”</div><div class="follow-button"><a href="https://lishuaiqi.top">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">96</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">26</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">30</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">one more thing</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://juejin.cn/post/7366896388658593803">小二哥的 Android 站</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Li Shuaiqi's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">kotlin 协程原理分析 - 启动方式比较分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2025-05-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kotlin/">kotlin</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kotlin/%E5%8D%8F%E7%A8%8B/">协程</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.2k</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>基于微模型，分析下协程常见的启动方式的差异和对比。</p>
<p>常见的启动方式有：launch、async、runblock 下面会对比分析下三者的区别。</p>
<p>细节就不讲了，都是微模型的那一套，区别在于启动方式、异常机制、分发器等的不同，这个后续在分析。</p>
<h2 id="1-launch-启动"><a href="#1-launch-启动" class="headerlink" title="1 launch 启动"></a>1 launch 启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> fun CoroutineScope.launch(</span><br><span class="line">    context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; Unit</span><br><span class="line">): Job &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">newContext</span> <span class="operator">=</span> newCoroutineContext(context)</span><br><span class="line">    <span class="type">val</span> <span class="variable">coroutine</span> <span class="operator">=</span> <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是 launch 启动的核心逻辑。</p>
<p>默认模式下的 launch 启动，job 是 StandaloneCoroutine，这种情况是立刻会启动该协程。</p>
<p>launch 也是支持 isLazy 启动的，job 是 LazyStandaloneCoroutine，我们看看二者的区别</p>
<h3 id="StandaloneCoroutine"><a href="#StandaloneCoroutine" class="headerlink" title="StandaloneCoroutine"></a>StandaloneCoroutine</h3><p>标准 DEFAULT 启动，这里是在后续 CoroutineStart 的时候会直接启动协程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> open <span class="keyword">class</span> <span class="title class_">StandaloneCoroutine</span>(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    active: Boolean</span><br><span class="line">) : AbstractCoroutine&lt;Unit&gt;(parentContext, initParentJob = <span class="literal">true</span>, active = active) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//【1】异常处理机制;</span></span><br><span class="line">    override fun <span class="title function_">handleJobException</span><span class="params">(exception: Throwable)</span>: Boolean &#123;</span><br><span class="line">        handleCoroutineException(context, exception)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LazyStandaloneCoroutine"><a href="#LazyStandaloneCoroutine" class="headerlink" title="LazyStandaloneCoroutine"></a>LazyStandaloneCoroutine</h3><p>他是 StandaloneCoroutine 的扩展，所以具有一样的异常处理机制。</p>
<p>延迟启动，可以看到这里他把 block 存起来了，在 onStart 方法的时候会创建协程体，然后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LazyStandaloneCoroutine</span>(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; Unit</span><br><span class="line">) : StandaloneCoroutine(parentContext, active = <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">//【1】这里是 continuation 对象;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">continuation</span> <span class="operator">=</span> block.createCoroutineUnintercepted(<span class="built_in">this</span>, <span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//【2】通过 start 延迟启动协程，会走到这里;;</span></span><br><span class="line">        continuation.startCoroutineCancellable(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：onStart 方法：</p>
<h4 id="onStart"><a href="#onStart" class="headerlink" title="onStart()"></a>onStart()</h4><p>这里是通过 start 方法延迟启动的回调，下面会分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">override fun <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//【1】通过 start 延迟启动协程，会走到这里;;</span></span><br><span class="line">    continuation.startCoroutineCancellable(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CoroutineStart"><a href="#CoroutineStart" class="headerlink" title="CoroutineStart"></a>CoroutineStart</h3><p>任何启动方式，都会最后都会到 CoroutineStart 这个地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行 invoke 函数;;</span></span><br><span class="line"><span class="meta">@InternalCoroutinesApi</span></span><br><span class="line"><span class="keyword">public</span> operator fun &lt;R, T&gt; invoke(block: suspend R.() -&gt; T, receiver: R, completion: Continuation&lt;T&gt;): Unit =</span><br><span class="line">    <span class="keyword">when</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion) <span class="comment">// 如果是 DEFAULT，立刻启动;</span></span><br><span class="line">        ATOMIC -&gt; block.startCoroutine(receiver, completion)</span><br><span class="line">        UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)</span><br><span class="line">        LAZY -&gt; Unit <span class="comment">// 如果是 LAZY，那么延迟启动;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>DEFAULT，立刻启动，不多说了；</p>
<h4 id="LAZY-模式通过-start-启动"><a href="#LAZY-模式通过-start-启动" class="headerlink" title="LAZY 模式通过 start 启动"></a>LAZY 模式通过 start 启动</h4><p>懒加载启动方式，例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">conx</span> <span class="operator">=</span> GlobalScope.launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">    println(<span class="string">&quot;GlobalScope 协程开始执行&quot;</span>)</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        println(<span class="string">&quot;线程切换执行完毕！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 start 方法启动</span></span><br><span class="line">conx.start()</span><br></pre></td></tr></table></figure>
<h4 id="JobSupport-start"><a href="#JobSupport-start" class="headerlink" title="JobSupport.start"></a>JobSupport.start</h4><p>start 具体的实现是是在 AbstractCoroutine 的父接口 JobSupport 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override fun <span class="title function_">start</span><span class="params">()</span>: Boolean &#123;</span><br><span class="line">    loopOnState &#123; state -&gt;</span><br><span class="line">        <span class="keyword">when</span> (startInternal(state)) &#123; <span class="comment">// qi</span></span><br><span class="line">            FALSE -&gt; <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            TRUE -&gt; <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【1】startInternal</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">startInternal</span><span class="params">(state: Any?)</span>: Int &#123;</span><br><span class="line">    <span class="keyword">when</span> (state) &#123;</span><br><span class="line">        is Empty -&gt; &#123; <span class="comment">// EMPTY_X state -- no completion handlers</span></span><br><span class="line">            <span class="keyword">if</span> (state.isActive) <span class="keyword">return</span> FALSE <span class="comment">// already active</span></span><br><span class="line">            <span class="keyword">if</span> (!_state.compareAndSet(state, EMPTY_ACTIVE)) <span class="keyword">return</span> RETRY</span><br><span class="line">            <span class="comment">//【1】这里触发 onStart 启动;</span></span><br><span class="line">            onStart()</span><br><span class="line">            <span class="keyword">return</span> TRUE</span><br><span class="line">        &#125;</span><br><span class="line">        is InactiveNodeList -&gt; &#123; <span class="comment">// LIST state -- inactive with a list of completion handlers</span></span><br><span class="line">            <span class="keyword">if</span> (!_state.compareAndSet(state, state.list)) <span class="keyword">return</span> RETRY</span><br><span class="line">            <span class="title function_">onStart</span><span class="params">()</span></span><br><span class="line">            <span class="keyword">return</span> TRUE</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">return</span> FALSE <span class="comment">// not a new state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了 onStart() 方法，</p>
<h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join 方法"></a>join 方法</h3><p>和 launch 方法对应的有个 join 方法，用于等待协程执行完成，如下是例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">conx</span> <span class="operator">=</span> CoroutineScope(Dispatchers.IO).launch(start = CoroutineStart.DEFAULT) &#123;</span><br><span class="line">        println(<span class="string">&quot;GlobalScope 协程开始执行&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.IO) &#123;</span><br><span class="line">            println(<span class="string">&quot;线程切换执行完毕！&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挂起函数;</span></span><br><span class="line">    conx.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>join 的原理是什么呢？</p>
<h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>接口在 JobSupport 中：</p>
<h4 id="JobSupport"><a href="#JobSupport" class="headerlink" title="JobSupport"></a>JobSupport</h4><h5 id="join-–-gt-joinSuspend"><a href="#join-–-gt-joinSuspend" class="headerlink" title="join –&gt; joinSuspend"></a>join –&gt; joinSuspend</h5><p>执行挂起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】JobSupport</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override suspend fun <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!joinInternal()) &#123; <span class="comment">// fast-path no wait</span></span><br><span class="line">        coroutineContext.ensureActive()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// do not suspend</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】核心 joinSuspend;</span></span><br><span class="line">    <span class="keyword">return</span> joinSuspend() <span class="comment">// slow-path wait</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// joinSuspend 是一个挂起函数;</span></span><br><span class="line"><span class="comment">// cont 是 CancellableContinuationImpl 对象，CancellableContinuationImpl 会包裹 DispatchedContinuation 对象;</span></span><br><span class="line"><span class="keyword">private</span> suspend fun <span class="title function_">joinSuspend</span><span class="params">()</span> = suspendCancellableCoroutine&lt;Unit&gt; &#123; cont -&gt;</span><br><span class="line">    <span class="comment">// invokeOnCompletion 注册一个完成回调处理对象；</span></span><br><span class="line">    <span class="comment">// disposeOnCancellation 用于在协程取消时自动清理资源；</span></span><br><span class="line">    cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(cont).asHandler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【2】ResumeOnCompletion 执行结束通知对象；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ResumeOnCompletion</span>(</span><br><span class="line">    <span class="keyword">private</span> val continuation: Continuation&lt;Unit&gt;</span><br><span class="line">) : JobNode() &#123;</span><br><span class="line">    <span class="comment">//【2.1】回复外面的协程;</span></span><br><span class="line">    override fun <span class="title function_">invoke</span><span class="params">(cause: Throwable?)</span> = continuation.resume(Unit)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类 JobNode，其中 asHandler 是 CompletionHandlerBase 扩展函数，返回的是 this，这个不多说，可以自己去跟跟代码；</span></span><br><span class="line">internal <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">JobNode</span> : CompletionHandlerBase(), DisposableHandle, Incomplete &#123;</span><br><span class="line">  ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cont 是 CancellableContinuationImpl 对象，分析 suspend 函数的时候有分析过。</p>
<p>ResumeOnCompletion 是一个执行结束通知对象，这里是用于在当前协程执行完成后通知外部协程，其中 asHandler 是扩展函数，返回的是 this，这个不多说，可以自己去跟跟代码。</p>
<h5 id="makeNode"><a href="#makeNode" class="headerlink" title="makeNode"></a>makeNode</h5><p>先看这个方法，创建节点，将 ResumeOnCompletion 对象封装 成一个 JobNode，同时关联 Job，然后会保存到当前协程内部：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> fun <span class="title function_">makeNode</span><span class="params">(handler: CompletionHandler, onCancelling: Boolean)</span>: JobNode &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">if</span> (onCancelling) &#123; </span><br><span class="line">        (handler as? JobCancellingNode) ?: InvokeOnCancelling(handler) <span class="comment">//【1】包装为取消节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (handler as? JobNode)?.also &#123; <span class="keyword">assert</span> &#123; it !is JobCancellingNode &#125; &#125;</span><br><span class="line">            ?: InvokeOnCompletion(handler) <span class="comment">//【2】包装为完成节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    node.job = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InvokeOnCompletion 节点;;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InvokeOnCompletion</span>(</span><br><span class="line">    <span class="keyword">private</span> val handler: CompletionHandler</span><br><span class="line">) : JobNode()  &#123;</span><br><span class="line">    override fun <span class="title function_">invoke</span><span class="params">(cause: Throwable?)</span> = handler.invoke(cause)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>InvokeOnCancelling</code>: 包装为取消节点；</li>
<li><code>InvokeOnCompletion</code>: 包装为完成节点；</li>
</ul>
<p>具体的细节，你们可以自己跟跟代码。</p>
<h5 id="invokeOnCompletion-注册一个完成回调对象"><a href="#invokeOnCompletion-注册一个完成回调对象" class="headerlink" title="invokeOnCompletion 注册一个完成回调对象"></a>invokeOnCompletion 注册一个完成回调对象</h5><p>这个代码看起来复杂的，其实也不简单，核心逻辑是：根据当前的 job 的 state 状态，注册 ResumeOnCompletion 对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override fun <span class="title function_">invokeOnCompletion</span><span class="params">(</span></span><br><span class="line"><span class="params">    onCancelling: Boolean, // <span class="literal">false</span></span></span><br><span class="line"><span class="params">    invokeImmediately: Boolean, // <span class="literal">true</span></span></span><br><span class="line"><span class="params">    handler: CompletionHandler</span></span><br><span class="line"><span class="params">)</span>: DisposableHandle &#123;</span><br><span class="line">    <span class="comment">//【1】创建回调对应的 node 节点;</span></span><br><span class="line">    val node: JobNode = makeNode(handler, onCancelling)</span><br><span class="line">    loopOnState &#123; state -&gt;</span><br><span class="line">        <span class="keyword">when</span> (state) &#123;</span><br><span class="line">            is Empty -&gt; &#123; <span class="comment">// EMPTY_X state -- no completion handlers</span></span><br><span class="line">                <span class="keyword">if</span> (state.isActive) &#123;</span><br><span class="line">                    <span class="comment">// try move to SINGLE state</span></span><br><span class="line">                    <span class="keyword">if</span> (_state.compareAndSet(state, node)) <span class="keyword">return</span> node</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    promoteEmptyToNodeList(state) <span class="comment">// that way we can add listener for non-active coroutine</span></span><br><span class="line">            &#125;</span><br><span class="line">            is Incomplete -&gt; &#123; <span class="comment">//【2】当前 job 还没有执行完成;</span></span><br><span class="line">                <span class="type">val</span> <span class="variable">list</span> <span class="operator">=</span> state.list</span><br><span class="line">                <span class="title function_">if</span> <span class="params">(list == <span class="literal">null</span>)</span> &#123; <span class="comment">// SINGLE/SINGLE+</span></span><br><span class="line">                    promoteSingleToNodeList(state as JobNode)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> rootCause: Throwable? = <span class="literal">null</span></span><br><span class="line">                    <span class="keyword">var</span> handle: DisposableHandle = NonDisposableHandle</span><br><span class="line">                    <span class="comment">// 这里和取消相关，暂时不关注;</span></span><br><span class="line">                    <span class="keyword">if</span> (onCancelling &amp;&amp; state is Finishing) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span>(state) &#123;</span><br><span class="line">                            rootCause = state.rootCause <span class="comment">// != null if cancelling job</span></span><br><span class="line">                            <span class="keyword">if</span> (rootCause == <span class="literal">null</span> || handler.isHandlerOf&lt;ChildHandleNode&gt;() &amp;&amp; !state.isCompleting) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!addLastAtomic(state, list, node)) <span class="keyword">return</span><span class="meta">@loopOnState</span> <span class="comment">// retry</span></span><br><span class="line">                                <span class="keyword">if</span> (rootCause == <span class="literal">null</span>) <span class="keyword">return</span> <span class="type">node</span></span><br><span class="line">                                <span class="variable">handle</span> <span class="operator">=</span> node</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (rootCause != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (invokeImmediately) handler.invokeIt(rootCause)</span><br><span class="line">                        <span class="keyword">return</span> handle</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//【2】核心逻辑：将前面的 ResumeOnCompletion 对应的 Node 添加到 state.list 中记录下来；</span></span><br><span class="line">                        <span class="keyword">if</span> (addLastAtomic(state, list, node)) <span class="keyword">return</span> node</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                <span class="comment">//【3】当前 job 已经执行完成，立刻执行 ResumeOnCompletion 的 invoke 函数。</span></span><br><span class="line">                <span class="comment">// 通知外部协程执行结束，resumeWith;</span></span><br><span class="line">                <span class="keyword">if</span> (invokeImmediately) handler.invokeIt((state as? CompletedExceptionally)?.cause)</span><br><span class="line">                <span class="keyword">return</span> NonDisposableHandle</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将前面的 ResumeOnCompletion 对应的 Node 添加到 state.list 中记录下来；</p>
<h5 id="completeStateFinalization"><a href="#completeStateFinalization" class="headerlink" title="completeStateFinalization"></a>completeStateFinalization</h5><p>当前协程执行完成后，会触发到这个函数，在这里会统一的通过  state.list 里面记录的 Node 来间接 resume 外部的协程；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// job 的 resumeWith</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override fun <span class="title function_">resumeWith</span><span class="params">(result: Result&lt;T&gt;)</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">state</span> <span class="operator">=</span> makeCompletingOnce(result.toState())</span><br><span class="line">    <span class="keyword">if</span> (state === COMPLETING_WAITING_CHILDREN) <span class="keyword">return</span></span><br><span class="line">    afterResume(state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// suppressed == true when any exceptions were suppressed while building the final completion cause</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">completeStateFinalization</span><span class="params">(state: Incomplete, update: Any?)</span> &#123;</span><br><span class="line">    parentHandle?.let &#123;</span><br><span class="line">        it.dispose() </span><br><span class="line">        parentHandle = NonDisposableHandle</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">val</span> <span class="variable">cause</span> <span class="operator">=</span> (update as? CompletedExceptionally)?.cause</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 2) Invoke completion handlers: .join(), callbacks etc.</span></span><br><span class="line"><span class="comment">     *    It&#x27;s important to invoke them only AFTER exception handling and everything else, see #208</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (state is JobNode) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            state.invoke(cause)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex: Throwable) &#123;</span><br><span class="line">            handleOnCompletionException(CompletionHandlerException(<span class="string">&quot;Exception in completion handler $state for $this&quot;</span>, ex))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【1】核心逻辑：</span></span><br><span class="line">        state.list?.notifyCompletion(cause)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>1、调用 join() 函数的协程体会被封装成一个 Node 节点，添加到被等待的协程的 job 的 state.list。</li>
<li>2、被等待的协程执行完成后，会通知对应的 job，job 会在  completeStateFinalization 中遍历  state.list 唤醒外面的等待的协程。</li>
</ul>
<h2 id="2-async-启动"><a href="#2-async-启动" class="headerlink" title="2 async 启动"></a>2 async 启动</h2><p>我们来看看 async 启动的核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> fun &lt;T&gt; CoroutineScope.async(</span><br><span class="line">    context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; T</span><br><span class="line">): Deferred&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">newContext</span> <span class="operator">=</span> newCoroutineContext(context)</span><br><span class="line">    <span class="type">val</span> <span class="variable">coroutine</span> <span class="operator">=</span> <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyDeferredCoroutine(newContext, block) <span class="keyword">else</span> <span class="comment">// y</span></span><br><span class="line">        DeferredCoroutine&lt;T&gt;(newContext, active = <span class="literal">true</span>) <span class="comment">// 默认启动</span></span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下：async 也是通过 DEFAULT 方式启动，并且是立刻启动。</p>
<h3 id="协程体的差异"><a href="#协程体的差异" class="headerlink" title="协程体的差异"></a>协程体的差异</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block: suspend CoroutineScope.() -&gt; T</span><br></pre></td></tr></table></figure>
<p>这里能看出，async 的 block 是有返回值的。</p>
<p>对应的编译脚本生成的 SuspendLambda 的 invokeSuspend 函数的返回值会被强转为 T 类型！</p>
<p>同时，也会将 invokeSuspend 返回的结果，通过 completion.resumeWith 传递给 Job。</p>
<p>这个和 launch 启动的协程是不一样的，launch 协程返回值是 unit，和 java void 是一个意思。</p>
<h3 id="LAZY-模式通过-start-启动-1"><a href="#LAZY-模式通过-start-启动-1" class="headerlink" title="LAZY 模式通过 start 启动"></a>LAZY 模式通过 start 启动</h3><p>对于 lazy 方式，async 也是支持的，配合 start() 方法就行了。</p>
<p>这个不多讲了，和 launch 没啥太大区别。</p>
<h3 id="DeferredCoroutine"><a href="#DeferredCoroutine" class="headerlink" title="DeferredCoroutine"></a>DeferredCoroutine</h3><p>如果是默认启动类型的话，那么走的是 DeferredCoroutine，LazyDeferredCoroutine 是 DeferredCoroutine 的子类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">DeferredCoroutine</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    active: <span class="built_in">Boolean</span></span><br><span class="line">) : AbstractCoroutine&lt;T&gt;(parentContext, <span class="literal">true</span>, active = active), Deferred&lt;T&gt;, SelectClause1&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCompleted</span><span class="params">()</span></span>: T = getCompletedInternal() <span class="keyword">as</span> T</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span>: T = awaitInternal() <span class="keyword">as</span> T</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> onAwait: SelectClause1&lt;T&gt; <span class="keyword">get</span>() = <span class="keyword">this</span> <span class="comment">// 和 select 有关系，这里先不关注～</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">registerSelectClause1</span><span class="params">(select: <span class="type">SelectInstance</span>&lt;<span class="type">R</span>&gt;, block: <span class="type">suspend</span> (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span> =</span><br><span class="line">        registerSelectClause1Internal(select, block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其支持 await() 方法，其他协程能够通过 await() 实现。</p>
<p>onAwait 和 registerSelectClause1 是配合 select 操作符实现对多个协程体进行监听的逻辑，这里我们不多关注先。</p>
<h3 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h3><p>我们看一下 await 是如何拿到 async 的执行结果的，逻辑是不是和 launch 一样呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> suspend fun <span class="title function_">awaitSuspend</span><span class="params">()</span>: Any? = suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt; </span><br><span class="line">    <span class="type">val</span> <span class="variable">cont</span> <span class="operator">=</span> AwaitContinuation(uCont.intercepted(), <span class="built_in">this</span>)</span><br><span class="line">    cont.initCancellability()</span><br><span class="line">    cont.disposeOnCancellation(invokeOnCompletion(ResumeAwaitOnCompletion(cont).asHandler))</span><br><span class="line">    cont.getResult()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然是一样的操作。</p>
<ul>
<li>onAwait 本质上就是一个挂起函数，所以外部协程会挂起。</li>
<li>invokeOnCompletion 依然是创建了一个 Node 节点，加入到当前协程 job 的 state.list 中</li>
<li>最后统一唤醒。</li>
</ul>
<p>其实 await 就是特殊的 join，join 传递的结果是特殊的 Unit 而已。</p>
<h2 id="3-runBlocking-启动"><a href="#3-runBlocking-启动" class="headerlink" title="3 runBlocking 启动"></a>3 runBlocking 启动</h2><p>最后看看 runBlocking，已经 runBlocking 的阻塞线程原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suspend fun <span class="title function_">main</span><span class="params">()</span> = runBlocking &#123;</span><br><span class="line">	... ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(InterruptedException::class)</span></span><br><span class="line"><span class="keyword">public</span> actual fun &lt;T&gt; runBlocking(context: CoroutineContext, block: suspend CoroutineScope.() -&gt; T): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">val</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】获取 Dispatchers 方法。</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">contextInterceptor</span> <span class="operator">=</span> context[ContinuationInterceptor]</span><br><span class="line">    val eventLoop: EventLoop?</span><br><span class="line">    val newContext: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】根据是否指定 Dispatchers 做处理。</span></span><br><span class="line">    <span class="comment">// 如果没有指定 Dispatchers，那么采用的是 ThreadLocalEventLoop。</span></span><br><span class="line">    <span class="keyword">if</span> (contextInterceptor == <span class="literal">null</span>) &#123;</span><br><span class="line">        eventLoop = ThreadLocalEventLoop.<span class="type">eventLoop</span></span><br><span class="line">        <span class="variable">newContext</span> <span class="operator">=</span> GlobalScope.newCoroutineContext(context + eventLoop)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果指定了 Dispatchers，看看是否是 EventLoop 是的话赋值 eventLoop</span></span><br><span class="line">        <span class="comment">// 同时创建新上下文 CoroutineContext，这里会包含外部执行的</span></span><br><span class="line">        eventLoop = (contextInterceptor as? EventLoop)?.takeIf &#123; it.shouldBeProcessedFromContext() &#125;</span><br><span class="line">            ?: ThreadLocalEventLoop.currentOrNull()</span><br><span class="line">        newContext = GlobalScope.newCoroutineContext(context)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】创建 BlockingCoroutine 这个 job，并启动；</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">coroutine</span> <span class="operator">=</span> BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)</span><br><span class="line">    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】调用 joinBlocking 等待结果；</span></span><br><span class="line">    <span class="keyword">return</span> coroutine.joinBlocking()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到了一些关键点：</p>
<ul>
<li>ThreadLocalEventLoop.eventLoop 的原理：BlockingEventLoop；</li>
<li>joinBlocking 的原理；</li>
<li>BlockingCoroutine 的原理；</li>
</ul>
<h3 id="BlockingEventLoop"><a href="#BlockingEventLoop" class="headerlink" title="BlockingEventLoop"></a>BlockingEventLoop</h3><p>其实最终返回的是一个 BlockingEventLoop</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">internal actual fun <span class="title function_">createEventLoop</span><span class="params">()</span>: EventLoop = BlockingEventLoop(Thread.currentThread())</span><br></pre></td></tr></table></figure>
<p>BlockingEventLoop 父类里面有一个队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">EventLoopImplBase</span>: EventLoopImplPlatform(), Delay &#123;</span><br><span class="line">    <span class="comment">// null | CLOSED_EMPTY | task | Queue&lt;Runnable&gt;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">_queue</span> <span class="operator">=</span> atomic&lt;Any?&gt;(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>回忆下微模型，DispatchedContinuations 对象会被添加到 Dispatcher 中去执行。</p>
<p>其实在 BlockingEventLoop 的场景下，就是被添加到 BlockingEventLoop 的 quue 队列中了。</p>
<p>同时注意 BlockingEventLoop 的线程：currentThread，也就是说，是同步执行。</p>
<h3 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h3><p>dispatch 的过程就是 enqueue 的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override fun <span class="title function_">dispatch</span><span class="params">(context: CoroutineContext, block: Runnable)</span> = enqueue(block)</span><br><span class="line"></span><br><span class="line">open fun <span class="title function_">enqueue</span><span class="params">(task: Runnable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (enqueueImpl(task)) &#123;</span><br><span class="line">        <span class="comment">// todo: we should unpark only when this delayed task became first in the queue</span></span><br><span class="line">        unpark()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DefaultExecutor.enqueue(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="joinBlocking"><a href="#joinBlocking" class="headerlink" title="joinBlocking"></a>joinBlocking</h3><p>我们看看 joinBlocking 函数，可以看到 joinBlocking 会进入到自旋状态，然后不断的从前面的 queue 中获取任务执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Suppress(&quot;UNCHECKED_CAST&quot;)</span></span><br><span class="line">fun <span class="title function_">joinBlocking</span><span class="params">()</span>: T &#123;</span><br><span class="line">    registerTimeLoopThread()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        eventLoop?.incrementUseCount()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="meta">@Suppress(&quot;DEPRECATION&quot;)</span></span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted()) <span class="keyword">throw</span> InterruptedException().also &#123; cancelCoroutine(it) &#125;</span><br><span class="line">              </span><br><span class="line">                <span class="comment">//【1】从队列中弹出 Task 对象;</span></span><br><span class="line">                <span class="comment">// 如果没有 eventLoop，那么就无限 park！！</span></span><br><span class="line">                <span class="type">val</span> <span class="variable">parkNanos</span> <span class="operator">=</span> eventLoop?.processNextEvent() ?: Long.MAX_VALUE <span class="comment">// 计算 park 时间</span></span><br><span class="line">                  </span><br><span class="line">                <span class="keyword">if</span> (isCompleted) <span class="keyword">break</span></span><br><span class="line">                <span class="title function_">parkNanos</span><span class="params">(<span class="built_in">this</span>, parkNanos)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// paranoia</span></span><br><span class="line">            eventLoop?.decrementUseCount()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// paranoia</span></span><br><span class="line">        unregisterTimeLoopThread()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// now return result</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">state</span> <span class="operator">=</span> <span class="built_in">this</span>.state.unboxState()</span><br><span class="line">    (state as? CompletedExceptionally)?.let &#123; <span class="keyword">throw</span> it.cause &#125;</span><br><span class="line">    <span class="keyword">return</span> state as T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override fun <span class="title function_">processNextEvent</span><span class="params">()</span>: Long &#123;</span><br><span class="line">    <span class="keyword">if</span> (processUnconfinedEvent()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">delayed</span> <span class="operator">=</span> _delayed.value</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(delayed != <span class="literal">null</span> &amp;&amp; !delayed.isEmpty)</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">now</span> <span class="operator">=</span> nanoTime()</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            delayed.removeFirstIf &#123;</span><br><span class="line">                <span class="keyword">if</span> (it.timeToExecute(now)) &#123;</span><br><span class="line">                    enqueueImpl(it)</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="literal">false</span></span><br><span class="line">            &#125; ?: <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】核心：dequeue task 并执行;</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">task</span> <span class="operator">=</span> dequeue()</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        platformAutoreleasePool &#123; task.run() &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextTime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以如果不指定线程，默认就在当前线程，那么是同步执行的！！！</p>
<p>当前线程在执行完 task 后，会再次进入自旋状态，然后阻塞等待！！！</p>
<h3 id="指定-Dispathers"><a href="#指定-Dispathers" class="headerlink" title="指定 Dispathers"></a>指定 Dispathers</h3><p>如果指定了 Dispathers 的话呢？那么就没 loop 内部的队列了，那么当前线程会在 eventloop 的 processNextEvent 的地方一直阻塞。</p>
<h4 id="BlockingCoroutine"><a href="#BlockingCoroutine" class="headerlink" title="BlockingCoroutine"></a>BlockingCoroutine</h4><p>知道协程体执行完成后，通知 BlockingCoroutine，resumeWith 返回里面在 afterCompletion 后会，unpark blockedThread 线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override fun <span class="title function_">afterCompletion</span><span class="params">(state: Any?)</span> &#123;</span><br><span class="line">    <span class="comment">// wake up blocked thread</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != blockedThread)</span><br><span class="line">        unpark(blockedThread)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，调用 joinBlocking 的线程就会被唤醒了！</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>本篇文章，总结了下协程常见的启动函数的原理，嗯嗯。</p>
<p>不同的启动模式有各自的特色，在特定场景使用才是关键。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Li Shuaiqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lishuaiqi.top/2025/05/25/kotlin/kotlin-cotoutine-launch-diff/">https://lishuaiqi.top/2025/05/25/kotlin/kotlin-cotoutine-launch-diff/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lishuaiqi.top">Li Shuaiqi's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B/">协程</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8/">协程启动</a></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2025/06/01/kotlin/kotlin-cotoutine-dispatcher_thread/"><i class="fa fa-chevron-left">  </i><span>kotlin 协程原理分析 - 协程线程池的原理</span></a></div><div class="next-post pull-right"><a href="/2025/05/12/kotlin/kotlin-cotoutine-coroutine_switch/"><span>kotlin 协程原理分析 - 协程的线程切换</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/img/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2025 By Li Shuaiqi</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>