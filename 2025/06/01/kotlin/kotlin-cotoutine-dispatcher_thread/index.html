<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="kotlin 协程原理分析 - 协程线程池的原理"><meta name="keywords" content="协程,协程启动"><meta name="author" content="Li Shuaiqi"><meta name="copyright" content="Li Shuaiqi"><title>kotlin 协程原理分析 - 协程线程池的原理 | Li Shuaiqi's Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '8.0.0'
} </script><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="Li Shuaiqi's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E5%89%8D%E8%A8%80"><span class="toc-text">0 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Main-%E5%88%86%E5%8F%91%E5%99%A8"><span class="toc-text">1 Main 分发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MainDispatcherLoader"><span class="toc-text">MainDispatcherLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AndroidDispatcherFactory"><span class="toc-text">AndroidDispatcherFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HandlerContext-dispatch"><span class="toc-text">HandlerContext.dispatch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Default-%E5%88%86%E5%8F%91%E5%99%A8"><span class="toc-text">2 Default 分发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DefaultScheduler"><span class="toc-text">DefaultScheduler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SchedulerCoroutineDispatcher"><span class="toc-text">SchedulerCoroutineDispatcher</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">线程池的配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CoroutineScheduler"><span class="toc-text">CoroutineScheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addToGlobalQueue"><span class="toc-text">addToGlobalQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatch"><span class="toc-text">dispatch</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Worker"><span class="toc-text">Worker</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#submitToLocalQueue"><span class="toc-text">submitToLocalQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#signalCpuWork"><span class="toc-text">signalCpuWork</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tryCreateWorker"><span class="toc-text">tryCreateWorker</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Worker-1"><span class="toc-text">Worker</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#findTask"><span class="toc-text">findTask</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-IO-%E5%88%86%E5%8F%91%E5%99%A8"><span class="toc-text">3 IO 分发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DefaultIoScheduler"><span class="toc-text">DefaultIoScheduler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LimitedDispatcher"><span class="toc-text">LimitedDispatcher</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatch-1"><span class="toc-text">dispatch</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#addAndTryDispatching"><span class="toc-text">addAndTryDispatching</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tryAllocateWorker"><span class="toc-text">tryAllocateWorker</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#run"><span class="toc-text">run</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Unconfined-%E5%88%86%E5%8F%91%E5%99%A8"><span class="toc-text">4 Unconfined 分发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unconfined"><span class="toc-text">Unconfined</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Li Shuaiqi</div><div class="author-info__description text-center">“Hi，我是李帅奇，Android 开发工程师。”</div><div class="follow-button"><a href="https://lishuaiqi.top">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">95</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">25</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">30</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">one more thing</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://juejin.cn/post/7366896388658593803">小二哥的 Android 站</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Li Shuaiqi's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">kotlin 协程原理分析 - 协程线程池的原理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2025-06-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kotlin/">kotlin</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kotlin/%E5%8D%8F%E7%A8%8B/">协程</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3k</span><span class="post-meta__separator">|</span><span>阅读时长: 13 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>从结构，原理等多个角度，简单分析下协程分发器和线程池的原理。</p>
<p>这里要说下协程的线程池和 java 线程池是不一样的，协程自己定制化了一套线程池逻辑。</p>
<h2 id="1-Main-分发器"><a href="#1-Main-分发器" class="headerlink" title="1 Main 分发器"></a>1 Main 分发器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmStatic</span></span><br><span class="line"><span class="keyword">public</span> actual val Main: MainCoroutineDispatcher <span class="title function_">get</span><span class="params">()</span> = MainDispatcherLoader.dispatcher</span><br></pre></td></tr></table></figure>
<h3 id="MainDispatcherLoader"><a href="#MainDispatcherLoader" class="headerlink" title="MainDispatcherLoader"></a>MainDispatcherLoader</h3><p>通过内部的 dispatcher 获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">val</span> <span class="variable">FAST_SERVICE_LOADER_ENABLED</span> <span class="operator">=</span> systemProp(FAST_SERVICE_LOADER_PROPERTY_NAME, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmField</span></span><br><span class="line">val dispatcher: MainCoroutineDispatcher = loadMainDispatcher()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">loadMainDispatcher</span><span class="params">()</span>: MainCoroutineDispatcher &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】可以看到这里通过快速途径：直接反射：kotlinx.coroutines.android.AndroidDispatcherFactory</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">factories</span> <span class="operator">=</span> <span class="keyword">if</span> (FAST_SERVICE_LOADER_ENABLED) &#123;</span><br><span class="line">            FastServiceLoader.loadMainDispatcherFactory()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【2】默认的 SPI 机制实现加载;</span></span><br><span class="line">            ServiceLoader.load(</span><br><span class="line">                    MainDispatcherFactory::class.java,</span><br><span class="line">                    MainDispatcherFactory::class.java.classLoader</span><br><span class="line">            ).iterator().asSequence().toList()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Suppress(&quot;ConstantConditionIf&quot;)</span></span><br><span class="line">        factories.maxByOrNull &#123; it.loadPriority &#125;?.tryCreateDispatcher(factories)</span><br><span class="line">            ?: createMissingDispatcher()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        <span class="comment">// Service loader can throw an exception as well</span></span><br><span class="line">        createMissingDispatcher(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SPI 通过 <code>ServiceLoader.load(MainDispatcherFactory::class.java)</code> 来：</p>
<ul>
<li>扫描 classpath 中所有 <code>META-INF/services/</code> 下的注册文件，并自动实例化所有找到的实现类</li>
<li>返回这些实现的集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kotlinx.coroutines.android.AndroidDispatcherFactory</span><br></pre></td></tr></table></figure>
<h3 id="AndroidDispatcherFactory"><a href="#AndroidDispatcherFactory" class="headerlink" title="AndroidDispatcherFactory"></a>AndroidDispatcherFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="keyword">class</span> <span class="title class_">AndroidDispatcherFactory</span> : MainDispatcherFactory &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】可以看到实际上就是对主线成 Looper 的封装；</span></span><br><span class="line">    override fun <span class="title function_">createDispatcher</span><span class="params">(allFactories: List&lt;MainDispatcherFactory&gt;)</span>: MainCoroutineDispatcher &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">mainLooper</span> <span class="operator">=</span> Looper.getMainLooper() ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;The main looper is not available&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> HandlerContext(mainLooper.asHandler(async = <span class="literal">true</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">hintOnError</span><span class="params">()</span>: String = <span class="string">&quot;For tests Dispatchers.setMain from kotlinx-coroutines-test module can be used&quot;</span></span><br><span class="line"></span><br><span class="line">    override val loadPriority: Int</span><br><span class="line">        <span class="title function_">get</span><span class="params">()</span> = Int.MAX_VALUE / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HandlerContext-dispatch"><a href="#HandlerContext-dispatch" class="headerlink" title="HandlerContext.dispatch"></a>HandlerContext.dispatch</h3><p>可以看到就是把协程丢到主线程中执行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override fun <span class="title function_">dispatch</span><span class="params">(context: CoroutineContext, block: Runnable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!handler.post(block)) &#123;</span><br><span class="line">        cancelOnRejection(context, block)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>挺简单的。</p>
<h2 id="2-Default-分发器"><a href="#2-Default-分发器" class="headerlink" title="2 Default 分发器"></a>2 Default 分发器</h2><p>Dispatchers.Default 和 Dispatchers.IO 是复用同一个线程池的，这里先来看 Default 分发器：</p>
<h3 id="DefaultScheduler"><a href="#DefaultScheduler" class="headerlink" title="DefaultScheduler"></a>DefaultScheduler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmStatic</span></span><br><span class="line"><span class="keyword">public</span> actual val Default: CoroutineDispatcher = DefaultScheduler</span><br></pre></td></tr></table></figure>
<p>核心在其父类：SchedulerCoroutineDispatcher</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance of Dispatchers.Default</span></span><br><span class="line">internal object DefaultScheduler : SchedulerCoroutineDispatcher(</span><br><span class="line">    CORE_POOL_SIZE, MAX_POOL_SIZE,</span><br><span class="line">    IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// Shuts down the dispatcher, used only by Dispatchers.shutdown()</span></span><br><span class="line">    internal fun <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overridden in case anyone writes (Dispatchers.Default as ExecutorCoroutineDispatcher).close()</span></span><br><span class="line">    override fun <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;Dispatchers.Default cannot be closed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">toString</span><span class="params">()</span>: String = <span class="string">&quot;Dispatchers.Default&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SchedulerCoroutineDispatcher"><a href="#SchedulerCoroutineDispatcher" class="headerlink" title="SchedulerCoroutineDispatcher"></a>SchedulerCoroutineDispatcher</h3><p>可以看到最后是 dispatch 到 CoroutineScheduler 对象内部去处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instantiated in tests so we can test it in isolation</span></span><br><span class="line">internal open <span class="keyword">class</span> <span class="title class_">SchedulerCoroutineDispatcher</span>(</span><br><span class="line">    <span class="keyword">private</span> val corePoolSize: Int = CORE_POOL_SIZE,</span><br><span class="line">    <span class="keyword">private</span> val maxPoolSize: Int = MAX_POOL_SIZE,</span><br><span class="line">    <span class="keyword">private</span> val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,</span><br><span class="line">    <span class="keyword">private</span> val schedulerName: String = <span class="string">&quot;CoroutineScheduler&quot;</span>,</span><br><span class="line">) : ExecutorCoroutineDispatcher() &#123;</span><br><span class="line"></span><br><span class="line">    override val executor: Executor</span><br><span class="line">        <span class="title function_">get</span><span class="params">()</span> = coroutineScheduler</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is variable for test purposes, so that we can reinitialize from clean state</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">var</span> <span class="variable">coroutineScheduler</span> <span class="operator">=</span> createScheduler()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> fun <span class="title function_">createScheduler</span><span class="params">()</span> =</span><br><span class="line">        CoroutineScheduler(corePoolSize, maxPoolSize, idleWorkerKeepAliveNs, schedulerName)</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">dispatch</span><span class="params">(context: CoroutineContext, block: Runnable)</span>: Unit = coroutineScheduler.dispatch(block)</span><br><span class="line">         </span><br></pre></td></tr></table></figure>
<h4 id="线程池的配置"><a href="#线程池的配置" class="headerlink" title="线程池的配置"></a>线程池的配置</h4><p>可以看到这里指定了：corePoolSize 和 maxPoolSize：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmField</span></span><br><span class="line">internal <span class="type">val</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> systemProp( <span class="comment">//【1】核心线程池数：取决于 cpu 的个数，最小为 2 </span></span><br><span class="line">    <span class="string">&quot;kotlinx.coroutines.scheduler.core.pool.size&quot;</span>,</span><br><span class="line">    AVAILABLE_PROCESSORS.coerceAtLeast(<span class="number">2</span>),</span><br><span class="line">    minValue = CoroutineScheduler.MIN_SUPPORTED_POOL_SIZE</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmField</span></span><br><span class="line">internal <span class="type">val</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> systemProp( <span class="comment">//【2】最大线程池数：可以视作无限大，1 shl 21 - 2， // 2M threads max  </span></span><br><span class="line">    <span class="string">&quot;kotlinx.coroutines.scheduler.max.pool.size&quot;</span>,</span><br><span class="line">    CoroutineScheduler.MAX_SUPPORTED_POOL_SIZE,</span><br><span class="line">    maxValue = CoroutineScheduler.MAX_SUPPORTED_POOL_SIZE</span><br><span class="line">)</span><br><span class="line">  </span><br><span class="line">internal const <span class="type">val</span> <span class="variable">MIN_SUPPORTED_POOL_SIZE</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">internal const <span class="type">val</span> <span class="variable">MAX_SUPPORTED_POOL_SIZE</span> <span class="operator">=</span> (<span class="number">1</span> shl BLOCKING_SHIFT) - <span class="number">2</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> const <span class="type">val</span> <span class="variable">BLOCKING_SHIFT</span> <span class="operator">=</span> <span class="number">21</span> <span class="comment">// 2M threads max  </span></span><br></pre></td></tr></table></figure>
<p>有什么区别呢，由于 default 和 io 公用一个线程池，所以：</p>
<ul>
<li>cool 用于 default 的，因为 default 用于 cpu 计算任务；</li>
<li>max - cool 用于 io 的，因为 io 用于 io 读写任务；</li>
</ul>
<p>由于 default 和 io 分发器复用了一套逻辑，那么接下来我们直接看 default 的逻辑。</p>
<h3 id="CoroutineScheduler"><a href="#CoroutineScheduler" class="headerlink" title="CoroutineScheduler"></a>CoroutineScheduler</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">CoroutineScheduler</span>(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> corePoolSize: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> maxPoolSize: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> idleWorkerKeepAliveNs: <span class="built_in">Long</span> = IDLE_WORKER_KEEP_ALIVE_NS,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> schedulerName: String = DEFAULT_SCHEDULER_NAME</span><br><span class="line">) : Executor, Closeable &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">       ... ... ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="keyword">val</span> globalCpuQueue = GlobalQueue() <span class="comment">// cpu 队列</span></span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="keyword">val</span> globalBlockingQueue = GlobalQueue() <span class="comment">// 阻塞队列</span></span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里是有 2 个队列的：</p>
<ul>
<li>globalCpuQueue 用于存放 cpu 类型的任务；</li>
<li>globalBlockingQueue 用于存放阻塞类型的任务；</li>
</ul>
<p>到底是哪个 queue，取决于是 default 还是 io 分发器。</p>
<h4 id="addToGlobalQueue"><a href="#addToGlobalQueue" class="headerlink" title="addToGlobalQueue"></a>addToGlobalQueue</h4><p>可以看到，这里会根据 Task 是否 blocking 添加到对应的 queue 中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">addToGlobalQueue</span><span class="params">(task: <span class="type">Task</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (task.isBlocking) &#123;</span><br><span class="line">        globalBlockingQueue.addLast(task)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        globalCpuQueue.addLast(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 的属性 taskContext 里面会记录是否 blocking。</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="keyword">val</span> Task.isBlocking <span class="keyword">get</span>() = taskContext.taskMode == TASK_PROBABLY_BLOCKING</span><br></pre></td></tr></table></figure>
<h4 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h4><p>协程分发执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="title function_">dispatch</span><span class="params">(block: Runnable, taskContext: TaskContext = NonBlockingContext, tailDispatch: Boolean = <span class="literal">false</span>)</span> &#123;</span><br><span class="line">    trackTask()</span><br><span class="line">    <span class="comment">//【1】创建一个 task，默认是 NonBlocking 的，返回的是一个 TaskImpl</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">task</span> <span class="operator">=</span> createTask(block, taskContext)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】尝试获取当前线程的 Worker 对象，Worker 就是线程对象在线程池中的描述。</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">currentWorker</span> <span class="operator">=</span> currentWorker()</span><br><span class="line">    <span class="type">val</span> <span class="variable">notAdded</span> <span class="operator">=</span> currentWorker.submitToLocalQueue(task, tailDispatch)</span><br><span class="line">    <span class="keyword">if</span> (notAdded != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!addToGlobalQueue(notAdded)) &#123; <span class="comment">// 不能 local 就 global</span></span><br><span class="line">            <span class="keyword">throw</span> RejectedExecutionException(<span class="string">&quot;$schedulerName was terminated&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">val</span> <span class="variable">skipUnpark</span> <span class="operator">=</span> tailDispatch &amp;&amp; currentWorker != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】这里根据不同的任务类型做不同的处理；</span></span><br><span class="line">    <span class="comment">// 启动不同的线程执行任务；  </span></span><br><span class="line">    <span class="keyword">if</span> (task.mode == TASK_NON_BLOCKING) &#123;</span><br><span class="line">        <span class="keyword">if</span> (skipUnpark) <span class="keyword">return</span> <span class="comment">// cpu 类型</span></span><br><span class="line">        signalCpuWork()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        signalBlockingWork(skipUnpark = skipUnpark) <span class="comment">// io 类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、是创建 Task 的逻辑，实际上是一个 TaskImpl 对象。</p>
<p>2、尝试获取当前线程的 Worker 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> fun <span class="title function_">currentWorker</span><span class="params">()</span>: Worker? = (Thread.currentThread() as? Worker)?.takeIf &#123; it.scheduler == <span class="built_in">this</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这是判断当前的 thread 是否是线程池的 Worker 线程:</p>
<h5 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h5><p>如下就是 Worker 线程，Thread 子类，注意看：</p>
<p>他内部有个 localQueue，本地任务队列，Worker 会优先执行本地任务队列中的任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">internal inner <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">private</span> <span class="title function_">constructor</span><span class="params">()</span> : Thread() &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        isDaemon = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    ... ... ...  </span><br><span class="line"></span><br><span class="line">    inline val scheduler <span class="title function_">get</span><span class="params">()</span> = <span class="built_in">this</span><span class="meta">@CoroutineScheduler</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    val localQueue: WorkQueue = WorkQueue() <span class="comment">//【1】本地任务;</span></span><br><span class="line">      </span><br><span class="line">    ... ... ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看：</p>
<p>3、如果是 Worker 线程的话，那么就直接添加到 Worker 内部的 localQueue 中去了，下面【3】可以看到距离的逻辑：</p>
<h5 id="submitToLocalQueue"><a href="#submitToLocalQueue" class="headerlink" title="submitToLocalQueue"></a>submitToLocalQueue</h5><p>注意如果是 task 是 cpu 类型的，而线程是用于处理 blocking 任务的，无法添加，直接返回；</p>
<p>因为 cpu 类型的任务需要对任务和 cpu 个数座做校验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> fun Worker?.submitToLocalQueue(task: Task, tailDispatch: Boolean): Task? &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) <span class="keyword">return</span> task</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(state === WorkerState.TERMINATED)</span> <span class="keyword">return</span> task</span><br><span class="line">    <span class="comment">//【1】注意如果是 task 是 cpu 类型的，而线程是用于处理 blocking 任务</span></span><br><span class="line">    <span class="comment">// 无法添加，直接返回 task；  </span></span><br><span class="line">    <span class="keyword">if</span> (task.mode == TASK_NON_BLOCKING &amp;&amp; state === WorkerState.BLOCKING) &#123;</span><br><span class="line">        <span class="keyword">return</span> task</span><br><span class="line">    &#125;</span><br><span class="line">    mayHaveLocalTasks = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//【2】添加到 localQueue;</span></span><br><span class="line">    <span class="keyword">return</span> localQueue.add(task, fair = tailDispatch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看：</p>
<p>4、signalBlockingWork 和 signalCpuWork 区别不大：核心都会走到  tryCreateWorker 方法中：</p>
<h5 id="signalCpuWork"><a href="#signalCpuWork" class="headerlink" title="signalCpuWork"></a>signalCpuWork</h5><p>核心就是：tryCreateWorker 的工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> fun <span class="title function_">signalBlockingWork</span><span class="params">(skipUnpark: Boolean)</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">stateSnapshot</span> <span class="operator">=</span> incrementBlockingTasks()</span><br><span class="line">    <span class="keyword">if</span> (skipUnpark) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (tryUnpark()) <span class="keyword">return</span> <span class="comment">// 尝试唤醒其他 Worker 工作</span></span><br><span class="line">    <span class="keyword">if</span> (tryCreateWorker(stateSnapshot)) <span class="keyword">return</span> <span class="comment">// 创建 Worker 对象；</span></span><br><span class="line">    tryUnpark() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun <span class="title function_">signalCpuWork</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryUnpark()) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (tryCreateWorker()) <span class="keyword">return</span>  <span class="comment">// 创建 Worker 对象；</span></span><br><span class="line">    tryUnpark()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="tryCreateWorker"><a href="#tryCreateWorker" class="headerlink" title="tryCreateWorker"></a>tryCreateWorker</h5><p>创建 Worker 线程对象。</p>
<p>可以看到这里对 cpu 类型的线程个数做了校验，不能超过 corePoolSize；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> fun <span class="title function_">tryCreateWorker</span><span class="params">(state: Long = controlState.value)</span>: Boolean &#123;</span><br><span class="line">    <span class="comment">//【1】再次创建 Worker 对象;</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">created</span> <span class="operator">=</span> createdWorkers(state)</span><br><span class="line">    <span class="comment">//【2】计算 blocking 任务的个数；</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">blocking</span> <span class="operator">=</span> blockingTasks(state)</span><br><span class="line">    <span class="comment">//【3】计算当前 cpu 线程的个数；</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">cpuWorkers</span> <span class="operator">=</span> (created - blocking).coerceAtLeast(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">//【4】有且当 cpu worker 的个数小于 corePoolSize 的时候，才允许创建线程 </span></span><br><span class="line">    <span class="keyword">if</span> (cpuWorkers &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">newCpuWorkers</span> <span class="operator">=</span> createNewWorker()</span><br><span class="line">        <span class="keyword">if</span> (newCpuWorkers == <span class="number">1</span> &amp;&amp; corePoolSize &gt; <span class="number">1</span>) createNewWorker()</span><br><span class="line">        <span class="keyword">if</span> (newCpuWorkers &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么它是如何计算的呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">val</span> <span class="variable">controlState</span> <span class="operator">=</span> atomic (corePoolSize.toLong() shl CPU_PERMITS_SHIFT) </span><br></pre></td></tr></table></figure>
<p><code>controlState</code> 是一个原子长整型变量，用于高效地管理线程池中工作线程的状态，这个 long 值的不同位段存储了不同的状态信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| created workers | CPU-acquired workers | blocking workers |</span><br><span class="line">|-----------------|----------------------|------------------|</span><br></pre></td></tr></table></figure>
<p>每个部分占用 <code>BLOCKING_SHIFT</code> 位（通常是 16 位或 32 位）。</p>
<p>blockingTasks 通过位运算的方式获取到了 blocking  线程的个数，</p>
<p>createdWorkers 通过位运算的方式获取到了当前所有的线程个数，相减就是 cpu 的线程个数了。</p>
<h4 id="Worker-1"><a href="#Worker-1" class="headerlink" title="Worker"></a>Worker</h4><p>最后看看 Worker 的执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">override fun <span class="title function_">run</span><span class="params">()</span> = runWorker() </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">runWorker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">rescanned</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">//【1】不断自旋;  </span></span><br><span class="line">    <span class="keyword">while</span> (!isTerminated &amp;&amp; state != WorkerState.TERMINATED) &#123;</span><br><span class="line">        <span class="comment">//【2】获取 Task</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">task</span> <span class="operator">=</span> findTask(mayHaveLocalTasks)</span><br><span class="line">        <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">            rescanned = <span class="type">false</span></span><br><span class="line">            <span class="variable">minDelayUntilStealableTaskNs</span> <span class="operator">=</span> <span class="number">0L</span></span><br><span class="line">            executeTask(task) <span class="comment">//【3】执行 Task;</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mayHaveLocalTasks = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minDelayUntilStealableTaskNs != <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rescanned) &#123;</span><br><span class="line">                rescanned = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rescanned = <span class="literal">false</span></span><br><span class="line">                <span class="title function_">tryReleaseCpu</span><span class="params">(WorkerState.PARKING)</span></span><br><span class="line">                interrupted()</span><br><span class="line">                LockSupport.parkNanos(minDelayUntilStealableTaskNs)</span><br><span class="line">                minDelayUntilStealableTaskNs = <span class="number">0L</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tryPark()</span><br><span class="line">    &#125;</span><br><span class="line">    tryReleaseCpu(WorkerState.TERMINATED)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="findTask"><a href="#findTask" class="headerlink" title="findTask"></a>findTask</h5><p>寻找任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="title function_">findTask</span><span class="params">(scanLocalQueue: Boolean)</span>: Task? &#123;</span><br><span class="line">    <span class="comment">//【1】尝试请求 cpu token，如果有权限，就从 cpu queue 中拿 Task;</span></span><br><span class="line">    <span class="comment">// 此时执行的是非阻塞任务；</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireCpuPermit()) <span class="keyword">return</span> findAnyTask(scanLocalQueue)</span><br><span class="line">    <span class="comment">//【3】此时执行阻塞任务，先 loacl 后 globalBlockingQueue；</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">if</span> (scanLocalQueue) &#123;</span><br><span class="line">        localQueue.poll() ?: globalBlockingQueue.removeFirstOrNull()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        globalBlockingQueue.removeFirstOrNull()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task ?: trySteal(blockingOnly = <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 default 线程池的一些逻辑。</p>
<h2 id="3-IO-分发器"><a href="#3-IO-分发器" class="headerlink" title="3 IO 分发器"></a>3 IO 分发器</h2><p>Dispatchers.IO 复用同一个线程池的，实现是 DefaultIoScheduler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmStatic</span></span><br><span class="line"><span class="keyword">public</span> val IO: CoroutineDispatcher = DefaultIoScheduler</span><br></pre></td></tr></table></figure>
<h3 id="DefaultIoScheduler"><a href="#DefaultIoScheduler" class="headerlink" title="DefaultIoScheduler"></a>DefaultIoScheduler</h3><p>可以看到，内部指定了一个 limitedParallelism 的属性：限制的最大并发个数，默认是 64。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> const val IO_PARALLELISM_PROPERTY_NAME: String = <span class="string">&quot;kotlinx.coroutines.io.parallelism&quot;</span></span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Dispatchers.IO</span></span><br><span class="line">internal object DefaultIoScheduler : ExecutorCoroutineDispatcher(), Executor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】这是创建分发器 LimitedDispatcher，限制了并发个数;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">default</span> <span class="operator">=</span> UnlimitedIoScheduler.limitedParallelism(</span><br><span class="line">        systemProp(</span><br><span class="line">            IO_PARALLELISM_PROPERTY_NAME,</span><br><span class="line">            <span class="number">64.</span>coerceAtLeast(AVAILABLE_PROCESSORS)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    override val executor: Executor</span><br><span class="line">        <span class="title function_">get</span><span class="params">()</span> = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">execute</span><span class="params">(command: java.lang.Runnable)</span> = dispatch(EmptyCoroutineContext, command)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line">    override fun <span class="title function_">limitedParallelism</span><span class="params">(parallelism: Int)</span>: CoroutineDispatcher &#123;</span><br><span class="line">        <span class="keyword">return</span> UnlimitedIoScheduler.limitedParallelism(parallelism)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">dispatch</span><span class="params">(context: CoroutineContext, block: Runnable)</span> &#123;</span><br><span class="line">        <span class="comment">//【2】通过 LimitedDispatcher 分发，参数 DispatchedContinuation 对象；</span></span><br><span class="line">        <span class="keyword">default</span>.dispatch(context, block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="LimitedDispatcher"><a href="#LimitedDispatcher" class="headerlink" title="LimitedDispatcher"></a>LimitedDispatcher</h3><p>LimitedDispatcher 用于限制协程调度器的并行度的一个分发器：</p>
<p>可以看到 dispatch 又交给了 DefaultScheduler 实现，注意此时设置的是 BlockingContext，也是是 blocking 阻塞任务；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】this 是 UnlimitedIoScheduler 实例，可以看到 dispatch 又交给了 DefaultScheduler 实现；</span></span><br><span class="line"><span class="keyword">private</span> object UnlimitedIoScheduler : CoroutineDispatcher() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InternalCoroutinesApi</span></span><br><span class="line">    override fun <span class="title function_">dispatchYield</span><span class="params">(context: CoroutineContext, block: Runnable)</span> &#123;</span><br><span class="line">        DefaultScheduler.dispatchWithContext(block, BlockingContext, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">dispatch</span><span class="params">(context: CoroutineContext, block: Runnable)</span> &#123;</span><br><span class="line">        DefaultScheduler.dispatchWithContext(block, BlockingContext, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LimitedDispatcher</span></span><br><span class="line"><span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line"><span class="keyword">public</span> open fun <span class="title function_">limitedParallelism</span><span class="params">(parallelism: Int)</span>: CoroutineDispatcher &#123;</span><br><span class="line">    parallelism.checkParallelism()</span><br><span class="line">    <span class="comment">//【1】分发到 LimitedDispatcher 里面;</span></span><br><span class="line">    <span class="keyword">return</span> LimitedDispatcher(<span class="built_in">this</span>, parallelism)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 LimitedDispatcher 内部的逻辑：</p>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>注意这里通过委托 by 实现了 Delay 功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="keyword">class</span> <span class="title class_">LimitedDispatcher</span>(</span><br><span class="line">    <span class="keyword">private</span> val dispatcher: CoroutineDispatcher,</span><br><span class="line">    <span class="keyword">private</span> val parallelism: Int</span><br><span class="line">) : CoroutineDispatcher(), Runnable, Delay <span class="title function_">by</span> <span class="params">(dispatcher as? Delay ?: DefaultDelay)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">var</span> <span class="variable">runningWorkers</span> <span class="operator">=</span> <span class="number">0</span> / </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">queue</span> <span class="operator">=</span> LockFreeTaskQueue&lt;Runnable&gt;(singleConsumer = <span class="literal">false</span>) <span class="comment">// cas 实现的无锁 queue;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// A separate object that we can synchronize on for K/N</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">workerAllocationLock</span> <span class="operator">=</span> SynchronizedObject()</span><br></pre></td></tr></table></figure>
<p>这里看到了一个由<code>by</code>关键字实现的委托属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Delay <span class="title function_">by</span> <span class="params">(dispatcher as? Delay ?: DefaultDelay)</span></span><br></pre></td></tr></table></figure>
<p>表示<code>LimitedDispatcher</code>将<code>Delay</code>接口的实现委托给另一个对象。具体来说：</p>
<ul>
<li>如果<code>dispatcher</code>（即被包装的分发器参数）实现了<code>Delay</code>接口，那么就直接使用<code>dispatcher</code>的<code>Delay</code>功能。</li>
<li>如果<code>dispatcher</code>没有实现<code>Delay</code>接口，那么就使用<code>DefaultDelay</code>。</li>
</ul>
<p><code>DefaultDelay</code>是 Kotlin 协程库中提供的一个默认的<code>Delay</code>实现，通常基于事件循环（例如在 JVM 上使用<code>ScheduledExecutorService</code>）来实现延迟。</p>
<h4 id="dispatch-1"><a href="#dispatch-1" class="headerlink" title="dispatch"></a>dispatch</h4><p>回过头来，LimitedDispatcher 内部的分发机制如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">override fun <span class="title function_">dispatch</span><span class="params">(context: CoroutineContext, block: Runnable)</span> &#123;</span><br><span class="line">    dispatchInternal(block) &#123;</span><br><span class="line">        <span class="comment">//【1】使用 DefaultScheduler 分发，复用一套线程池；</span></span><br><span class="line">        dispatcher.dispatch(<span class="built_in">this</span>, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【2】这是对任务执行的条件做了一些校验</span></span><br><span class="line"><span class="keyword">private</span> inline fun <span class="title function_">dispatchInternal</span><span class="params">(block: Runnable, dispatch: ()</span> -&gt; Unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addAndTryDispatching(block)) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAllocateWorker()) <span class="keyword">return</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//【3】执行分发</span></span><br><span class="line">    dispatch()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="addAndTryDispatching"><a href="#addAndTryDispatching" class="headerlink" title="addAndTryDispatching"></a>addAndTryDispatching</h5><p>先添加到内部的并发队列中，然后判断 runningWorkers 是否超过了 parallelism 指定的数量，如果超过了，那就不会分发;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> fun <span class="title function_">addAndTryDispatching</span><span class="params">(block: Runnable)</span>: Boolean &#123;</span><br><span class="line">    queue.addLast(block)</span><br><span class="line">    <span class="keyword">return</span> runningWorkers &gt;= parallelism</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="tryAllocateWorker"><a href="#tryAllocateWorker" class="headerlink" title="tryAllocateWorker"></a>tryAllocateWorker</h5><p>分配 Worker 线程，这里只是计数而已，分配在线程池：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker分配</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">tryAllocateWorker</span><span class="params">()</span>: Boolean &#123;</span></span><br><span class="line">    <span class="built_in">synchronized</span>(workerAllocationLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runningWorkers &gt;= parallelism) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="comment">//【1】计数+1  </span></span><br><span class="line">        ++runningWorkers</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后看看任务执行：</p>
<h5 id="run"><a href="#run" class="headerlink" title="run"></a>run</h5><p>LimitedDispatcher 自身会被作为 task 丢到线程之中执行，run 方法会不断的自旋，读取 queue 队列里面 DispatchContinuation 对象执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">override fun <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">fairnessCounter</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">task</span> <span class="operator">=</span> queue.removeFirstOrNull()</span><br><span class="line">        <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【1】执行 DispatchContinuation；</span></span><br><span class="line">                task.run()</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">                handleCoroutineException(EmptyCoroutineContext, e)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 16 is our out-of-thin-air constant to emulate fairness. Used in JS dispatchers as well</span></span><br><span class="line">            <span class="keyword">if</span> (++fairnessCounter &gt;= <span class="number">16</span> &amp;&amp; dispatcher.isDispatchNeeded(<span class="built_in">this</span>)) &#123;</span><br><span class="line">                <span class="comment">// Do &quot;yield&quot; to let other views to execute their runnable as well</span></span><br><span class="line">                <span class="comment">// Note that we do not decrement &#x27;runningWorkers&#x27; as we still committed to do our part of work</span></span><br><span class="line">                dispatcher.dispatch(<span class="built_in">this</span>, <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【2】引用计数调整;</span></span><br><span class="line">        <span class="keyword">synchronized</span>(workerAllocationLock) &#123;</span><br><span class="line">            --runningWorkers</span><br><span class="line">            <span class="title function_">if</span> <span class="params">(queue.size == <span class="number">0</span>)</span> <span class="keyword">return</span></span><br><span class="line">            ++<span class="type">runningWorkers</span></span><br><span class="line">            <span class="variable">fairnessCounter</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 IO 分发器的逻辑。</p>
<h2 id="4-Unconfined-分发器"><a href="#4-Unconfined-分发器" class="headerlink" title="4 Unconfined 分发器"></a>4 Unconfined 分发器</h2><p>最后看看 Unconfined 分发器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmStatic</span></span><br><span class="line"><span class="keyword">public</span> actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined</span><br></pre></td></tr></table></figure>
<h3 id="Unconfined"><a href="#Unconfined" class="headerlink" title="Unconfined"></a>Unconfined</h3><p>Unconfined 分发器，表示不明确指定具体的线程。</p>
<p>isDispatchNeeded 这里为 false，那么就会在调用者的线程中执行，也就是<strong>在当前线程</strong>执行，而不是被分发到其他线程。</p>
<p>所以你可以看到 dispatch 里面没有执行  block: Runnable 的任何代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">internal object Unconfined : CoroutineDispatcher() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line">    override fun <span class="title function_">limitedParallelism</span><span class="params">(parallelism: Int)</span>: CoroutineDispatcher &#123;</span><br><span class="line">        <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;limitedParallelism is not supported for Dispatchers.Unconfined&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】isDispatchNeeded 这里为 false，那么就会在调用者的线程中执行，也就是在当前线程 执行，而不是被分发到其他线程。</span></span><br><span class="line">    override fun <span class="title function_">isDispatchNeeded</span><span class="params">(context: CoroutineContext)</span>: Boolean = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">dispatch</span><span class="params">(context: CoroutineContext, block: Runnable)</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">yieldContext</span> <span class="operator">=</span> context[YieldContext]</span><br><span class="line">        <span class="keyword">if</span> (yieldContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            yieldContext.dispatcherWasUnconfined = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;Dispatchers.Unconfined.dispatch function can only be used by the yield function. &quot;</span> +</span><br><span class="line">            <span class="string">&quot;If you wrap Unconfined dispatcher in your code, make sure you properly delegate &quot;</span> +</span><br><span class="line">            <span class="string">&quot;isDispatchNeeded and dispatch calls.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun <span class="title function_">toString</span><span class="params">()</span>: String = <span class="string">&quot;Dispatchers.Unconfined&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Li Shuaiqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lishuaiqi.top/2025/06/01/kotlin/kotlin-cotoutine-dispatcher_thread/">https://lishuaiqi.top/2025/06/01/kotlin/kotlin-cotoutine-dispatcher_thread/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lishuaiqi.top">Li Shuaiqi's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B/">协程</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8/">协程启动</a></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/2025/05/25/kotlin/kotlin-cotoutine-launch-diff/"><span>kotlin 协程原理分析 - 启动方式比较分析</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/img/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2025 By Li Shuaiqi</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>