<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Li Shuaiqi&#39;s Blog</title>
  
  <subtitle>Every day is always sleepy.</subtitle>
  <link href="https://lishuaiqi.top/atom.xml" rel="self"/>
  
  <link href="https://lishuaiqi.top/"/>
  <updated>2025-10-22T16:38:09.211Z</updated>
  <id>https://lishuaiqi.top/</id>
  
  <author>
    <name>Li Shuaiqi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kotlin 协程原理分析 - Flow 启动原理和 Rxjava 的比较</title>
    <link href="https://lishuaiqi.top/2025/07/01/kotlin/kotlin-cotoutine-flow-start/"/>
    <id>https://lishuaiqi.top/2025/07/01/kotlin/kotlin-cotoutine-flow-start/</id>
    <published>2025-07-01T12:46:25.000Z</published>
    <updated>2025-10-22T16:38:09.211Z</updated>
    
    
    
    
    <category term="kotlin" scheme="https://lishuaiqi.top/categories/kotlin/"/>
    
    <category term="协程" scheme="https://lishuaiqi.top/categories/kotlin/%E5%8D%8F%E7%A8%8B/"/>
    
    
    <category term="协程" scheme="https://lishuaiqi.top/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="Flow" scheme="https://lishuaiqi.top/tags/Flow/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 协程原理分析 - 协程线程池的原理</title>
    <link href="https://lishuaiqi.top/2025/06/01/kotlin/kotlin-cotoutine-dispatcher_thread/"/>
    <id>https://lishuaiqi.top/2025/06/01/kotlin/kotlin-cotoutine-dispatcher_thread/</id>
    <published>2025-06-01T12:46:25.000Z</published>
    <updated>2025-10-22T15:24:06.244Z</updated>
    
    
    
    
    <category term="kotlin" scheme="https://lishuaiqi.top/categories/kotlin/"/>
    
    <category term="协程" scheme="https://lishuaiqi.top/categories/kotlin/%E5%8D%8F%E7%A8%8B/"/>
    
    
    <category term="协程" scheme="https://lishuaiqi.top/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="协程启动" scheme="https://lishuaiqi.top/tags/%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 协程原理分析 - 启动方式比较分析</title>
    <link href="https://lishuaiqi.top/2025/05/25/kotlin/kotlin-cotoutine-launch-diff/"/>
    <id>https://lishuaiqi.top/2025/05/25/kotlin/kotlin-cotoutine-launch-diff/</id>
    <published>2025-05-25T12:46:25.000Z</published>
    <updated>2025-10-23T19:08:21.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>基于微模型，分析下协程常见的启动方式的差异和对比。</p><p>常见的启动方式有：launch、async、runblock 下面会对比分析下三者的区别。</p><p>细节就不讲了，都是微模型的那一套，区别在于启动方式、异常机制、分发器等的不同，这个后续在分析。</p><h2 id="1-launch-启动"><a href="#1-launch-启动" class="headerlink" title="1 launch 启动"></a>1 launch 启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> fun CoroutineScope.launch(</span><br><span class="line">    context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; Unit</span><br><span class="line">): Job &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">newContext</span> <span class="operator">=</span> newCoroutineContext(context)</span><br><span class="line">    <span class="type">val</span> <span class="variable">coroutine</span> <span class="operator">=</span> <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是 launch 启动的核心逻辑。</p><p>默认模式下的 launch 启动，job 是 StandaloneCoroutine，这种情况是立刻会启动该协程。</p><p>launch 也是支持 isLazy 启动的，job 是 LazyStandaloneCoroutine，我们看看二者的区别</p><h3 id="StandaloneCoroutine"><a href="#StandaloneCoroutine" class="headerlink" title="StandaloneCoroutine"></a>StandaloneCoroutine</h3><p>标准 DEFAULT 启动，这里是在后续 CoroutineStart 的时候会直接启动协程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> open <span class="keyword">class</span> <span class="title class_">StandaloneCoroutine</span>(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    active: Boolean</span><br><span class="line">) : AbstractCoroutine&lt;Unit&gt;(parentContext, initParentJob = <span class="literal">true</span>, active = active) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//【1】异常处理机制;</span></span><br><span class="line">    override fun <span class="title function_">handleJobException</span><span class="params">(exception: Throwable)</span>: Boolean &#123;</span><br><span class="line">        handleCoroutineException(context, exception)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LazyStandaloneCoroutine"><a href="#LazyStandaloneCoroutine" class="headerlink" title="LazyStandaloneCoroutine"></a>LazyStandaloneCoroutine</h3><p>他是 StandaloneCoroutine 的扩展，所以具有一样的异常处理机制。</p><p>延迟启动，可以看到这里他把 block 存起来了，在 onStart 方法的时候会创建协程体，然后执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LazyStandaloneCoroutine</span>(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; Unit</span><br><span class="line">) : StandaloneCoroutine(parentContext, active = <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">//【1】这里是 continuation 对象;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">continuation</span> <span class="operator">=</span> block.createCoroutineUnintercepted(<span class="built_in">this</span>, <span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//【2】通过 start 延迟启动协程，会走到这里;;</span></span><br><span class="line">        continuation.startCoroutineCancellable(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：onStart 方法：</p><h4 id="onStart"><a href="#onStart" class="headerlink" title="onStart()"></a>onStart()</h4><p>这里是通过 start 方法延迟启动的回调，下面会分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">override fun <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//【1】通过 start 延迟启动协程，会走到这里;;</span></span><br><span class="line">    continuation.startCoroutineCancellable(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CoroutineStart"><a href="#CoroutineStart" class="headerlink" title="CoroutineStart"></a>CoroutineStart</h3><p>任何启动方式，都会最后都会到 CoroutineStart 这个地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行 invoke 函数;;</span></span><br><span class="line"><span class="meta">@InternalCoroutinesApi</span></span><br><span class="line"><span class="keyword">public</span> operator fun &lt;R, T&gt; invoke(block: suspend R.() -&gt; T, receiver: R, completion: Continuation&lt;T&gt;): Unit =</span><br><span class="line">    <span class="keyword">when</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion) <span class="comment">// 如果是 DEFAULT，立刻启动;</span></span><br><span class="line">        ATOMIC -&gt; block.startCoroutine(receiver, completion)</span><br><span class="line">        UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)</span><br><span class="line">        LAZY -&gt; Unit <span class="comment">// 如果是 LAZY，那么延迟启动;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>DEFAULT，立刻启动，不多说了；</p><h4 id="LAZY-模式通过-start-启动"><a href="#LAZY-模式通过-start-启动" class="headerlink" title="LAZY 模式通过 start 启动"></a>LAZY 模式通过 start 启动</h4><p>懒加载启动方式，例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">conx</span> <span class="operator">=</span> GlobalScope.launch(start = CoroutineStart.LAZY) &#123;</span><br><span class="line">    println(<span class="string">&quot;GlobalScope 协程开始执行&quot;</span>)</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        println(<span class="string">&quot;线程切换执行完毕！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 start 方法启动</span></span><br><span class="line">conx.start()</span><br></pre></td></tr></table></figure><h4 id="JobSupport-start"><a href="#JobSupport-start" class="headerlink" title="JobSupport.start"></a>JobSupport.start</h4><p>start 具体的实现是是在 AbstractCoroutine 的父接口 JobSupport 里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override fun <span class="title function_">start</span><span class="params">()</span>: Boolean &#123;</span><br><span class="line">    loopOnState &#123; state -&gt;</span><br><span class="line">        <span class="keyword">when</span> (startInternal(state)) &#123; <span class="comment">// qi</span></span><br><span class="line">            FALSE -&gt; <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            TRUE -&gt; <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【1】startInternal</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">startInternal</span><span class="params">(state: Any?)</span>: Int &#123;</span><br><span class="line">    <span class="keyword">when</span> (state) &#123;</span><br><span class="line">        is Empty -&gt; &#123; <span class="comment">// EMPTY_X state -- no completion handlers</span></span><br><span class="line">            <span class="keyword">if</span> (state.isActive) <span class="keyword">return</span> FALSE <span class="comment">// already active</span></span><br><span class="line">            <span class="keyword">if</span> (!_state.compareAndSet(state, EMPTY_ACTIVE)) <span class="keyword">return</span> RETRY</span><br><span class="line">            <span class="comment">//【1】这里触发 onStart 启动;</span></span><br><span class="line">            onStart()</span><br><span class="line">            <span class="keyword">return</span> TRUE</span><br><span class="line">        &#125;</span><br><span class="line">        is InactiveNodeList -&gt; &#123; <span class="comment">// LIST state -- inactive with a list of completion handlers</span></span><br><span class="line">            <span class="keyword">if</span> (!_state.compareAndSet(state, state.list)) <span class="keyword">return</span> RETRY</span><br><span class="line">            <span class="title function_">onStart</span><span class="params">()</span></span><br><span class="line">            <span class="keyword">return</span> TRUE</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">return</span> FALSE <span class="comment">// not a new state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里调用了 onStart() 方法，</p><h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join 方法"></a>join 方法</h3><p>和 launch 方法对应的有个 join 方法，用于等待协程执行完成，如下是例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">conx</span> <span class="operator">=</span> CoroutineScope(Dispatchers.IO).launch(start = CoroutineStart.DEFAULT) &#123;</span><br><span class="line">        println(<span class="string">&quot;GlobalScope 协程开始执行&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.IO) &#123;</span><br><span class="line">            println(<span class="string">&quot;线程切换执行完毕！&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挂起函数;</span></span><br><span class="line">    conx.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>join 的原理是什么呢？</p><h4 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h4><p>接口在 JobSupport 中：</p><h4 id="JobSupport"><a href="#JobSupport" class="headerlink" title="JobSupport"></a>JobSupport</h4><h5 id="join-–-gt-joinSuspend"><a href="#join-–-gt-joinSuspend" class="headerlink" title="join –&gt; joinSuspend"></a>join –&gt; joinSuspend</h5><p>执行挂起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】JobSupport</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override suspend fun <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!joinInternal()) &#123; <span class="comment">// fast-path no wait</span></span><br><span class="line">        coroutineContext.ensureActive()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// do not suspend</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】核心 joinSuspend;</span></span><br><span class="line">    <span class="keyword">return</span> joinSuspend() <span class="comment">// slow-path wait</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// joinSuspend 是一个挂起函数;</span></span><br><span class="line"><span class="comment">// cont 是 CancellableContinuationImpl 对象，CancellableContinuationImpl 会包裹 DispatchedContinuation 对象;</span></span><br><span class="line"><span class="keyword">private</span> suspend fun <span class="title function_">joinSuspend</span><span class="params">()</span> = suspendCancellableCoroutine&lt;Unit&gt; &#123; cont -&gt;</span><br><span class="line">    <span class="comment">// invokeOnCompletion 注册一个完成回调处理对象；</span></span><br><span class="line">    <span class="comment">// disposeOnCancellation 用于在协程取消时自动清理资源；</span></span><br><span class="line">    cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(cont).asHandler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【2】ResumeOnCompletion 执行结束通知对象；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ResumeOnCompletion</span>(</span><br><span class="line">    <span class="keyword">private</span> val continuation: Continuation&lt;Unit&gt;</span><br><span class="line">) : JobNode() &#123;</span><br><span class="line">    <span class="comment">//【2.1】回复外面的协程;</span></span><br><span class="line">    override fun <span class="title function_">invoke</span><span class="params">(cause: Throwable?)</span> = continuation.resume(Unit)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类 JobNode，其中 asHandler 是 CompletionHandlerBase 扩展函数，返回的是 this，这个不多说，可以自己去跟跟代码；</span></span><br><span class="line">internal <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">JobNode</span> : CompletionHandlerBase(), DisposableHandle, Incomplete &#123;</span><br><span class="line">  ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cont 是 CancellableContinuationImpl 对象，分析 suspend 函数的时候有分析过。</p><p>ResumeOnCompletion 是一个执行结束通知对象，这里是用于在当前协程执行完成后通知外部协程，其中 asHandler 是扩展函数，返回的是 this，这个不多说，可以自己去跟跟代码。</p><h5 id="makeNode"><a href="#makeNode" class="headerlink" title="makeNode"></a>makeNode</h5><p>先看这个方法，创建节点，将 ResumeOnCompletion 对象封装 成一个 JobNode，同时关联 Job，然后会保存到当前协程内部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> fun <span class="title function_">makeNode</span><span class="params">(handler: CompletionHandler, onCancelling: Boolean)</span>: JobNode &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">if</span> (onCancelling) &#123; </span><br><span class="line">        (handler as? JobCancellingNode) ?: InvokeOnCancelling(handler) <span class="comment">//【1】包装为取消节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (handler as? JobNode)?.also &#123; <span class="keyword">assert</span> &#123; it !is JobCancellingNode &#125; &#125;</span><br><span class="line">            ?: InvokeOnCompletion(handler) <span class="comment">//【2】包装为完成节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    node.job = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InvokeOnCompletion 节点;;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InvokeOnCompletion</span>(</span><br><span class="line">    <span class="keyword">private</span> val handler: CompletionHandler</span><br><span class="line">) : JobNode()  &#123;</span><br><span class="line">    override fun <span class="title function_">invoke</span><span class="params">(cause: Throwable?)</span> = handler.invoke(cause)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>InvokeOnCancelling</code>: 包装为取消节点；</li><li><code>InvokeOnCompletion</code>: 包装为完成节点；</li></ul><p>具体的细节，你们可以自己跟跟代码。</p><h5 id="invokeOnCompletion-注册一个完成回调对象"><a href="#invokeOnCompletion-注册一个完成回调对象" class="headerlink" title="invokeOnCompletion 注册一个完成回调对象"></a>invokeOnCompletion 注册一个完成回调对象</h5><p>这个代码看起来复杂的，其实也不简单，核心逻辑是：根据当前的 job 的 state 状态，注册 ResumeOnCompletion 对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override fun <span class="title function_">invokeOnCompletion</span><span class="params">(</span></span><br><span class="line"><span class="params">    onCancelling: Boolean, // <span class="literal">false</span></span></span><br><span class="line"><span class="params">    invokeImmediately: Boolean, // <span class="literal">true</span></span></span><br><span class="line"><span class="params">    handler: CompletionHandler</span></span><br><span class="line"><span class="params">)</span>: DisposableHandle &#123;</span><br><span class="line">    <span class="comment">//【1】创建回调对应的 node 节点;</span></span><br><span class="line">    val node: JobNode = makeNode(handler, onCancelling)</span><br><span class="line">    loopOnState &#123; state -&gt;</span><br><span class="line">        <span class="keyword">when</span> (state) &#123;</span><br><span class="line">            is Empty -&gt; &#123; <span class="comment">// EMPTY_X state -- no completion handlers</span></span><br><span class="line">                <span class="keyword">if</span> (state.isActive) &#123;</span><br><span class="line">                    <span class="comment">// try move to SINGLE state</span></span><br><span class="line">                    <span class="keyword">if</span> (_state.compareAndSet(state, node)) <span class="keyword">return</span> node</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    promoteEmptyToNodeList(state) <span class="comment">// that way we can add listener for non-active coroutine</span></span><br><span class="line">            &#125;</span><br><span class="line">            is Incomplete -&gt; &#123; <span class="comment">//【2】当前 job 还没有执行完成;</span></span><br><span class="line">                <span class="type">val</span> <span class="variable">list</span> <span class="operator">=</span> state.list</span><br><span class="line">                <span class="title function_">if</span> <span class="params">(list == <span class="literal">null</span>)</span> &#123; <span class="comment">// SINGLE/SINGLE+</span></span><br><span class="line">                    promoteSingleToNodeList(state as JobNode)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> rootCause: Throwable? = <span class="literal">null</span></span><br><span class="line">                    <span class="keyword">var</span> handle: DisposableHandle = NonDisposableHandle</span><br><span class="line">                    <span class="comment">// 这里和取消相关，暂时不关注;</span></span><br><span class="line">                    <span class="keyword">if</span> (onCancelling &amp;&amp; state is Finishing) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span>(state) &#123;</span><br><span class="line">                            rootCause = state.rootCause <span class="comment">// != null if cancelling job</span></span><br><span class="line">                            <span class="keyword">if</span> (rootCause == <span class="literal">null</span> || handler.isHandlerOf&lt;ChildHandleNode&gt;() &amp;&amp; !state.isCompleting) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!addLastAtomic(state, list, node)) <span class="keyword">return</span><span class="meta">@loopOnState</span> <span class="comment">// retry</span></span><br><span class="line">                                <span class="keyword">if</span> (rootCause == <span class="literal">null</span>) <span class="keyword">return</span> <span class="type">node</span></span><br><span class="line">                                <span class="variable">handle</span> <span class="operator">=</span> node</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (rootCause != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (invokeImmediately) handler.invokeIt(rootCause)</span><br><span class="line">                        <span class="keyword">return</span> handle</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//【2】核心逻辑：将前面的 ResumeOnCompletion 对应的 Node 添加到 state.list 中记录下来；</span></span><br><span class="line">                        <span class="keyword">if</span> (addLastAtomic(state, list, node)) <span class="keyword">return</span> node</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                <span class="comment">//【3】当前 job 已经执行完成，立刻执行 ResumeOnCompletion 的 invoke 函数。</span></span><br><span class="line">                <span class="comment">// 通知外部协程执行结束，resumeWith;</span></span><br><span class="line">                <span class="keyword">if</span> (invokeImmediately) handler.invokeIt((state as? CompletedExceptionally)?.cause)</span><br><span class="line">                <span class="keyword">return</span> NonDisposableHandle</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将前面的 ResumeOnCompletion 对应的 Node 添加到 state.list 中记录下来；</p><h5 id="completeStateFinalization"><a href="#completeStateFinalization" class="headerlink" title="completeStateFinalization"></a>completeStateFinalization</h5><p>当前协程执行完成后，会触发到这个函数，在这里会统一的通过  state.list 里面记录的 Node 来间接 resume 外部的协程；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// job 的 resumeWith</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override fun <span class="title function_">resumeWith</span><span class="params">(result: Result&lt;T&gt;)</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">state</span> <span class="operator">=</span> makeCompletingOnce(result.toState())</span><br><span class="line">    <span class="keyword">if</span> (state === COMPLETING_WAITING_CHILDREN) <span class="keyword">return</span></span><br><span class="line">    afterResume(state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// suppressed == true when any exceptions were suppressed while building the final completion cause</span></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">completeStateFinalization</span><span class="params">(state: Incomplete, update: Any?)</span> &#123;</span><br><span class="line">    parentHandle?.let &#123;</span><br><span class="line">        it.dispose() </span><br><span class="line">        parentHandle = NonDisposableHandle</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">val</span> <span class="variable">cause</span> <span class="operator">=</span> (update as? CompletedExceptionally)?.cause</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 2) Invoke completion handlers: .join(), callbacks etc.</span></span><br><span class="line"><span class="comment">     *    It&#x27;s important to invoke them only AFTER exception handling and everything else, see #208</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (state is JobNode) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            state.invoke(cause)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex: Throwable) &#123;</span><br><span class="line">            handleOnCompletionException(CompletionHandlerException(<span class="string">&quot;Exception in completion handler $state for $this&quot;</span>, ex))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【1】核心逻辑：</span></span><br><span class="line">        state.list?.notifyCompletion(cause)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>1、调用 join() 函数的协程体会被封装成一个 Node 节点，添加到被等待的协程的 job 的 state.list。</li><li>2、被等待的协程执行完成后，会通知对应的 job，job 会在  completeStateFinalization 中遍历  state.list 唤醒外面的等待的协程。</li></ul><h2 id="2-async-启动"><a href="#2-async-启动" class="headerlink" title="2 async 启动"></a>2 async 启动</h2><p>我们来看看 async 启动的核心逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> fun &lt;T&gt; CoroutineScope.async(</span><br><span class="line">    context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; T</span><br><span class="line">): Deferred&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">newContext</span> <span class="operator">=</span> newCoroutineContext(context)</span><br><span class="line">    <span class="type">val</span> <span class="variable">coroutine</span> <span class="operator">=</span> <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyDeferredCoroutine(newContext, block) <span class="keyword">else</span> <span class="comment">// y</span></span><br><span class="line">        DeferredCoroutine&lt;T&gt;(newContext, active = <span class="literal">true</span>) <span class="comment">// 默认启动</span></span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下：async 也是通过 DEFAULT 方式启动，并且是立刻启动。</p><h3 id="协程体的差异"><a href="#协程体的差异" class="headerlink" title="协程体的差异"></a>协程体的差异</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block: suspend CoroutineScope.() -&gt; T</span><br></pre></td></tr></table></figure><p>这里能看出，async 的 block 是有返回值的。</p><p>对应的编译脚本生成的 SuspendLambda 的 invokeSuspend 函数的返回值会被强转为 T 类型！</p><p>同时，也会将 invokeSuspend 返回的结果，通过 completion.resumeWith 传递给 Job。</p><p>这个和 launch 启动的协程是不一样的，launch 协程返回值是 unit，和 java void 是一个意思。</p><h3 id="LAZY-模式通过-start-启动-1"><a href="#LAZY-模式通过-start-启动-1" class="headerlink" title="LAZY 模式通过 start 启动"></a>LAZY 模式通过 start 启动</h3><p>对于 lazy 方式，async 也是支持的，配合 start() 方法就行了。</p><p>这个不多讲了，和 launch 没啥太大区别。</p><h3 id="DeferredCoroutine"><a href="#DeferredCoroutine" class="headerlink" title="DeferredCoroutine"></a>DeferredCoroutine</h3><p>如果是默认启动类型的话，那么走的是 DeferredCoroutine，LazyDeferredCoroutine 是 DeferredCoroutine 的子类。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">DeferredCoroutine</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    active: <span class="built_in">Boolean</span></span><br><span class="line">) : AbstractCoroutine&lt;T&gt;(parentContext, <span class="literal">true</span>, active = active), Deferred&lt;T&gt;, SelectClause1&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCompleted</span><span class="params">()</span></span>: T = getCompletedInternal() <span class="keyword">as</span> T</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">await</span><span class="params">()</span></span>: T = awaitInternal() <span class="keyword">as</span> T</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> onAwait: SelectClause1&lt;T&gt; <span class="keyword">get</span>() = <span class="keyword">this</span> <span class="comment">// 和 select 有关系，这里先不关注～</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">registerSelectClause1</span><span class="params">(select: <span class="type">SelectInstance</span>&lt;<span class="type">R</span>&gt;, block: <span class="type">suspend</span> (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span> =</span><br><span class="line">        registerSelectClause1Internal(select, block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其支持 await() 方法，其他协程能够通过 await() 实现。</p><p>onAwait 和 registerSelectClause1 是配合 select 操作符实现对多个协程体进行监听的逻辑，这里我们不多关注先。</p><h3 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h3><p>我们看一下 await 是如何拿到 async 的执行结果的，逻辑是不是和 launch 一样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> suspend fun <span class="title function_">awaitSuspend</span><span class="params">()</span>: Any? = suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt; </span><br><span class="line">    <span class="type">val</span> <span class="variable">cont</span> <span class="operator">=</span> AwaitContinuation(uCont.intercepted(), <span class="built_in">this</span>)</span><br><span class="line">    cont.initCancellability()</span><br><span class="line">    cont.disposeOnCancellation(invokeOnCompletion(ResumeAwaitOnCompletion(cont).asHandler))</span><br><span class="line">    cont.getResult()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然是一样的操作。</p><ul><li>onAwait 本质上就是一个挂起函数，所以外部协程会挂起。</li><li>invokeOnCompletion 依然是创建了一个 Node 节点，加入到当前协程 job 的 state.list 中</li><li>最后统一唤醒。</li></ul><p>其实 await 就是特殊的 join，join 传递的结果是特殊的 Unit 而已。</p><h2 id="3-runBlocking-启动"><a href="#3-runBlocking-启动" class="headerlink" title="3 runBlocking 启动"></a>3 runBlocking 启动</h2><p>最后看看 runBlocking，已经 runBlocking 的阻塞线程原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suspend fun <span class="title function_">main</span><span class="params">()</span> = runBlocking &#123;</span><br><span class="line">... ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(InterruptedException::class)</span></span><br><span class="line"><span class="keyword">public</span> actual fun &lt;T&gt; runBlocking(context: CoroutineContext, block: suspend CoroutineScope.() -&gt; T): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">val</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】获取 Dispatchers 方法。</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">contextInterceptor</span> <span class="operator">=</span> context[ContinuationInterceptor]</span><br><span class="line">    val eventLoop: EventLoop?</span><br><span class="line">    val newContext: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】根据是否指定 Dispatchers 做处理。</span></span><br><span class="line">    <span class="comment">// 如果没有指定 Dispatchers，那么采用的是 ThreadLocalEventLoop。</span></span><br><span class="line">    <span class="keyword">if</span> (contextInterceptor == <span class="literal">null</span>) &#123;</span><br><span class="line">        eventLoop = ThreadLocalEventLoop.<span class="type">eventLoop</span></span><br><span class="line">        <span class="variable">newContext</span> <span class="operator">=</span> GlobalScope.newCoroutineContext(context + eventLoop)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果指定了 Dispatchers，看看是否是 EventLoop 是的话赋值 eventLoop</span></span><br><span class="line">        <span class="comment">// 同时创建新上下文 CoroutineContext，这里会包含外部执行的</span></span><br><span class="line">        eventLoop = (contextInterceptor as? EventLoop)?.takeIf &#123; it.shouldBeProcessedFromContext() &#125;</span><br><span class="line">            ?: ThreadLocalEventLoop.currentOrNull()</span><br><span class="line">        newContext = GlobalScope.newCoroutineContext(context)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】创建 BlockingCoroutine 这个 job，并启动；</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">coroutine</span> <span class="operator">=</span> BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)</span><br><span class="line">    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】调用 joinBlocking 等待结果；</span></span><br><span class="line">    <span class="keyword">return</span> coroutine.joinBlocking()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到了一些关键点：</p><ul><li>ThreadLocalEventLoop.eventLoop 的原理：BlockingEventLoop；</li><li>joinBlocking 的原理；</li><li>BlockingCoroutine 的原理；</li></ul><h3 id="BlockingEventLoop"><a href="#BlockingEventLoop" class="headerlink" title="BlockingEventLoop"></a>BlockingEventLoop</h3><p>其实最终返回的是一个 BlockingEventLoop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">internal actual fun <span class="title function_">createEventLoop</span><span class="params">()</span>: EventLoop = BlockingEventLoop(Thread.currentThread())</span><br></pre></td></tr></table></figure><p>BlockingEventLoop 父类里面有一个队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">EventLoopImplBase</span>: EventLoopImplPlatform(), Delay &#123;</span><br><span class="line">    <span class="comment">// null | CLOSED_EMPTY | task | Queue&lt;Runnable&gt;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">_queue</span> <span class="operator">=</span> atomic&lt;Any?&gt;(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>回忆下微模型，DispatchedContinuations 对象会被添加到 Dispatcher 中去执行。</p><p>其实在 BlockingEventLoop 的场景下，就是被添加到 BlockingEventLoop 的 quue 队列中了。</p><p>同时注意 BlockingEventLoop 的线程：currentThread，也就是说，是同步执行。</p><h3 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h3><p>dispatch 的过程就是 enqueue 的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override fun <span class="title function_">dispatch</span><span class="params">(context: CoroutineContext, block: Runnable)</span> = enqueue(block)</span><br><span class="line"></span><br><span class="line">open fun <span class="title function_">enqueue</span><span class="params">(task: Runnable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (enqueueImpl(task)) &#123;</span><br><span class="line">        <span class="comment">// todo: we should unpark only when this delayed task became first in the queue</span></span><br><span class="line">        unpark()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DefaultExecutor.enqueue(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="joinBlocking"><a href="#joinBlocking" class="headerlink" title="joinBlocking"></a>joinBlocking</h3><p>我们看看 joinBlocking 函数，可以看到 joinBlocking 会进入到自旋状态，然后不断的从前面的 queue 中获取任务执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Suppress(&quot;UNCHECKED_CAST&quot;)</span></span><br><span class="line">fun <span class="title function_">joinBlocking</span><span class="params">()</span>: T &#123;</span><br><span class="line">    registerTimeLoopThread()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        eventLoop?.incrementUseCount()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="meta">@Suppress(&quot;DEPRECATION&quot;)</span></span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted()) <span class="keyword">throw</span> InterruptedException().also &#123; cancelCoroutine(it) &#125;</span><br><span class="line">              </span><br><span class="line">                <span class="comment">//【1】从队列中弹出 Task 对象;</span></span><br><span class="line">                <span class="comment">// 如果没有 eventLoop，那么就无限 park！！</span></span><br><span class="line">                <span class="type">val</span> <span class="variable">parkNanos</span> <span class="operator">=</span> eventLoop?.processNextEvent() ?: Long.MAX_VALUE <span class="comment">// 计算 park 时间</span></span><br><span class="line">                  </span><br><span class="line">                <span class="keyword">if</span> (isCompleted) <span class="keyword">break</span></span><br><span class="line">                <span class="title function_">parkNanos</span><span class="params">(<span class="built_in">this</span>, parkNanos)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// paranoia</span></span><br><span class="line">            eventLoop?.decrementUseCount()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// paranoia</span></span><br><span class="line">        unregisterTimeLoopThread()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// now return result</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">state</span> <span class="operator">=</span> <span class="built_in">this</span>.state.unboxState()</span><br><span class="line">    (state as? CompletedExceptionally)?.let &#123; <span class="keyword">throw</span> it.cause &#125;</span><br><span class="line">    <span class="keyword">return</span> state as T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override fun <span class="title function_">processNextEvent</span><span class="params">()</span>: Long &#123;</span><br><span class="line">    <span class="keyword">if</span> (processUnconfinedEvent()) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">delayed</span> <span class="operator">=</span> _delayed.value</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(delayed != <span class="literal">null</span> &amp;&amp; !delayed.isEmpty)</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">now</span> <span class="operator">=</span> nanoTime()</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            delayed.removeFirstIf &#123;</span><br><span class="line">                <span class="keyword">if</span> (it.timeToExecute(now)) &#123;</span><br><span class="line">                    enqueueImpl(it)</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="literal">false</span></span><br><span class="line">            &#125; ?: <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】核心：dequeue task 并执行;</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">task</span> <span class="operator">=</span> dequeue()</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        platformAutoreleasePool &#123; task.run() &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextTime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果不指定线程，默认就在当前线程，那么是同步执行的！！！</p><p>当前线程在执行完 task 后，会再次进入自旋状态，然后阻塞等待！！！</p><h3 id="指定-Dispathers"><a href="#指定-Dispathers" class="headerlink" title="指定 Dispathers"></a>指定 Dispathers</h3><p>如果指定了 Dispathers 的话呢？那么就没 loop 内部的队列了，那么当前线程会在 eventloop 的 processNextEvent 的地方一直阻塞。</p><h4 id="BlockingCoroutine"><a href="#BlockingCoroutine" class="headerlink" title="BlockingCoroutine"></a>BlockingCoroutine</h4><p>知道协程体执行完成后，通知 BlockingCoroutine，resumeWith 返回里面在 afterCompletion 后会，unpark blockedThread 线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override fun <span class="title function_">afterCompletion</span><span class="params">(state: Any?)</span> &#123;</span><br><span class="line">    <span class="comment">// wake up blocked thread</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != blockedThread)</span><br><span class="line">        unpark(blockedThread)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，调用 joinBlocking 的线程就会被唤醒了！</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>本篇文章，总结了下协程常见的启动函数的原理，嗯嗯。</p><p>不同的启动模式有各自的特俗，在特定场景使用才是关键。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0 前言&quot;&gt;&lt;/a&gt;0 前言&lt;/h2&gt;&lt;p&gt;基于微模型，分析下协程常见的启动方式的差异和对比。&lt;/p&gt;
&lt;p&gt;常见的启动方式有：launch、async、runbloc</summary>
      
    
    
    
    <category term="kotlin" scheme="https://lishuaiqi.top/categories/kotlin/"/>
    
    <category term="协程" scheme="https://lishuaiqi.top/categories/kotlin/%E5%8D%8F%E7%A8%8B/"/>
    
    
    <category term="协程" scheme="https://lishuaiqi.top/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="协程启动" scheme="https://lishuaiqi.top/tags/%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 协程原理分析 - 协程的线程切换</title>
    <link href="https://lishuaiqi.top/2025/05/12/kotlin/kotlin-cotoutine-coroutine_switch/"/>
    <id>https://lishuaiqi.top/2025/05/12/kotlin/kotlin-cotoutine-coroutine_switch/</id>
    <published>2025-05-12T12:46:25.000Z</published>
    <updated>2025-10-22T16:58:35.771Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结下协程线程切换的原理：</p><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>协程线程切换的原理很简单，如果能理解微模型，那么协程切换实际上就是不同微笑模型之前的切换；</p><h2 id="1-简单场景"><a href="#1-简单场景" class="headerlink" title="1 简单场景"></a>1 简单场景</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;GlobalScope 协程开始执行&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.IO) &#123;</span><br><span class="line">            println(<span class="string">&quot;线程切换执行完毕！&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑上面这样一个场景</p><p>GlobalScope 启动的协程在内部通过 withContext 执行了线程切换，那么是如何切换的呢？</p><h2 id="2-withContext-原理分析"><a href="#2-withContext-原理分析" class="headerlink" title="2 withContext 原理分析"></a>2 withContext 原理分析</h2><p>withContext 是一个挂起函数，不熟悉挂起函数原理的可以先去看看</p><p>通过微模型我们知道，协程启动三要素：</p><ul><li>关联任务 job，用于协程之间的协同。</li><li>分发器 Dispatchers：协程在特定线程池中运行。</li><li>协程体 SuspendLamda：协程体逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> suspend fun &lt;T&gt; withContext(</span><br><span class="line">    context: CoroutineContext,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; T</span><br><span class="line">): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn sc@ &#123; uCont -&gt;</span><br><span class="line">        <span class="comment">// compute new context</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">oldContext</span> <span class="operator">=</span> uCont.context</span><br><span class="line">        <span class="comment">// Copy CopyableThreadContextElement if necessary</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">newContext</span> <span class="operator">=</span> oldContext.newCoroutineContext(context)</span><br><span class="line">        <span class="comment">// always check for cancellation of new context</span></span><br><span class="line">        newContext.ensureActive()</span><br><span class="line">        <span class="comment">// FAST PATH #1 -- new context is the same as the old one</span></span><br><span class="line">        <span class="keyword">if</span> (newContext === oldContext) &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">coroutine</span> <span class="operator">=</span> ScopeCoroutine(newContext, uCont)</span><br><span class="line">            <span class="keyword">return</span><span class="meta">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】如果没有指定分发起，就在父协程的 dispatcher 中分发。                                              </span></span><br><span class="line">        <span class="keyword">if</span> (newContext[ContinuationInterceptor] == oldContext[ContinuationInterceptor]) &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">coroutine</span> <span class="operator">=</span> UndispatchedCoroutine(newContext, uCont)</span><br><span class="line">            <span class="comment">// There are changes in the context, so this thread needs to be updated</span></span><br><span class="line">            withCoroutineContext(newContext, <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span><span class="meta">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【2】切换线程</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">coroutine</span> <span class="operator">=</span> DispatchedCoroutine(newContext, uCont)</span><br><span class="line">        block.startCoroutineCancellable(coroutine, coroutine)</span><br><span class="line">        coroutine.getResult()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 launch 启动的协程：</p><ul><li>关联任务 job：StandardConroutine。</li><li>分发器 Dispatchers：Dispatchers.MAIN。</li><li>协程体 SuspendLamda：协程体</li></ul><p>那么对于 withContext：</p><ul><li>关联任务 job：如果指定了不一样的分发器；DispatchedCoroutine，如果和父亲协程一样，就是 UnDispatchedCoroutine。</li><li>分发器 Dispatchers：如果指定了就是 Dispatchers.IO，没指定就是父亲协程的 Dispatchers.IO</li><li>协程体 SuspendLambda：协程体</li></ul><p>这样看 withContext 也是执行了启动协程的微模型的操作！！</p><h2 id="3-从微模型看协程的线程切换"><a href="#3-从微模型看协程的线程切换" class="headerlink" title="3 从微模型看协程的线程切换"></a>3 从微模型看协程的线程切换</h2><p>在微模型里，协程体的执行主要是如下流程：</p><ul><li>协程体 SuspendLambda 被包裹成一个 DispatchedContinuation 对象；</li><li>DispatchedContinuation 被丢到 Dispatchers 线程池中运行；</li><li>DispatchedContinuation 执行 协程体 SuspendLambda 的 resumeWith 方法；</li><li>resumeWith 方法会触发协程体 SuspendLambda 的 invokeSuspend 方法，执行协程业务代码；</li><li>执行完成后，通过 completion.resumeWith 通知 Job 协程执行完成了！</li></ul><p>launch 和 withContext 其实都是做的这个操作。</p><p>那么他们的切换是基于什么操作呢？实际上，关键点就是在关联的 Job 上：DispatchedCoroutine。</p><p>下面进一步分析。</p><h2 id="4-通过-withContext-切换到-IO-线程"><a href="#4-通过-withContext-切换到-IO-线程" class="headerlink" title="4 通过 withContext 切换到 IO 线程"></a>4 通过 withContext 切换到 IO 线程</h2><p>这个很好理解 withContext 是一个 suspend 函数，同时指定了不同的分发器，那么 withContext 启动的 DispatchedCoroutine 的状态默认 UNDECIDE。</p><p>那么此时 coroutine.getResult() 返回一定是 SUSPEND。</p><p>从而导致外面的 launch 协程挂起等待了。</p><p>这个没什么好说的。</p><h2 id="5-withContext-切换回-launch-所在的-MAIN-线程"><a href="#5-withContext-切换回-launch-所在的-MAIN-线程" class="headerlink" title="5 withContext 切换回 launch 所在的 MAIN 线程"></a>5 withContext 切换回 launch 所在的 MAIN 线程</h2><p>关键点在于 DispatchedCoroutine。</p><p>协程体执行完成后，会通过 completion.resumeWith 通知 Job 协程执行完成了！</p><p>withContext 对应的 job 就是 DispatchedCoroutine，我们去看看 DispatchedCoroutine：</p><h3 id="DispatchedCoroutine"><a href="#DispatchedCoroutine" class="headerlink" title="DispatchedCoroutine"></a>DispatchedCoroutine</h3><p>构造器逻辑，里面持有外部写成的 Continuation 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="keyword">class</span> <span class="title class_">DispatchedCoroutine</span>&lt;in T&gt;(</span><br><span class="line">    context: CoroutineContext,</span><br><span class="line">    uCont: Continuation&lt;T&gt; <span class="comment">//【1】持有外部协程的 DispatchedContinuation 对象。</span></span><br><span class="line">) : ScopeCoroutine&lt;T&gt;(context, uCont) &#123;</span><br></pre></td></tr></table></figure><h3 id="resumeWith-–-gt-afterResume"><a href="#resumeWith-–-gt-afterResume" class="headerlink" title="resumeWith –&gt; afterResume"></a>resumeWith –&gt; afterResume</h3><p>我们来看下 afterResume 在 DispatchedCoroutine 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCoroutine</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override fun <span class="title function_">resumeWith</span><span class="params">(result: Result&lt;T&gt;)</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">state</span> <span class="operator">=</span> makeCompletingOnce(result.toState())</span><br><span class="line">    <span class="keyword">if</span> (state === COMPLETING_WAITING_CHILDREN) <span class="keyword">return</span></span><br><span class="line">    afterResume(state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> open fun <span class="title function_">afterResume</span><span class="params">(state: Any?)</span>: Unit = afterCompletion(state)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// DispatchedCoroutine</span></span><br><span class="line">override fun <span class="title function_">afterCompletion</span><span class="params">(state: Any?)</span> &#123;</span><br><span class="line">    <span class="comment">// Call afterResume from afterCompletion and not vice-versa, because stack-size is more</span></span><br><span class="line">    <span class="comment">// important for afterResume implementation</span></span><br><span class="line">    afterResume(state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override fun <span class="title function_">afterResume</span><span class="params">(state: Any?)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryResume()) <span class="keyword">return</span> <span class="comment">// completed before getResult invocation -- bail out</span></span><br><span class="line">    <span class="comment">// Resume in a cancellable way because we have to switch back to the original dispatcher</span></span><br><span class="line">    uCont.intercepted().resumeCancellableWith(recoverResult(state, uCont))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点就在 afterResume 里面。</p><p>他获取到 launch 协程的 Continuation 对象，调用 intercepted() 方法，获取到其对应的 DispatchedContinuation 对象，再次 resumeCancellableWith</p><p>这个很熟悉了，其实就是把  launch 协程又唤醒了，并且 DispatchedContinuation 内部支持在特定的线程池中执行协程逻辑。</p><p>其他的切换线程的方式大体也是这样。</p><h2 id="6-普通-suspend-函数如何切换线程"><a href="#6-普通-suspend-函数如何切换线程" class="headerlink" title="6 普通 suspend 函数如何切换线程"></a>6 普通 suspend 函数如何切换线程</h2><p>普通 suspend 函数这里特指我们自己业务中定义的 suspend 函数。</p><p>普通 suspend 函数切换线程的逻辑在业务 block 里面，对于 suspend 函数经过编译器和内部框架产生的代码，这部分所在的线程 Dispatchers 复用的外部协程的：</p><h3 id="suspendCancellableCoroutine"><a href="#suspendCancellableCoroutine" class="headerlink" title="suspendCancellableCoroutine"></a>suspendCancellableCoroutine</h3><p>这里可以看到 cancellable.getResult() 是在调用 suspend 函数的线程中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> suspend inline fun &lt;T&gt; suspendCancellableCoroutine(</span><br><span class="line">    crossinline block: (CancellableContinuation&lt;T&gt;) -&gt; Unit</span><br><span class="line">): T =</span><br><span class="line">    <span class="comment">//【1】执行校验，不重要；</span></span><br><span class="line">    <span class="comment">//【2】这里的 uCont 对象就是前面的 $completion</span></span><br><span class="line">    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;</span><br><span class="line">        <span class="comment">//【2】创建了 CancellableContinuationImpl 对象，包裹外部的 $completion 的 DispatchedContinuation 对象;</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">cancellable</span> <span class="operator">=</span> CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * For non-atomic cancellation we setup parent-child relationship immediately</span></span><br><span class="line"><span class="comment">         * in case when `block` blocks the current thread (e.g. Rx2 with trampoline scheduler), but</span></span><br><span class="line"><span class="comment">         * properly supports cancellation.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        cancellable.initCancellability()</span><br><span class="line">        <span class="comment">//【3】执行我们的逻辑，并传入 CancellableContinuationImpl;</span></span><br><span class="line">        block(cancellable)</span><br><span class="line">        <span class="comment">//【4】立刻返回结果，如果是自线程的话，返回的是 suspend 状态；</span></span><br><span class="line">        cancellable.getResult()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="resumeWith-–-gt-dispatchResume"><a href="#resumeWith-–-gt-dispatchResume" class="headerlink" title="resumeWith –&gt; dispatchResume"></a>resumeWith –&gt; dispatchResume</h3><p>dispatchResume 最终会调用到 dispatch 方法里面，可以看到 suspend 函数的情况下，利用的是调用 suspend 函数的协程所在的 Dispatchers。</p><p>这样确保业务环境没问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">internal fun &lt;T&gt; DispatchedTask&lt;T&gt;.dispatch(mode: Int) &#123;</span><br><span class="line">    <span class="keyword">assert</span> &#123; mode != MODE_UNINITIALIZED &#125; <span class="comment">// invalid mode value for this method</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate</span><br><span class="line">    <span class="type">val</span> <span class="variable">undispatched</span> <span class="operator">=</span> mode == MODE_UNDISPATCHED</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(!undispatched &amp;&amp; delegate is DispatchedContinuation&lt;*&gt; </span></span><br><span class="line"><span class="params">        &amp;&amp; mode.isCancellableMode == resumeMode.isCancellableMode)</span> &#123;</span><br><span class="line">        <span class="comment">//【1】这里是外部协程的 DispatchedContinuation</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">dispatcher</span> <span class="operator">=</span> delegate.dispatcher</span><br><span class="line">        <span class="type">val</span> <span class="variable">context</span> <span class="operator">=</span> delegate.context</span><br><span class="line">        <span class="comment">//【2】这里就是在外部协程的 Dispatchers 线程里面分发自己；</span></span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            dispatcher.dispatch(context, <span class="built_in">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resumeUnconfined()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// delegate is coming from 3rd-party interceptor implementation (and does not support cancellation)</span></span><br><span class="line">        <span class="comment">// or undispatched mode was requested</span></span><br><span class="line">        resume(delegate, undispatched)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><p>可以看到协程线程切换的原理，也是基于微模型：</p><ul><li>1、通过 job 关联实现协程的恢复操作；</li><li>2、通过 DispatchedTask 的统一分发和调用实现线程的切换；</li><li>3、普通的 suspend 函数依然复用调用者的线程池；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单总结下协程线程切换的原理：&lt;/p&gt;
&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0 前言&quot;&gt;&lt;/a&gt;0 前言&lt;/h2&gt;&lt;p&gt;协程线程切换的原理很简单，如果能理解微模型，那么协程切换实际上就是不同微笑模型</summary>
      
    
    
    
    <category term="kotlin" scheme="https://lishuaiqi.top/categories/kotlin/"/>
    
    <category term="协程" scheme="https://lishuaiqi.top/categories/kotlin/%E5%8D%8F%E7%A8%8B/"/>
    
    
    <category term="协程" scheme="https://lishuaiqi.top/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="协程切换" scheme="https://lishuaiqi.top/tags/%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 协程原理分析- CoroutineContext 和偏左链表</title>
    <link href="https://lishuaiqi.top/2025/05/12/kotlin/kotlin-cotoutine-coroutinecontext/"/>
    <id>https://lishuaiqi.top/2025/05/12/kotlin/kotlin-cotoutine-coroutinecontext/</id>
    <published>2025-05-12T12:46:25.000Z</published>
    <updated>2025-10-22T15:02:57.233Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结下 CoroutineContext 原理：</p><h2 id="CoroutineContext-原理总结"><a href="#CoroutineContext-原理总结" class="headerlink" title="CoroutineContext 原理总结"></a>CoroutineContext 原理总结</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>CoroutineContext 是协程的上下文环境，用于保存和传递数据。<strong>本质上是一个索引表</strong>，包含 Key 和 Element，每个 Element 都有唯一的 Key。</p><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineContext</span> &#123;</span><br><span class="line">    <span class="comment">// 键定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Key</span>&lt;<span class="type">E : Element</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 元素定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> : <span class="type">CoroutineContext</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Element 作为单元素上下文，get 返回自身或 null</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E? =</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.key == key) <span class="keyword">this</span> <span class="keyword">as</span> E <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment">// fold 对单元素执行操作</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R =</span><br><span class="line">            operation(initial, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// minusKey 移除自身或返回自身</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext =</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.key == key) EmptyCoroutineContext <span class="keyword">else</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心操作</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上下文合并机制"><a href="#上下文合并机制" class="headerlink" title="上下文合并机制"></a>上下文合并机制</h3><p><code>plus</code> 操作的实现逻辑：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext =</span><br><span class="line">    <span class="keyword">if</span> (context === EmptyCoroutineContext) <span class="keyword">this</span> <span class="keyword">else</span></span><br><span class="line">        context.fold(<span class="keyword">this</span>) &#123; acc, element -&gt;</span><br><span class="line">            <span class="keyword">val</span> removed = acc.minusKey(element.key) <span class="comment">// 移除同 key 元素</span></span><br><span class="line">            <span class="keyword">if</span> (removed === EmptyCoroutineContext) element <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 确保拦截器始终在末尾，便于快速获取</span></span><br><span class="line">                <span class="keyword">val</span> interceptor = removed[ContinuationInterceptor]</span><br><span class="line">                <span class="keyword">if</span> (interceptor == <span class="literal">null</span>) CombinedContext(removed, element) <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> left = removed.minusKey(ContinuationInterceptor)</span><br><span class="line">                    <span class="keyword">if</span> (left === EmptyCoroutineContext) CombinedContext(element, interceptor) <span class="keyword">else</span></span><br><span class="line">                        CombinedContext(CombinedContext(left, element), interceptor)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="CombinedContext：偏左链表结构"><a href="#CombinedContext：偏左链表结构" class="headerlink" title="CombinedContext：偏左链表结构"></a>CombinedContext：偏左链表结构</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">CombinedContext</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> left: CoroutineContext,  <span class="comment">// 列表前部分</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> element: Element         <span class="comment">// 尾节点</span></span><br><span class="line">) : CoroutineContext, Serializable</span><br></pre></td></tr></table></figure><p><strong>核心方法实现：</strong></p><ol><li><p><strong>get</strong> - 倒序访问</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E? &#123;</span><br><span class="line">    <span class="keyword">var</span> cur = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cur.element[key]?.let &#123; <span class="keyword">return</span> it &#125;  <span class="comment">// 先查尾节点</span></span><br><span class="line">        <span class="keyword">val</span> next = cur.left</span><br><span class="line">        <span class="keyword">if</span> (next <span class="keyword">is</span> CombinedContext) &#123;</span><br><span class="line">            cur = next  <span class="comment">// 递归左列表</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> next[key]  <span class="comment">// 基础 case</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>minusKey</strong> - 递归移除</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext &#123;</span><br><span class="line">    element[key]?.let &#123; <span class="keyword">return</span> left &#125;  <span class="comment">// 尾节点匹配，返回左列表</span></span><br><span class="line">    <span class="keyword">val</span> newLeft = left.minusKey(key)   <span class="comment">// 递归移除左列表中的 key</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        newLeft === left -&gt; <span class="keyword">this</span></span><br><span class="line">        newLeft === EmptyCoroutineContext -&gt; element</span><br><span class="line">        <span class="keyword">else</span> -&gt; CombinedContext(newLeft, element)  <span class="comment">// 重新组合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>fold</strong> - 递归展开</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R =</span><br><span class="line">    operation(left.fold(initial, operation), element)  <span class="comment">// 先递归左列表，再处理尾节点</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="协程上下文创建"><a href="#协程上下文创建" class="headerlink" title="协程上下文创建"></a>协程上下文创建</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">newCoroutineContext</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext &#123;</span><br><span class="line">    <span class="keyword">val</span> combined = coroutineContext + context  <span class="comment">// 合并父协程和当前上下文</span></span><br><span class="line">    <span class="comment">// 调试模式添加 CoroutineId</span></span><br><span class="line">    <span class="keyword">val</span> debug = <span class="keyword">if</span> (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) <span class="keyword">else</span> combined</span><br><span class="line">    <span class="comment">// 确保有默认调度器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == <span class="literal">null</span>)</span><br><span class="line">        debug + Dispatchers.Default <span class="keyword">else</span> debug</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ol><li><strong>Element 本身也是 CoroutineContext</strong>（单元素上下文）</li><li><strong>CombinedContext 是偏左链表</strong>，便于高效添加新元素</li><li><strong>拦截器始终保持在末尾</strong>，便于快速访问</li><li><strong>Key 冲突时新值覆盖旧值</strong></li><li><strong>所有操作都保证 CombinedContext 中无重复 Key</strong></li></ol><h2 id="偏左链表"><a href="#偏左链表" class="headerlink" title="偏左链表"></a>偏左链表</h2><h3 id="什么是偏左链表？"><a href="#什么是偏左链表？" class="headerlink" title="什么是偏左链表？"></a>什么是偏左链表？</h3><p>偏左链表是一种<strong>向左生长的链表结构</strong>，新元素总是被添加到链表的”左侧”（或者说头部），而不是传统的向右追加。</p><h3 id="传统链表-vs-偏左链表"><a href="#传统链表-vs-偏左链表" class="headerlink" title="传统链表 vs 偏左链表"></a>传统链表 vs 偏左链表</h3><p><strong>传统链表（向右生长）：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">头节点 → 节点A → 节点B → 节点C → null</span><br></pre></td></tr></table></figure><br>新元素D添加后：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">头节点 → 节点A → 节点B → 节点C → 节点D → null</span><br></pre></td></tr></table></figure></p><p><strong>偏左链表（向左生长）：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null ← 节点A ← 节点B ← 节点C ← 尾节点</span><br></pre></td></tr></table></figure><br>新元素D添加后：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null ← 节点A ← 节点B ← 节点C ← 节点D ← 尾节点</span><br></pre></td></tr></table></figure></p><h3 id="在-CombinedContext-中的具体体现"><a href="#在-CombinedContext-中的具体体现" class="headerlink" title="在 CombinedContext 中的具体体现"></a>在 CombinedContext 中的具体体现</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CombinedContext 结构：left + element</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">CombinedContext</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> left: CoroutineContext,  <span class="comment">// 已有的上下文（向左延伸）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> element: Element         <span class="comment">// 当前节点（最新的元素）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>构建过程示例：</strong></p><p>假设依次添加元素 A、B、C：</p><ol><li><p><strong>添加 A</strong>：<code>Empty + A = CombinedContext(Empty, A)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null ← A</span><br></pre></td></tr></table></figure></li><li><p><strong>添加 B</strong>：<code>ctxA + B = CombinedContext(ctxA, B)</code>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null ← A ← B</span><br></pre></td></tr></table></figure></li><li><p><strong>添加 C</strong>：<code>ctxAB + C = CombinedContext(ctxAB, C)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null ← A ← B ← C</span><br></pre></td></tr></table></figure></li></ol><h3 id="访问顺序：从右向左"><a href="#访问顺序：从右向左" class="headerlink" title="访问顺序：从右向左"></a>访问顺序：从右向左</h3><p>由于是向左生长，访问时从最新的元素开始向左遍历：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get 方法的遍历逻辑体现了这一点</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E? &#123;</span><br><span class="line">    <span class="keyword">var</span> cur = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cur.element[key]?.let &#123; <span class="keyword">return</span> it &#125;  <span class="comment">// 先查当前（最右）元素</span></span><br><span class="line">        <span class="keyword">val</span> next = cur.left                   <span class="comment">// 再向左查找</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找 key 的过程：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查找key → 从C开始 → 没找到 → 向左到B → 没找到 → 向左到A → 找到！</span><br></pre></td></tr></table></figure></p><h3 id="为什么设计成偏左链表？"><a href="#为什么设计成偏左链表？" class="headerlink" title="为什么设计成偏左链表？"></a>为什么设计成偏左链表？</h3><ol><li><strong>高效的添加操作</strong>：添加新元素只需创建新节点，O(1) 时间复杂度</li><li><strong>自然的覆盖语义</strong>：新添加的元素在查找时优先级更高，类似于头插法，符合”后来者覆盖”的直觉。</li><li><strong>容易实现 minusKey</strong>：可以从右向左快速找到并移除目标元素</li></ol><h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> context = EmptyCoroutineContext +</span><br><span class="line">    CoroutineName(<span class="string">&quot;test&quot;</span>) + </span><br><span class="line">    Dispatchers.IO +</span><br><span class="line">    CoroutineExceptionHandler &#123; _, _ -&gt; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际结构：</span></span><br><span class="line"><span class="comment">// null ← CoroutineName ← Dispatchers.IO ← CoroutineExceptionHandler</span></span><br></pre></td></tr></table></figure><p>这种设计让 CombinedContext 在保持功能完整的同时，具有很好的性能特性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单总结下 CoroutineContext 原理：&lt;/p&gt;
&lt;h2 id=&quot;CoroutineContext-原理总结&quot;&gt;&lt;a href=&quot;#CoroutineContext-原理总结&quot; class=&quot;headerlink&quot; title=&quot;CoroutineContext</summary>
      
    
    
    
    <category term="kotlin" scheme="https://lishuaiqi.top/categories/kotlin/"/>
    
    <category term="协程" scheme="https://lishuaiqi.top/categories/kotlin/%E5%8D%8F%E7%A8%8B/"/>
    
    
    <category term="协程" scheme="https://lishuaiqi.top/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="协程启动" scheme="https://lishuaiqi.top/tags/%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 协程原理分析 - 挂起函数的原理</title>
    <link href="https://lishuaiqi.top/2025/04/22/kotlin/kotlin-cotoutine-suspend_function/"/>
    <id>https://lishuaiqi.top/2025/04/22/kotlin/kotlin-cotoutine-suspend_function/</id>
    <published>2025-04-22T12:46:25.000Z</published>
    <updated>2025-10-22T15:10:24.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>suspend 函数，就是被 suspend 修饰的 function，本篇文章简单分析下 suspend 函数的工作原理和编译处理：</p><h2 id="1-suspend-函数的例子"><a href="#1-suspend-函数的例子" class="headerlink" title="1 suspend 函数的例子"></a>1 suspend 函数的例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suspend fun <span class="title function_">helloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">   println(<span class="string">&quot;hellow world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>suspend 关键字表示挂起，意味着该函数会被 kotlin 的编译器黑魔法处理。 </p><h2 id="2-suspend-关键字作用"><a href="#2-suspend-关键字作用" class="headerlink" title="2 suspend 关键字作用"></a>2 suspend 关键字作用</h2><h3 id="场景限制"><a href="#场景限制" class="headerlink" title="场景限制"></a>场景限制</h3><p>首先 suspend 会限制该函数的调用场景：只能在协程体或者另外一个 suspend 函数中执行，这是从编译器和语法角度的约束；</p><h3 id="编译处理"><a href="#编译处理" class="headerlink" title="编译处理"></a>编译处理</h3><p>suspend 函数会让 kotlin 编译器做针对性处理，内部会有一些黑魔法，用于实现挂起的功能，以及安全校验等功能；</p><h3 id="挂起能力"><a href="#挂起能力" class="headerlink" title="挂起能力"></a>挂起能力</h3><p>suspend 函数可以实现协程挂起，减少线程上下文的切换；</p><h2 id="3-suspend-函数原理分析"><a href="#3-suspend-函数原理分析" class="headerlink" title="3 suspend 函数原理分析"></a>3 suspend 函数原理分析</h2><h3 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h3><p>还是上面的那个例子，经过编译器处理后，可以看到，编译器增加了一个参数：$completion：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title function_">helloWorld</span><span class="params">(<span class="meta">@NotNull</span> Continuation $completion)</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="string">&quot;hellow world&quot;</span>;</span><br><span class="line">   System.out.println(var1);</span><br><span class="line">   <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 $completion 参数表示，调用 helloWorld 函数的外部 Continuation：</p><ul><li>可能是一个协程体；</li><li>也有可能是另一个 suspend 函数的 Continuation；</li></ul><p>但是这样写，有个问题，我们没法直接拿到这个 $completion，需要有一个机制能把他暴漏出来，这就是 suspendCancellableCoroutine 函数的作用。</p><h3 id="suspendCancelableCoroutine"><a href="#suspendCancelableCoroutine" class="headerlink" title="suspendCancelableCoroutine"></a>suspendCancelableCoroutine</h3><p>下面我们来看看 suspendCancellableCoroutine 的原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】进入到这里：suspendCancellableCoroutine</span></span><br><span class="line">suspend fun <span class="title function_">requestForData</span><span class="params">()</span> = suspendCancellableCoroutine&lt;String&gt; &#123; continuation -&gt;</span><br><span class="line">    getData(object: Callback) &#123;</span><br><span class="line">        override fun <span class="title function_">onSuccess</span><span class="params">(str: String)</span> &#123; </span><br><span class="line">          continuation.resumeWith(Result.success(<span class="string">&quot;kapibala,makabaka.&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        override fun <span class="title function_">onFailure</span><span class="params">(exception: Throwable)</span> &#123; </span><br><span class="line">          continuation.resumeWithException(exception) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="suspendCancellableCoroutine"><a href="#suspendCancellableCoroutine" class="headerlink" title="suspendCancellableCoroutine"></a>suspendCancellableCoroutine</h3><p>核心逻辑，进入 suspendCoroutineUninterceptedOrReturn</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> suspend <span class="keyword">inline</span> fun &lt;T&gt; <span class="built_in">suspendCancellableCoroutine</span>(</span><br><span class="line">    crossinline block: (CancellableContinuation&lt;T&gt;) -&gt; Unit</span><br><span class="line">): T =</span><br><span class="line">    <span class="comment">//【1】执行校验，不重要；</span></span><br><span class="line">    <span class="comment">//【2】这里的 uCont 对象就是前面的 $completion</span></span><br><span class="line">    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;</span><br><span class="line">        <span class="comment">//【2】创建了 CancellableContinuationImpl 对象，包裹外部的 $completion</span></span><br><span class="line">        val cancellable = <span class="built_in">CancellableContinuationImpl</span>(uCont.<span class="built_in">intercepted</span>(), resumeMode = MODE_CANCELLABLE)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * For non-atomic cancellation we setup parent-child relationship immediately</span></span><br><span class="line"><span class="comment">         * in case when `block` blocks the current thread (e.g. Rx2 with trampoline scheduler), but</span></span><br><span class="line"><span class="comment">         * properly supports cancellation.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        cancellable.<span class="built_in">initCancellability</span>()</span><br><span class="line">        <span class="comment">//【3】执行我们的逻辑，并传入 CancellableContinuationImpl;</span></span><br><span class="line">        <span class="built_in">block</span>(cancellable)</span><br><span class="line">        <span class="comment">//【4】立刻返回结果，如果是自线程的话，返回的是 suspend 状态；</span></span><br><span class="line">        cancellable.<span class="built_in">getResult</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>suspendCoroutineUninterceptedOrReturn 方法不用看，用于执行校验。</p><p>核心在于上面的这段逻辑。</p><ul><li><p>创建了 CancellableContinuationImpl 对象，wrapper 外面的 $completion；</p></li><li><p>这里包裹的是 $completion.intercepted()，如果你知道协程微模型的话，其实包裹关系如下：</p><ul><li>CancellableContinuationImpl –&gt; DispatcheredContinuation –&gt; 协程体 Continuation</li><li>DispatcheredContinuation 的目的就是为了切线程，当 suspend 函数回复后能回到特定线程中去；</li></ul></li><li>block(cancellable) 传入 CancellableContinuationImpl 对象，执行我们的逻辑；</li><li>cancellable.getResult() 返回当前的结果，如果切了线程，那会返回 suspend 状态<ul><li>否则通过 CancellableContinuationImpl 的 resumeWith 返回结构；</li></ul></li></ul><p>其实已经可以看出 suspendCancellableCoroutine 的原理了。</p><h3 id="CancellableContinuationImpl"><a href="#CancellableContinuationImpl" class="headerlink" title="CancellableContinuationImpl"></a>CancellableContinuationImpl</h3><p>可以看到 CancellableContinuationImpl 也是一个 DispatchedTask 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line">internal open <span class="keyword">class</span> <span class="title class_">CancellableContinuationImpl</span>&lt;in T&gt;(</span><br><span class="line">    <span class="keyword">final</span> override val delegate: Continuation&lt;T&gt;,</span><br><span class="line">    resumeMode: Int</span><br><span class="line">) : DispatchedTask&lt;T&gt;(resumeMode), CancellableContinuation&lt;T&gt;, CoroutineStackFrame &#123;</span><br></pre></td></tr></table></figure><h4 id="getResult"><a href="#getResult" class="headerlink" title="getResult()"></a>getResult()</h4><p>获取结果；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line">internal fun <span class="title function_">getResult</span><span class="params">()</span>: Any? &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">isReusable</span> <span class="operator">=</span> isReusable()</span><br><span class="line">    <span class="comment">// trySuspend may fail either if &#x27;block&#x27; has resumed/cancelled a continuation</span></span><br><span class="line">    <span class="comment">// or we got async cancellation from parent.</span></span><br><span class="line">    <span class="comment">//【1】看是否属于 suspend 状态 </span></span><br><span class="line">    <span class="keyword">if</span> (trySuspend()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentHandle == <span class="literal">null</span>) &#123;</span><br><span class="line">            installParentHandle()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isReusable) &#123;</span><br><span class="line">            releaseClaimedReusableContinuation()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【2】返回挂起状态;</span></span><br><span class="line">        <span class="keyword">return</span> COROUTINE_SUSPENDED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isReusable) &#123;</span><br><span class="line">        releaseClaimedReusableContinuation()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">val</span> <span class="variable">state</span> <span class="operator">=</span> <span class="built_in">this</span>.state</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(state is CompletedExceptionally)</span> <span class="keyword">throw</span> recoverStackTrace(state.cause, <span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (resumeMode.isCancellableMode) &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> context[Job]</span><br><span class="line">        <span class="keyword">if</span> (job != <span class="literal">null</span> &amp;&amp; !job.isActive) &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">cause</span> <span class="operator">=</span> job.getCancellationException()</span><br><span class="line">            cancelCompletedResult(state, cause)</span><br><span class="line">            <span class="keyword">throw</span> recoverStackTrace(cause, <span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】立刻返回结果;</span></span><br><span class="line">    <span class="keyword">return</span> getSuccessfulResult(state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有切线程，那么 resumeWith 会在当前线程执行，那么协程的状态就会被切为 RESUME，那么 trySuspend() 返回 false，那么 getSuccessfulResult 会立刻返回结果；</p><p>如果切了线程，那么 resumeWith 和 block(cancellable) 在不同的线程执行，默认协程是 DECIDE 状态，此时 trySuspend() 返回 true，那么就返回 SUSPEND 状态，协程挂起啦。</p><h4 id="resumeWith"><a href="#resumeWith" class="headerlink" title="resumeWith"></a>resumeWith</h4><p>如果我们异步获取到结果，通过 CancellableContinuationImpl 的 resumeWith 返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// result.toState 就是执行 onSuccess 或者 onFail 函数，假设 onSuccess，返回就是 CancellableContinuationImpl 自己;</span></span><br><span class="line">override fun <span class="title function_">resumeWith</span><span class="params">(result: Result&lt;T&gt;)</span> =</span><br><span class="line">    resumeImpl(result.toState(<span class="built_in">this</span>), resumeMode)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">resumeImpl</span><span class="params">(</span></span><br><span class="line"><span class="params">    proposedUpdate: Any?,</span></span><br><span class="line"><span class="params">    resumeMode: Int,</span></span><br><span class="line"><span class="params">    onCancellation: ((cause: Throwable)</span> -&gt; Unit)? = <span class="literal">null</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">//【2】处理自己的状态；</span></span><br><span class="line">    _state.loop &#123; state -&gt;</span><br><span class="line">        <span class="keyword">when</span> (state) &#123;</span><br><span class="line">            is NotCompleted -&gt; &#123;</span><br><span class="line">                <span class="comment">//【1】更新状态；</span></span><br><span class="line">                <span class="type">val</span> <span class="variable">update</span> <span class="operator">=</span> resumedState(state, proposedUpdate, resumeMode, onCancellation, idempotent = <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">if</span> (!_state.compareAndSet(state, update)) <span class="keyword">return</span><span class="meta">@loop</span> <span class="comment">// retry on cas failure</span></span><br><span class="line">                detachChildIfNonResuable()</span><br><span class="line">                <span class="comment">//【2】分发结果； </span></span><br><span class="line">                dispatchResume(resumeMode) <span class="comment">// dispatch resume, but it might get cancelled in process</span></span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// done</span></span><br><span class="line">            &#125;</span><br><span class="line">            is CancelledContinuation -&gt; &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * If continuation was cancelled, then resume attempt must be ignored,</span></span><br><span class="line"><span class="comment">                 * because cancellation is asynchronous and may race with resume.</span></span><br><span class="line"><span class="comment">                 * Racy exceptions will be lost, too.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (state.makeResumed()) &#123; <span class="comment">// check if trying to resume one (otherwise error)</span></span><br><span class="line">                    <span class="comment">// call onCancellation</span></span><br><span class="line">                    onCancellation?.let &#123; callOnCancellation(it, state.cause) &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="comment">// done</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        alreadyResumedError(proposedUpdate) <span class="comment">// otherwise, an error (second resume attempt)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dispatchResume"><a href="#dispatchResume" class="headerlink" title="dispatchResume"></a>dispatchResume</h4><p>dispatchResume 最终会调用到 dispatch 方法里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">internal fun &lt;T&gt; DispatchedTask&lt;T&gt;.dispatch(mode: Int) &#123;</span><br><span class="line">    <span class="keyword">assert</span> &#123; mode != MODE_UNINITIALIZED &#125; <span class="comment">// invalid mode value for this method</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate</span><br><span class="line">    <span class="type">val</span> <span class="variable">undispatched</span> <span class="operator">=</span> mode == MODE_UNDISPATCHED</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(!undispatched &amp;&amp; delegate is DispatchedContinuation&lt;*&gt; </span></span><br><span class="line"><span class="params">        &amp;&amp; mode.isCancellableMode == resumeMode.isCancellableMode)</span> &#123;</span><br><span class="line">        <span class="comment">// dispatch directly using this instance&#x27;s Runnable implementation</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">dispatcher</span> <span class="operator">=</span> delegate.dispatcher</span><br><span class="line">        <span class="type">val</span> <span class="variable">context</span> <span class="operator">=</span> delegate.context</span><br><span class="line">        <span class="comment">//【1】这里就是在外部协程的 Dispatchers 线程里面分发自己；</span></span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            dispatcher.dispatch(context, <span class="built_in">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resumeUnconfined()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// delegate is coming from 3rd-party interceptor implementation (and does not support cancellation)</span></span><br><span class="line">        <span class="comment">// or undispatched mode was requested</span></span><br><span class="line">        resume(delegate, undispatched)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h4><p>唤醒外部协程体的 DispatcherContinuation 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override fun <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> &#123; resumeMode != MODE_UNINITIALIZED &#125; <span class="comment">// should have been set before dispatching</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">taskContext</span> <span class="operator">=</span> <span class="built_in">this</span>.taskContext</span><br><span class="line">    <span class="keyword">var</span> fatalException: Throwable? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">delegate</span> <span class="operator">=</span> delegate as DispatchedContinuation&lt;T&gt;</span><br><span class="line">        <span class="type">val</span> <span class="variable">continuation</span> <span class="operator">=</span> delegate.continuation</span><br><span class="line">        <span class="title function_">withContinuationContext</span><span class="params">(continuation, delegate.countOrElement)</span> &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">context</span> <span class="operator">=</span> continuation.context</span><br><span class="line">            <span class="type">val</span> <span class="variable">state</span> <span class="operator">=</span> takeState() <span class="comment">// <span class="doctag">NOTE:</span> Must take state in any case, even if cancelled</span></span><br><span class="line">            <span class="type">val</span> <span class="variable">exception</span> <span class="operator">=</span> getExceptionalResult(state)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Check whether continuation was originally resumed with an exception.</span></span><br><span class="line"><span class="comment">             * If so, it dominates cancellation, otherwise the original exception</span></span><br><span class="line"><span class="comment">             * will be silently lost.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 这里就是唤醒的地方；  </span></span><br><span class="line">            <span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> <span class="keyword">if</span> (exception == <span class="literal">null</span> &amp;&amp; resumeMode.isCancellableMode) context[Job] <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">            <span class="title function_">if</span> <span class="params">(job != <span class="literal">null</span> &amp;&amp; !job.isActive)</span> &#123;</span><br><span class="line">                <span class="type">val</span> <span class="variable">cause</span> <span class="operator">=</span> job.getCancellationException()</span><br><span class="line">                cancelCompletedResult(state, cause)</span><br><span class="line">                continuation.resumeWithStackTrace(cause)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                    continuation.resumeWithException(exception)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    continuation.resume(getSuccessfulResult(state))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        <span class="comment">// This instead of runCatching to have nicer stacktrace and debug experience</span></span><br><span class="line">        fatalException = e</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">result</span> <span class="operator">=</span> runCatching &#123; taskContext.afterTask() &#125;</span><br><span class="line">        handleFatalException(fatalException, result.exceptionOrNull())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>挂起函数的原理主要有 2 个：编译时和运行时。</p><ul><li>编译时通过黑魔法，修改函数的参数，同时传递外层的 continuation。</li><li>运行时通过 Continuation 的嵌套包裹，实现唤醒和挂起。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0 前言&quot;&gt;&lt;/a&gt;0 前言&lt;/h2&gt;&lt;p&gt;suspend 函数，就是被 suspend 修饰的 function，本篇文章简单分析下 suspend 函数的工作原理和</summary>
      
    
    
    
    <category term="kotlin" scheme="https://lishuaiqi.top/categories/kotlin/"/>
    
    <category term="协程" scheme="https://lishuaiqi.top/categories/kotlin/%E5%8D%8F%E7%A8%8B/"/>
    
    
    <category term="协程" scheme="https://lishuaiqi.top/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="协程启动" scheme="https://lishuaiqi.top/tags/%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>kotlin 协程原理分析 - 启动微模型</title>
    <link href="https://lishuaiqi.top/2025/04/12/kotlin/kotlin-cotoutine-instart2/"/>
    <id>https://lishuaiqi.top/2025/04/12/kotlin/kotlin-cotoutine-instart2/</id>
    <published>2025-04-12T12:46:25.000Z</published>
    <updated>2025-10-22T05:51:18.579Z</updated>
    
    <content type="html"><![CDATA[<p>(同步下学习记录)</p><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>简单分析下，kotlin 协程的启动微模型，协程由于其结构化的原理，父子协程之间有依赖关系，而协程的执行也是有依赖关系，基于微模型。</p><p>只要搞清楚了这个微模型，那么协程的嵌套也就了如指掌了。</p><p>下面以 launch 为例子，我们分析下微模型。</p><h2 id="1-启动一个简单协程"><a href="#1-启动一个简单协程" class="headerlink" title="1 启动一个简单协程"></a>1 启动一个简单协程</h2><p>下面分析下 launch 的启动流程，核心的代码是到这个地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> fun CoroutineScope.launch(</span><br><span class="line">    context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; Unit</span><br><span class="line">): Job &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">newContext</span> <span class="operator">=</span> newCoroutineContext(context)</span><br><span class="line">    <span class="comment">//【1】默认的 job 情况;  </span></span><br><span class="line">    <span class="type">val</span> <span class="variable">coroutine</span> <span class="operator">=</span> <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">//【2】进入 job 启动环节;</span></span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#CoroutineStart.kt</span><br><span class="line"><span class="keyword">public</span> operator fun &lt;R, T&gt; invoke(block: suspend R.() -&gt; T, receiver: R, completion: Continuation&lt;T&gt;): Unit =</span><br><span class="line">    <span class="keyword">when</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】默认模式启动;</span></span><br><span class="line">        DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion)</span><br><span class="line">        ATOMIC -&gt; block.startCoroutine(receiver, completion)</span><br><span class="line">        UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)</span><br><span class="line">        LAZY -&gt; Unit <span class="comment">// will start lazily</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>无论走哪个分支，都是调用 block 的函数，而 ==block 就是一个 suspend 修饰的函数==。</p><h3 id="startCoroutineCancellable"><a href="#startCoroutineCancellable" class="headerlink" title="startCoroutineCancellable"></a>startCoroutineCancellable</h3><p>以 DEFAULT 为例 startCoroutineCancellable 接下来会调用到 IntrinsicsJvm.kt 里的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InternalCoroutinesApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): <span class="built_in">Unit</span> = runSafely(completion) &#123;</span><br><span class="line">    createCoroutineUnintercepted(completion)</span><br><span class="line">  .intercepted()</span><br><span class="line">  .resumeCancellableWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就看到了协程体的创建三部曲啦。</p><ul><li><p>1、createCoroutineUnintercepted 创建协程体，关联 job；</p></li><li><p>2、intercepted 执行拦截器逻辑；</p></li><li><p>3、resumeCancellableWith 启动协程</p></li></ul><p>下面可以分别看看他们的流程。</p><h2 id="2-createCoroutineUnintercepted"><a href="#2-createCoroutineUnintercepted" class="headerlink" title="2. createCoroutineUnintercepted"></a>2. createCoroutineUnintercepted</h2><p>该函数带了俩参数，其中的 receiver 为接收者，而 completion 为协程结束后调用的回调：</p><p>为什么看不到源码呢？</p><ol><li><strong>编译器内置函数</strong>：<code>createCoroutineUnintercepted</code> 是一个编译器内置函数（intrinsic），它的实际实现是在 Kotlin 编译器层面完成的，而不是在标准库中提供具体的 Kotlin 代码。</li><li><strong>平台相关实现</strong>：不同的平台（JVM、Native、JS）有不同的实现方式。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 实际实现由编译器提供</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这里我们关注 JVM 平台的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> actual fun &lt;R, T&gt; (suspend R.() -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    receiver: R,</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;Unit&gt; &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">probeCompletion</span> <span class="operator">=</span> probeCoroutineCreated(completion)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="built_in">this</span> is BaseContinuationImpl)</span><br><span class="line">        <span class="comment">//【1】核心逻辑：BaseContinuationImpl</span></span><br><span class="line">        create(receiver, probeCompletion)</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">            (<span class="built_in">this</span> as Function2&lt;R, Continuation&lt;T&gt;, Any?&gt;).invoke(receiver, it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseContinuationImpl 是什么？</p><p>这里的 this 是我们的协程体对象，那么协程体对象是什么样子呢？一定是 实现了 BaseContinuationImpl 的一个对象。</p><h3 id="编译器黑魔法"><a href="#编译器黑魔法" class="headerlink" title="编译器黑魔法"></a>编译器黑魔法</h3><p>在这个例子中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;GlobalScope 协程执行完毕！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的协程体经过编译器处理后会生成一个匿名内部类，并创建其对应的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">BuildersKt.launch$<span class="keyword">default</span>((CoroutineScope)GlobalScope.INSTANCE, (CoroutineContext)<span class="literal">null</span>, (CoroutineStart)<span class="literal">null</span>, </span><br><span class="line">                          <span class="comment">//【1】就是这个地方</span></span><br><span class="line">                          (Function2)(<span class="keyword">new</span> <span class="title class_">Function2</span>((Continuation)<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> label;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object $result)</span> &#123; <span class="comment">//【2】invokeSuspend</span></span><br><span class="line">           <span class="type">Object</span> <span class="variable">var3</span> <span class="operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">           <span class="keyword">switch</span> (<span class="built_in">this</span>.label) &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                 ResultKt.throwOnFailure($result);</span><br><span class="line">                 <span class="built_in">this</span>.label = <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">if</span> (DelayKt.delay(<span class="number">1000L</span>, <span class="built_in">this</span>) == var3) &#123;</span><br><span class="line">                    <span class="keyword">return</span> var3;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                 ResultKt.throwOnFailure($result);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;GlobalScope 协程执行完毕！&quot;</span>;</span><br><span class="line">           System.out.println(var2);</span><br><span class="line">           <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Continuation <span class="title function_">create</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@NotNull</span> Continuation completion)</span> &#123;</span><br><span class="line">           Intrinsics.checkNotNullParameter(completion, <span class="string">&quot;completion&quot;</span>); <span class="comment">//【2】create anonymous</span></span><br><span class="line">           <span class="type">Function2</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="keyword">new</span> &lt;anonymous constructor&gt;(completion);</span><br><span class="line">           <span class="keyword">return</span> var3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Object var2)</span> &#123; <span class="comment">//【3】invoke 函数特性 --&gt; 【4】</span></span><br><span class="line">           <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="built_in">this</span>.create(var1, (Continuation)var2)).invokeSuspend(Unit.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;), <span class="number">3</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>这个匿名内部类实现了  Function2 接口，实现了 invoke 方法。</p><h3 id="SuspendLambda-父类"><a href="#SuspendLambda-父类" class="headerlink" title="SuspendLambda 父类"></a>SuspendLambda 父类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ContinuationImpl.kt</span><br><span class="line">internal <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SuspendLambda</span>(</span><br><span class="line">    <span class="keyword">public</span> override val arity: Int,</span><br><span class="line">    completion: Continuation&lt;Any?&gt;? <span class="comment">//【1】关联 job</span></span><br><span class="line">) : ContinuationImpl(completion), FunctionBase&lt;Any?&gt;, SuspendFunction &#123;</span><br><span class="line">    constructor(arity: Int) : <span class="built_in">this</span>(arity, <span class="literal">null</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的匿名内部类实现了这个 SuspendLambda 类。</p><ul><li>resumeWith 是  Continuation 的接口；</li><li>ContinuationImpl 实现了 BaseContinuationImpl，BaseContinuationImpl 实现了 Continuation；</li><li>invokeSuspend 和 create 是 BaseContinuationImpl  的接口；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#Continuation.kt</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;in T&gt; &#123;</span><br><span class="line">    <span class="comment">//【1】协程上下文</span></span><br><span class="line">    <span class="keyword">public</span> val context: CoroutineContext</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//【2】恢复协程</span></span><br><span class="line">    <span class="keyword">public</span> fun <span class="title function_">resumeWith</span><span class="params">(result: Result&lt;T&gt;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实看逻辑已经能知道他的作用。</p><ul><li>resumeWith 唤醒协程。</li><li>invokeSuspend 执行协程体。</li><li>create 创建协程体。</li></ul><p>所以可以看到，createCoroutineUnintercepted 实际上就是调用了 匿名内部类对象的 create 方法，创建了协程体对象。</p><p>其实这个地方创建了 2 个，因为：new Function2 是中间对象，然后借助 create 创建我们真正的协程体对象。</p><h2 id="3-intercepted"><a href="#3-intercepted" class="headerlink" title="3 intercepted"></a>3 intercepted</h2><p>启动拦截，处理 dispatchers 逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SinceKotlin(&quot;1.3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> actual fun &lt;T&gt; Continuation&lt;T&gt;.intercepted(): Continuation&lt;T&gt; =</span><br><span class="line">    (<span class="built_in">this</span> as? ContinuationImpl)?.intercepted() ?: <span class="built_in">this</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> fun <span class="title function_">intercepted</span><span class="params">()</span>: Continuation&lt;Any?&gt; =</span><br><span class="line">    intercepted</span><br><span class="line">        ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="built_in">this</span>) ?: <span class="built_in">this</span>)</span><br><span class="line">            .also &#123; intercepted = it &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这一步是从 context 中取 ContinuationInterceptor，其实就是我们的  Dispatchers。</p><h3 id="Dispatchers-IO"><a href="#Dispatchers-IO" class="headerlink" title="Dispatchers.IO"></a>Dispatchers.IO</h3><p>interceptContinuation 的作用是创建一个 DispatcheredContinuation 对象，把 Dispatchers 和协程体包裹在里面；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; =</span><br><span class="line">    DispatchedContinuation(<span class="built_in">this</span>, continuation) <span class="comment">//【1】</span></span><br></pre></td></tr></table></figure><h4 id="DispatchedContinuation"><a href="#DispatchedContinuation" class="headerlink" title="DispatchedContinuation"></a>DispatchedContinuation</h4><p>DispatchedContinuation 本质上是一个  DispatchedTask，实现了 Runnable 接口，也就意味着，可以被丢到线程池中运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">internal <span class="keyword">class</span> <span class="title class_">DispatchedContinuation</span>&lt;in T&gt;(</span><br><span class="line">    <span class="meta">@JvmField</span> val dispatcher: CoroutineDispatcher, <span class="comment">// Dispatchers.IO</span></span><br><span class="line">    <span class="meta">@JvmField</span> val continuation: Continuation&lt;T&gt; <span class="comment">// 我们的协程体;</span></span><br><span class="line">) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation &#123;</span><br></pre></td></tr></table></figure><p>同时，他也实现了 Continuation 接口，所以他也有 resumeWith 方法；</p><h2 id="4-resumeCancellableWith"><a href="#4-resumeCancellableWith" class="headerlink" title="4 resumeCancellableWith"></a>4 resumeCancellableWith</h2><p>启动协程体，到这里就要启动协程体了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InternalCoroutinesApi</span></span><br><span class="line"><span class="keyword">public</span> fun &lt;T&gt; Continuation&lt;T&gt;.resumeCancellableWith(</span><br><span class="line">    result: Result&lt;T&gt;,</span><br><span class="line">    onCancellation: ((cause: Throwable) -&gt; Unit)? = <span class="literal">null</span></span><br><span class="line">): Unit = <span class="keyword">when</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//【1】此时进入这里</span></span><br><span class="line">    is DispatchedContinuation -&gt; resumeCancellableWith(result, onCancellation)</span><br><span class="line">    <span class="keyword">else</span> -&gt; resumeWith(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行了 DispatchedContinuation 的 resumeCancellableWith 方法！</p><h3 id="DispatchedContinuation-1"><a href="#DispatchedContinuation-1" class="headerlink" title="DispatchedContinuation"></a>DispatchedContinuation</h3><h4 id="resumeCancellableWith"><a href="#resumeCancellableWith" class="headerlink" title="resumeCancellableWith"></a>resumeCancellableWith</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We inline it to save an entry on the stack in cases where it shows (unconfined dispatcher)</span></span><br><span class="line"><span class="comment">// It is used only in Continuation&lt;T&gt;.resumeCancellableWith</span></span><br><span class="line"><span class="meta">@Suppress(&quot;NOTHING_TO_INLINE&quot;)</span></span><br><span class="line">inline fun <span class="title function_">resumeCancellableWith</span><span class="params">(</span></span><br><span class="line"><span class="params">    result: Result&lt;T&gt;,</span></span><br><span class="line"><span class="params">    noinline onCancellation: ((cause: Throwable)</span> -&gt; Unit)?</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">state</span> <span class="operator">=</span> result.toState(onCancellation)</span><br><span class="line">    <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">        _state = <span class="type">state</span></span><br><span class="line">        <span class="variable">resumeMode</span> <span class="operator">=</span> MODE_CANCELLABLE</span><br><span class="line">        <span class="comment">//【1】核心：把自己丢到 dispatchers.io 的线程池中执行；  </span></span><br><span class="line">        dispatcher.dispatch(context, <span class="built_in">this</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executeUnconfined(state, MODE_CANCELLABLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!resumeCancelled(state)) &#123;</span><br><span class="line">                resumeUndispatchedWith(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心：把自己丢到 dispatchers.io 的线程池中执行；  </p><p>DispatchedContinuation 被丢进线程池啦；</p><h3 id="DispatchedTask"><a href="#DispatchedTask" class="headerlink" title="DispatchedTask"></a>DispatchedTask</h3><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>此时 DispatchedContinuation 作为任务在线程池中执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override fun <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> &#123; resumeMode != MODE_UNINITIALIZED &#125; <span class="comment">// should have been set before dispatching</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">taskContext</span> <span class="operator">=</span> <span class="built_in">this</span>.taskContext</span><br><span class="line">    <span class="keyword">var</span> fatalException: Throwable? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">delegate</span> <span class="operator">=</span> delegate as DispatchedContinuation&lt;T&gt;</span><br><span class="line">        <span class="type">val</span> <span class="variable">continuation</span> <span class="operator">=</span> delegate.continuation</span><br><span class="line">        <span class="title function_">withContinuationContext</span><span class="params">(continuation, delegate.countOrElement)</span> &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">context</span> <span class="operator">=</span> continuation.context</span><br><span class="line">            <span class="type">val</span> <span class="variable">state</span> <span class="operator">=</span> takeState() <span class="comment">// <span class="doctag">NOTE:</span> Must take state in any case, even if cancelled</span></span><br><span class="line">            <span class="type">val</span> <span class="variable">exception</span> <span class="operator">=</span> getExceptionalResult(state)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Check whether continuation was originally resumed with an exception.</span></span><br><span class="line"><span class="comment">             * If so, it dominates cancellation, otherwise the original exception</span></span><br><span class="line"><span class="comment">             * will be silently lost.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">val</span> <span class="variable">job</span> <span class="operator">=</span> <span class="keyword">if</span> (exception == <span class="literal">null</span> &amp;&amp; resumeMode.isCancellableMode) context[Job] <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">            <span class="title function_">if</span> <span class="params">(job != <span class="literal">null</span> &amp;&amp; !job.isActive)</span> &#123;</span><br><span class="line">                <span class="type">val</span> <span class="variable">cause</span> <span class="operator">=</span> job.getCancellationException()</span><br><span class="line">                cancelCompletedResult(state, cause)</span><br><span class="line">                <span class="comment">//【1】核心逻辑：执行协程体，在特定的线程池中;  </span></span><br><span class="line">                continuation.resumeWithStackTrace(cause)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                    continuation.resumeWithException(exception)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    continuation.resume(getSuccessfulResult(state))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        <span class="comment">// This instead of runCatching to have nicer stacktrace and debug experience</span></span><br><span class="line">        fatalException = e</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">result</span> <span class="operator">=</span> runCatching &#123; taskContext.afterTask() &#125;</span><br><span class="line">        handleFatalException(fatalException, result.exceptionOrNull())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里已经开始触发，真正协程体的执行了！</p><h2 id="5-真正协程体的执行"><a href="#5-真正协程体的执行" class="headerlink" title="5 真正协程体的执行"></a>5 真正协程体的执行</h2><p>此时，真正协程体的就要执行了。</p><h3 id="BaseContinuationImpl"><a href="#BaseContinuationImpl" class="headerlink" title="BaseContinuationImpl"></a>BaseContinuationImpl</h3><h4 id="resumeWith"><a href="#resumeWith" class="headerlink" title="resumeWith"></a>resumeWith</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseContinuationImpl</span> <span class="keyword">implements</span> <span class="title class_">Continuation</span>&lt;Object&gt;, CoroutineStackFrame, Serializable &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Continuation&lt;Object&gt; completion;</span><br><span class="line">  </span><br><span class="line">  ... ... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//【1】用于挂起函数来唤醒协程体;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resumeWith</span><span class="params">(Object paramObject)</span> &#123;</span><br><span class="line">    <span class="type">BaseContinuationImpl</span> <span class="variable">baseContinuationImpl</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      DebugProbesKt.probeCoroutineResumed(baseContinuationImpl);</span><br><span class="line">      <span class="type">BaseContinuationImpl</span> <span class="variable">baseContinuationImpl1</span> <span class="operator">=</span> baseContinuationImpl;</span><br><span class="line">      Continuation&lt;Object&gt; continuation = baseContinuationImpl1.completion;</span><br><span class="line">      </span><br><span class="line">      Intrinsics.checkNotNull(continuation);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】执行协程体的状态机逻辑;</span></span><br><span class="line">        paramObject = baseContinuationImpl1.invokeSuspend(paramObject);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】如果返回的是挂起状态，那就跳出循环，直接返回；</span></span><br><span class="line">        <span class="keyword">if</span> (paramObject == IntrinsicsKt.getCOROUTINE_SUSPENDED())</span><br><span class="line">          <span class="keyword">return</span>; </span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        paramObject = <span class="literal">null</span>;</span><br><span class="line">        Result.<span class="type">Companion</span> <span class="variable">companion</span> <span class="operator">=</span> Result.Companion;</span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      baseContinuationImpl1.releaseIntercepted();</span><br><span class="line">      <span class="keyword">if</span> (continuation <span class="keyword">instanceof</span> BaseContinuationImpl)</span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">      </span><br><span class="line">      <span class="comment">//【2】执行成功，通知结果给 job;</span></span><br><span class="line">      continuation.resumeWith(paramObject);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>到这里，协程就执行完成啦。</p><h2 id="6-微模型总结"><a href="#6-微模型总结" class="headerlink" title="6 微模型总结"></a>6 微模型总结</h2><p>总结下协程启动的微模型，协程的嵌套就是微模型嵌套。</p><ul><li>一个协程体，关联一个 job coroutine，协程之间的父子关系则是以 job coroutine 进行关联；</li><li>协程体执行完成后会通过 job.resumeWith 通知执行结果；</li><li>协程体会被 DispatchedContinuation 的 wrapper 对象包裹到内部，丢到 Dispatchers 线程池中执行；</li><li>DispatchedContinuation 是一个 Runnable，run 方法里会真正执行我们的协程体对象；</li></ul><p>结束～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;(同步下学习记录)&lt;/p&gt;
&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0 前言&quot;&gt;&lt;/a&gt;0 前言&lt;/h2&gt;&lt;p&gt;简单分析下，kotlin 协程的启动微模型，协程由于其结构化的原理，父子协程之间有依赖关系</summary>
      
    
    
    
    <category term="kotlin" scheme="https://lishuaiqi.top/categories/kotlin/"/>
    
    <category term="协程" scheme="https://lishuaiqi.top/categories/kotlin/%E5%8D%8F%E7%A8%8B/"/>
    
    
    <category term="协程" scheme="https://lishuaiqi.top/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="协程启动" scheme="https://lishuaiqi.top/tags/%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Shadow 原理分析</title>
    <link href="https://lishuaiqi.top/2022/10/13/shadow-howtowork-all/"/>
    <id>https://lishuaiqi.top/2022/10/13/shadow-howtowork-all/</id>
    <published>2022-10-13T12:46:25.000Z</published>
    <updated>2022-10-24T15:57:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周在团队内部做了一次技术分享，关于 shadow 核心技术原理，下面是这次分享的内容：</p><p>我这里也提供了 pdf 的百度云地址，微信扫一扫就好～～</p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/05/1112.png" alt=""> </p><h1 id="原理总览"><a href="#原理总览" class="headerlink" title="原理总览"></a>原理总览</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/19e559177000a7db6424f781bd7da2ef.png" width="70%"></p><h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/e81a4a6afaec51f2a6371398e3a9590e123.png" width="70%"></p><h1 id="接口动态化原理"><a href="#接口动态化原理" class="headerlink" title="接口动态化原理"></a>接口动态化原理</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/1eaff16b6499abc0d1278411062335d1.png" width="70%"></p><h1 id="插件包的组成"><a href="#插件包的组成" class="headerlink" title="插件包的组成"></a>插件包的组成</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/image-20221024042017313.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/6d60ff0bd75bfa6398cbb24c1ef02ab5.png" width="70%"></p><h1 id="宿主如何启动插件-Activity"><a href="#宿主如何启动插件-Activity" class="headerlink" title="宿主如何启动插件 Activity"></a>宿主如何启动插件 Activity</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/1ad330e14208feae1bdddae0acf01f18.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/8e20f889f6bcbcf0da8f7feedabe7728.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/fb607615626d95b232ddaef8a17fcacf.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/4ddb06df7f1b71d1a0c5e89ba5e69619.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/dff534d7bf719e3d16433363b60c7703.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/c2958941fb6154cccc247e59c8f34056.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/87a07583f881eb55a7f90a475e898a1e.png" width="70%"></p><h1 id="PPS-的作用"><a href="#PPS-的作用" class="headerlink" title="PPS 的作用"></a>PPS 的作用</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/37d98fc1f32655ce51909c1993c21f19.png" width="70%"></p><h1 id="插件独立进程的好处"><a href="#插件独立进程的好处" class="headerlink" title="插件独立进程的好处"></a>插件独立进程的好处</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/0dda4f65105ab27bb292ecf3918f970c.png" width="70%"></p><h1 id="同名-View-问题和解决方案"><a href="#同名-View-问题和解决方案" class="headerlink" title="同名 View 问题和解决方案"></a>同名 <strong>View</strong> 问题和解决方案</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/914a74508b0fd7a2551ef79bf89c34f9.png" width="70%"></p><h2 id="传统解决方案"><a href="#传统解决方案" class="headerlink" title="传统解决方案"></a>传统解决方案</h2><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/5faca70d15065311d4d001e2c7cda4ce.png" width="70%"></p><h2 id="Factory-注入"><a href="#Factory-注入" class="headerlink" title="Factory 注入"></a>Factory 注入</h2><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/8f738b7ac1d781bb3d46af1bf02febee.png" width="70%"></p><p>com.tencent.shadow.core.runtime.ShadowLayoutInflater/InnerInflater </p><p>com.tencent.shadow.core.runtime.ShadowFactory2</p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/ad9dc342c2f3081de329690b67236e3a.jpeg" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/3dca7657fdb73098a4096c5f9df157a3-1234.jpeg" width="70%"><br>ShadowFactory2  ShadowLayoutInflater</p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/2619db515edbd3b4c16c1020aa4cfb4d.jpeg" width="70%"></p><p>LayoutInflater</p><h2 id="LayoutInflater-的-Merge"><a href="#LayoutInflater-的-Merge" class="headerlink" title="LayoutInflater 的 Merge"></a>LayoutInflater 的 Merge</h2><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/70166414fd349723eda83b4cfb37e4ed.png" width="70%"></p><h1 id="插件-PluginClassLoader-浅析"><a href="#插件-PluginClassLoader-浅析" class="headerlink" title="插件 PluginClassLoader 浅析"></a>插件 PluginClassLoader 浅析</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/095604ba7367ff4aca77402da896a0d4.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/05/image-20221024055237183.png" width="70%"></p><h1 id="插件包名和宿主包名"><a href="#插件包名和宿主包名" class="headerlink" title="插件包名和宿主包名"></a>插件包名和宿主包名</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/87feec32ede63fdc3fa4b48550a51957.jpeg" width="70%"></p><h1 id="插件包的资源"><a href="#插件包的资源" class="headerlink" title="插件包的资源"></a>插件包的资源</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/593ead7257a5ec97b4663d1f63e0a76e.jpeg" width="70%"></p><h1 id="ShadowContext-代理"><a href="#ShadowContext-代理" class="headerlink" title="ShadowContext 代理"></a>ShadowContext 代理</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/309885dc6166b26379bcdaef422d8c76-1234.jpeg" width="70%"></p><p>ShadowActivity、ShadowApplication 的父类都是 ShadowContext</p><h1 id="宿主如何启动插件-Service"><a href="#宿主如何启动插件-Service" class="headerlink" title="宿主如何启动插件 Service"></a>宿主如何启动插件 Service</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/61121db483849a08f069316ea70cd3fc.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/e67cb88c01ec821585d695539f76fc16.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/03/be12ef34cd7eaba1b9e9b31442585da8.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/9c0730de7472524cc8a82ff4f1de5eb7-1234.jpeg" width="70%"></p><h1 id="宿主如何启动和访问插件-provider"><a href="#宿主如何启动和访问插件-provider" class="headerlink" title="宿主如何启动和访问插件 provider"></a>宿主如何启动和访问插件 provider</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/94cf71f07a736b41e1562cbd6ee662fa.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/4332787979cd2014ef823657c81b81e9.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/6dcb6e2bca42ba4c3ef96282fea68f7b.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/e5b571aec8e013c103836e64377a15e5.png" width="70%"></p><h1 id="宿主如何启动和访问插件-receiver"><a href="#宿主如何启动和访问插件-receiver" class="headerlink" title="宿主如何启动和访问插件 receiver"></a>宿主如何启动和访问插件 receiver</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/512ebd907d835af5bd0e3e79e105cf71.png" width="70%"></p><h1 id="Gradle-Plugin-简析-配置阶段"><a href="#Gradle-Plugin-简析-配置阶段" class="headerlink" title="Gradle Plugin 简析-配置阶段"></a>Gradle Plugin 简析-配置阶段</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/d1820c195a73b212927273db1a01a957.jpeg" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/7e535b08dffc9e4cc049833399ad27ac.jpeg" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/c4d52eff69590f1d8f6cd05e747f2352.jpeg" width="70%"></p><h1 id="Gradle-Plugin-简析-Task"><a href="#Gradle-Plugin-简析-Task" class="headerlink" title="Gradle Plugin 简析-Task"></a>Gradle Plugin 简析-Task</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/3a4dc470f1c202bbb1a31ed755a26833.jpeg" alt=""></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/eaf1bd949d5134e76ee0475d1aa6de04.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/image-20221024042430828.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/4de26cc8cb37e6fd7d18ed1f688aa691.jpeg" alt=""></p><h1 id="Gradle-Plugin-简析-Transformer"><a href="#Gradle-Plugin-简析-Transformer" class="headerlink" title="Gradle Plugin 简析- Transformer"></a>Gradle Plugin 简析- Transformer</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/image-20221024041343449.png" width="70%"> </p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/image-20221024041417834.png" alt=""></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/59a6618b11def831941c87d646cea777.jpeg" width="70%"></p><h1 id="简单的-SpecificTransform"><a href="#简单的-SpecificTransform" class="headerlink" title="简单的 SpecificTransform"></a>简单的 SpecificTransform</h1><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/88801d524e3219153bc6751a2079eeb2.jpeg" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/1cc0bd8a5123dbcdd72f11e7fcb2fa4c.jpeg" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/9b27a8746ce6e32ecfbe94a45bc14e15.jpeg" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/image-20221024041510698.png" alt=""></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/image-20221024041520343.png" alt=""></p><h1 id="复杂的-SpecificTransform"><a href="#复杂的-SpecificTransform" class="headerlink" title="复杂的 SpecificTransform"></a>复杂的 SpecificTransform</h1><h2 id="ContentProviderTransform"><a href="#ContentProviderTransform" class="headerlink" title="ContentProviderTransform"></a>ContentProviderTransform</h2><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/image-20221024041601332.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/image-20221024041707286.png" style="zoom: 67%;"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/7d4a91de71034adc326dfa8b36041474.jpeg" style="zoom: 67%;"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/dbc54d03d18165607adc639e7b29f046.jpeg" style="zoom: 67%;"></p><h2 id="DialogSupportTransform"><a href="#DialogSupportTransform" class="headerlink" title="DialogSupportTransform"></a>DialogSupportTransform</h2><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/image-20221024041755647.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/25c486e9ea14d0b468a237986f19cbf8.jpeg" style="zoom: 67%;"></p><h2 id="LayoutInflaterTransform"><a href="#LayoutInflaterTransform" class="headerlink" title="LayoutInflaterTransform"></a>LayoutInflaterTransform</h2><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/9b0e6d2485eafcd403d955116472b14f.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/51c6a2de8e34b18fb11f17c498781b7f.jpeg" width="70%">  </p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/b8dd3837c60bd23809ee18a496357000.jpeg" width="70%" style="zoom:50%;"></p><h2 id="PackageManagerTransform"><a href="#PackageManagerTransform" class="headerlink" title="PackageManagerTransform"></a>PackageManagerTransform</h2><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/a1889e74e623a0e46bc3365ca92a8bc6.png" width="70%"></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/d7ab9e13fc701548536b9d5ce69c3184.jpeg" alt=""></p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/image-20221024041930534.png" alt=""> </p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/04/f5c2b3edbe7189acea056ca80bb0fa07.jpeg" width="70%"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>Shadow 官网<a href="https://github.com/Tencent/Shadow">https://github.com/Tencent/Shadow</a></p><p>Shadow 作者本人的博客： <a href="https://juejin.cn/user/536217405890903">https://juejin.cn/user/536217405890903</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上周在团队内部做了一次技术分享，关于 shadow 核心技术原理，下面是这次分享的内容：&lt;/p&gt;
&lt;p&gt;我这里也提供了 pdf 的百度云地址，微信扫一扫就好～～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://coolqifiles.oss-cn-hangzhou.ali</summary>
      
    
    
    
    <category term="插件化" scheme="https://lishuaiqi.top/categories/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    <category term="Shadow" scheme="https://lishuaiqi.top/categories/%E6%8F%92%E4%BB%B6%E5%8C%96/Shadow/"/>
    
    
    <category term="Shadow" scheme="https://lishuaiqi.top/tags/Shadow/"/>
    
  </entry>
  
  <entry>
    <title>ViewDraw 第六篇 draw 流程分析</title>
    <link href="https://lishuaiqi.top/2020/04/21/ViewDraw-6-draw/"/>
    <id>https://lishuaiqi.top/2020/04/21/ViewDraw-6-draw/</id>
    <published>2020-04-21T12:46:25.000Z</published>
    <updated>2025-10-03T07:20:49.021Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章基于 Android N - 7.1.1 主要分析下 draw 方法的执行流程；</p><h1 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h1><p>在上面的 performTraversals 文章中，我们知道 perfomDraw 分为硬件绘制和软件绘制，这里我们只看软件绘制：</p><h2 id="1-1-mHardwareRenderer-draw-硬件绘制"><a href="#1-1-mHardwareRenderer-draw-硬件绘制" class="headerlink" title="1.1 mHardwareRenderer.draw - 硬件绘制"></a>1.1 mHardwareRenderer.draw - 硬件绘制</h2><p>我们先来看看硬件绘制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="literal">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">    <span class="comment">// If accessibility focus moved, always invalidate the root.</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">invalidateRoot</span> <span class="operator">=</span> accessibilityFocusDirty || mInvalidateRootRequested;</span><br><span class="line">    mInvalidateRootRequested = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw with hardware renderer.</span></span><br><span class="line">    mIsAnimating = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHardwareYOffset != yOffset || mHardwareXOffset != xOffset) &#123;</span><br><span class="line">        mHardwareYOffset = yOffset;</span><br><span class="line">        mHardwareXOffset = xOffset;</span><br><span class="line">        invalidateRoot = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (invalidateRoot) &#123;</span><br><span class="line">        mAttachInfo.mHardwareRenderer.invalidateRoot();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dirty.setEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">updated</span> <span class="operator">=</span> updateContentDrawBounds();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mReportNextDraw) &#123;</span><br><span class="line">        mAttachInfo.mHardwareRenderer.setStopped(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (updated) &#123;</span><br><span class="line">        requestDrawWindow();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】通过 ThreadedRenderer 进行绘制；</span></span><br><span class="line">    mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, <span class="built_in">this</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="1-2-drawSoftware-软件绘制"><a href="#1-2-drawSoftware-软件绘制" class="headerlink" title="1.2 drawSoftware - 软件绘制"></a>1.2 drawSoftware - 软件绘制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="type">int</span> xoff, <span class="type">int</span> yoff,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> scalingRequired, Rect dirty)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dirty.left;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> dirty.top;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> dirty.right;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> dirty.bottom;</span><br><span class="line">        <span class="comment">//【1】锁定 canvas，并返回画布 Canvas；</span></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The dirty rectangle can be modified by Surface.lockCanvas()</span></span><br><span class="line">        <span class="comment">// noinspection ConstantConditions</span></span><br><span class="line">        <span class="keyword">if</span> (left != dirty.left || top != dirty.top || right != dirty.right</span><br><span class="line">                || bottom != dirty.bottom) &#123;</span><br><span class="line">            attachInfo.mIgnoreDirtyState = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Do this in native</span></span><br><span class="line">        canvas.setDensity(mDensity);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Surface.OutOfResourcesException e) &#123;</span><br><span class="line">        handleOutOfResourcesException(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Log.e(mTag, <span class="string">&quot;Could not lock surface&quot;</span>, e);</span><br><span class="line">        <span class="comment">// Don&#x27;t assume this is due to out of memory, it could be</span></span><br><span class="line">        <span class="comment">// something else, and if it is something else then we could</span></span><br><span class="line">        <span class="comment">// kill stuff (or ourself) for no reason.</span></span><br><span class="line">        mLayoutRequested = <span class="literal">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_DRAW) &#123;</span><br><span class="line">            Log.v(mTag, <span class="string">&quot;Surface &quot;</span> + surface + <span class="string">&quot; drawing to bitmap w=&quot;</span></span><br><span class="line">                    + canvas.getWidth() + <span class="string">&quot;, h=&quot;</span> + canvas.getHeight());</span><br><span class="line">            <span class="comment">//canvas.drawARGB(255, 255, 0, 0);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该位图的格式包含 Alpha 通道，则我们需要在绘制之前清除它，以便 child 可以在透明背景上正确地重新组合其图形。</span></span><br><span class="line">        <span class="comment">// 这将自动考虑裁剪区域或者脏区，或者如果我们要应用偏移，则需要清除没有出现偏移的区域，以避免在空白区域中留下垃圾。</span></span><br><span class="line">        <span class="keyword">if</span> (!canvas.isOpaque() || yoff != <span class="number">0</span> || xoff != <span class="number">0</span>) &#123;</span><br><span class="line">            canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirty.setEmpty(); <span class="comment">// 将 dirty 区域置空；</span></span><br><span class="line">        mIsAnimating = <span class="literal">false</span>;</span><br><span class="line">        mView.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DRAW) &#123;</span><br><span class="line">            <span class="type">Context</span> <span class="variable">cxt</span> <span class="operator">=</span> mView.getContext();</span><br><span class="line">            Log.i(mTag, <span class="string">&quot;Drawing: package:&quot;</span> + cxt.getPackageName() +</span><br><span class="line">                    <span class="string">&quot;, metrics=&quot;</span> + cxt.getResources().getDisplayMetrics() +</span><br><span class="line">                    <span class="string">&quot;, compatibilityInfo=&quot;</span> + cxt.getResources().getCompatibilityInfo());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas.translate(-xoff, -yoff);</span><br><span class="line">            <span class="keyword">if</span> (mTranslator != <span class="literal">null</span>) &#123;</span><br><span class="line">                mTranslator.translateCanvas(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">            attachInfo.mSetIgnoreDirtyState = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2-core】调用 DecorView（GroupView）的 draw 方法；</span></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!attachInfo.mSetIgnoreDirtyState) &#123;</span><br><span class="line">                <span class="comment">// Only clear the flag if it was not set during the mView.draw() call</span></span><br><span class="line">                attachInfo.mIgnoreDirtyState = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【3】解锁 canvas</span></span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            Log.e(mTag, <span class="string">&quot;Could not unlock surface&quot;</span>, e);</span><br><span class="line">            mLayoutRequested = <span class="literal">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">            <span class="comment">//noinspection ReturnInsideFinallyBlock</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCAL_LOGV) &#123;</span><br><span class="line">            Log.v(mTag, <span class="string">&quot;Surface &quot;</span> + surface + <span class="string">&quot; unlockCanvasAndPost&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的关键代码就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【2-core】调用 DecorView（GroupView）的 draw 方法；</span></span><br><span class="line">mView.draw(canvas);</span><br></pre></td></tr></table></figure><p>这里的 mView 是 DecorView：</p><h1 id="2-DecorView"><a href="#2-DecorView" class="headerlink" title="2 DecorView"></a>2 DecorView</h1><h2 id="2-1-draw"><a href="#2-1-draw" class="headerlink" title="2.1 draw"></a>2.1 draw</h2><p>DecorView 复写了 draw 方法，但是其内部依然是调用了父类 View 的 draw 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;4.1】进入 view；</span></span><br><span class="line">    <span class="built_in">super</span>.draw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMenuBackground != <span class="literal">null</span>) &#123;</span><br><span class="line">        mMenuBackground.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-onDraw"><a href="#2-2-onDraw" class="headerlink" title="2.2 onDraw"></a>2.2 onDraw</h2><p>DecorView 复写了 view 的 onDraw 方法，但是其内部主要逻辑依然是调用了父类的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas c)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;4.1】开启 view 的绘制；</span></span><br><span class="line">    <span class="built_in">super</span>.onDraw(c);</span><br><span class="line">    mBackgroundFallback.draw(mContentRoot, c, mWindow.mContentParent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-ViewGroup"><a href="#3-ViewGroup" class="headerlink" title="3 ViewGroup"></a>3 ViewGroup</h1><h2 id="3-1-dispatchDraw-核心"><a href="#3-1-dispatchDraw-核心" class="headerlink" title="3.1 dispatchDraw - 核心"></a>3.1 dispatchDraw - 核心</h2><p>ViewGroup 复写了 view 的 dispatchDraw 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">dispatchDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="comment">//【0】是否使用 renderNode 属性，实际上是针对于硬件加速的，软件绘制返回的是 false；</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">usingRenderNodeProperties</span> <span class="operator">=</span> canvas.isRecordingFor(mRenderNode);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childrenCount</span> <span class="operator">=</span> mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> mGroupFlags;</span><br><span class="line">    <span class="comment">//【1】判断是否有动画，如果有动画，同时 child view 是可见的 VISIBLE，那么这里会设置动画参数；</span></span><br><span class="line">    <span class="comment">// FLAG_RUN_ANIMATION 标志位表示要运行动画。</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; FLAG_RUN_ANIMATION) != <span class="number">0</span> &amp;&amp; canAnimate()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">buildCache</span> <span class="operator">=</span> !isHardwareAccelerated();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> children[i];</span><br><span class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;</span><br><span class="line">                <span class="comment">//【1.1】动画的参数是保存在 view 的 LayoutParams 中的；</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> child.getLayoutParams();</span><br><span class="line">                attachLayoutAnimationParameters(child, params, i, childrenCount);</span><br><span class="line">                bindLayoutAnimation(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1.2】将布局动画器的应用保存到 controller，并启动动画；</span></span><br><span class="line">        <span class="comment">// 布局动画控制器用于对布局或视图组的 child view 进行动画处理。每个孩子都使用相同的动画，但是对于每个孩子，动画在不同的时间开始。</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">LayoutAnimationController</span> <span class="variable">controller</span> <span class="operator">=</span> mLayoutAnimationController;</span><br><span class="line">        <span class="keyword">if</span> (controller.willOverlap()) &#123;</span><br><span class="line">            mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        controller.start();</span><br><span class="line">        <span class="comment">//【1.3】去掉上面的 FLAG_RUN_ANIMATION 标志位，因为动画开始了，同时要去掉 FLAG_ANIMATION_DONE 标志位</span></span><br><span class="line">        <span class="comment">// FLAG_ANIMATION_DONE 表示动画结束了或者没有动画；</span></span><br><span class="line">        mGroupFlags &amp;= ~FLAG_RUN_ANIMATION;</span><br><span class="line">        mGroupFlags &amp;= ~FLAG_ANIMATION_DONE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1.4】如果有动画监听器，那就回调，显然，这个是我们要设置进去的；</span></span><br><span class="line">        <span class="keyword">if</span> (mAnimationListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            mAnimationListener.onAnimationStart(controller.getAnimation());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">clipSaveCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//【2】这里判断了下 viewgroup 是否有 padding 区域，如果有的话，那么绘制的区域就要减去 padding</span></span><br><span class="line">    <span class="comment">// 所以下面 save 的画布的状态，裁剪了 canvas，去掉了 padding 区域；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">clipToPadding</span> <span class="operator">=</span> (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;</span><br><span class="line">    <span class="keyword">if</span> (clipToPadding) &#123;</span><br><span class="line">        clipSaveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);</span><br><span class="line">        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,</span><br><span class="line">                mScrollX + mRight - mLeft - mPaddingRight,</span><br><span class="line">                mScrollY + mBottom - mTop - mPaddingBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】这里又去掉了 PFLAG_DRAW_ANIMATION 和 FLAG_INVALIDATE_REQUIRED 标志位；</span></span><br><span class="line">    <span class="comment">// 如果设置了 FLAG_INVALIDATE_REQUIRED ，dispatchDraw 将调用 invalidate，</span></span><br><span class="line">    <span class="comment">// 当一个 child 需要 invalidate 并且设置了 FLAG_OPTIMIZE_INVALIDATE 时，</span></span><br><span class="line">    <span class="comment">// drawChild 会设置该标志位；</span></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION;</span><br><span class="line">    mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">more</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">drawingTime</span> <span class="operator">=</span> getDrawingTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usingRenderNodeProperties) canvas.insertReorderBarrier();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">transientCount</span> <span class="operator">=</span> mTransientIndices == <span class="literal">null</span> ? <span class="number">0</span> : mTransientIndices.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">transientIndex</span> <span class="operator">=</span> transientCount != <span class="number">0</span> ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】这里的意思：如果没有开启硬件加速（HW accelerated），那么会对 child 的绘制顺序做一个预排列 preorderedList</span></span><br><span class="line">    <span class="comment">// 如果开启硬件加速，那么这里无需排列，因为硬件管道会在内部进行重新排序；</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties <span class="comment">// 软件绘制返回 false</span></span><br><span class="line">            ? <span class="literal">null</span> : buildOrderedChildList(); <span class="comment">//【--&gt;3.1.1】这里是会对 view 预排列；</span></span><br><span class="line">    <span class="comment">//【5】如果开启了硬件加速（没有预排列），同时我们指定了 ViewGroup 按照 getChildDrawingOrder 定义的顺序绘制其子级 view</span></span><br><span class="line">    <span class="comment">// 是否按照指定顺序，看是否指定了 FLAG_USE_CHILD_DRAWING_ORDER 标志位；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">customOrder</span> <span class="operator">=</span> preorderedList == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">transientChild</span> <span class="operator">=</span> mTransientViews.get(transientIndex);</span><br><span class="line">            <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                    transientChild.getAnimation() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【--&gt;3.2】绘制 transientChild（可能是 view/viewGroup）</span></span><br><span class="line">                more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">            &#125;</span><br><span class="line">            transientIndex++;</span><br><span class="line">            <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</span><br><span class="line">                transientIndex = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【6】这里就是绘制 child view 了，这里会对 child 的绘制顺序做调整，有一个容器顺序和绘制顺序的不同；</span></span><br><span class="line">        <span class="comment">//【--&gt;3.1.1】获取调整后的绘制顺序；</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">        <span class="comment">//【--&gt;3.1.2】根据调整后的绘制顺序返回 view；</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;3.2】绘制 child（可能是 view/viewGroup）</span></span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">transientChild</span> <span class="operator">=</span> mTransientViews.get(transientIndex);</span><br><span class="line">        <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                transientChild.getAnimation() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;3.2】绘制额外的 transient child view（可能是 view/viewGroup）</span></span><br><span class="line">            more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">        transientIndex++;</span><br><span class="line">        <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (preorderedList != <span class="literal">null</span>) preorderedList.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】绘制所有的正在消失的有动画的 view；</span></span><br><span class="line">    <span class="keyword">if</span> (mDisappearingChildren != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">disappearingCount</span> <span class="operator">=</span> disappearingChildren.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> disappearingCount; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> disappearingChildren.get(i);</span><br><span class="line">            <span class="comment">//【--&gt;3.2】绘制 child（可能是 view/viewGroup）</span></span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (usingRenderNodeProperties) canvas.insertInorderBarrier();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugDraw()) &#123;</span><br><span class="line">        onDebugDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【8】如果前面针对 padding 做了画布裁剪，这里就恢复它；</span></span><br><span class="line">    <span class="keyword">if</span> (clipToPadding) &#123;</span><br><span class="line">        canvas.restoreToCount(clipSaveCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【9】mGroupFlags 可能会被 drawChild() 更改，所以这里将副本保存到 flags 中；</span></span><br><span class="line">    flags = mGroupFlags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) &#123;</span><br><span class="line">        invalidate(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【10】判断完成了吗</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; FLAG_ANIMATION_DONE) == <span class="number">0</span> &amp;&amp; (flags &amp; FLAG_NOTIFY_ANIMATION_LISTENER) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            mLayoutAnimationController.isDone() &amp;&amp; !more) &#123;</span><br><span class="line">        <span class="comment">//【10。1】设置 FLAG_NOTIFY_ANIMATION_LISTENER，调用 mAnimationListener.onAnimationEnd() 并在必要时删除子级Bitmap缓存。</span></span><br><span class="line">        <span class="comment">// 当布局动画结束时（设置FLAG_ANIMATION_DONE之后）设置此标志。</span></span><br><span class="line">        mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                notifyAnimationListener(); <span class="comment">// 这里面会调用 mAnimationListener.onAnimationEnd()</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        post(end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-buildOrderedChildList"><a href="#3-1-1-buildOrderedChildList" class="headerlink" title="3.1.1 buildOrderedChildList"></a>3.1.1 buildOrderedChildList</h3><p>该方法会返回 child view 的预排序列表 mPreSortedChildren，首先按 Z 排序，然后按 child view 绘制顺序排序（如果适用）。</p><p>使用后必须清除此列表，以免泄漏子视图。</p><p>使用稳定的插入排序，通常为 O（n）时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;View&gt; <span class="title function_">buildOrderedChildList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childrenCount</span> <span class="operator">=</span> mChildrenCount;</span><br><span class="line">    <span class="comment">//【1】如果 child 不超过 2 个，或者没有 view 设置了 android:elevation android:translationZ</span></span><br><span class="line">    <span class="comment">// 那就无需排序；</span></span><br><span class="line">    <span class="keyword">if</span> (childrenCount &lt;= <span class="number">1</span> || !hasChildWithZ()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (mPreSortedChildren == <span class="literal">null</span>) &#123;</span><br><span class="line">        mPreSortedChildren = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(childrenCount);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// callers should clear, so clear shouldn&#x27;t be necessary, but for safety...</span></span><br><span class="line">        mPreSortedChildren.clear();</span><br><span class="line">        mPreSortedChildren.ensureCapacity(childrenCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;3.1.1.1】判断是否开启自定义绘制顺序；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">customOrder</span> <span class="operator">=</span> isChildrenDrawingOrderEnabled();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;3.1.2】获取绘制顺序（可能被更改）</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">nextChild</span> <span class="operator">=</span> mChildren[childIndex];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">currentZ</span> <span class="operator">=</span> nextChild.getZ();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 Z 值越大的 view 查到 list 的前面，其他的相对位置不变；</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (insertIndex &gt; <span class="number">0</span> &amp;&amp; mPreSortedChildren.get(insertIndex - <span class="number">1</span>).getZ() &gt; currentZ) &#123;</span><br><span class="line">            insertIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        mPreSortedChildren.add(insertIndex, nextChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mPreSortedChildren;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 view 内部都有一个，它包含 View 属性（软硬都用），也可能包含 View 内容的 DisplayList（硬件加速使用）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RenderNode mRenderNode</span><br></pre></td></tr></table></figure><p>我们看看 hasChildWithZ ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// Child views of this ViewGroup</span></span><br><span class="line">   <span class="keyword">private</span> View[] mChildren;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasChildWithZ</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mChildrenCount; i++) &#123;</span><br><span class="line">           <span class="comment">//【1】这里调用了 View 的 getZ 方法：</span></span><br><span class="line">           <span class="keyword">if</span> (mChildren[i].getZ() != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>判断该 View 的是否有可视 z 位置（以像素为单位）。该方法等价于  setTranslationZ + getElevation 属性；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">&quot;drawing&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getZ</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getElevation() + getTranslationZ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是 android:elevation 和 android:translationZ </p><h4 id="3-1-1-1-isChildrenDrawingOrderEnabled"><a href="#3-1-1-1-isChildrenDrawingOrderEnabled" class="headerlink" title="3.1.1.1 isChildrenDrawingOrderEnabled"></a>3.1.1.1 isChildrenDrawingOrderEnabled</h4><p>判断下 ViewGroup 是否按照 getChildDrawingOrder 返回的方式绘制 view：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">&quot;drawing&quot;</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isChildrenDrawingOrderEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (mGroupFlags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == FLAG_USE_CHILD_DRAWING_ORDER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-getAndVerifyPreorderedIndex"><a href="#3-1-2-getAndVerifyPreorderedIndex" class="headerlink" title="3.1.2 getAndVerifyPreorderedIndex"></a>3.1.2 getAndVerifyPreorderedIndex</h3><p>获取 view 实际绘制顺序；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getAndVerifyPreorderedIndex</span><span class="params">(<span class="type">int</span> childrenCount, <span class="type">int</span> i, <span class="type">boolean</span> customOrder)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> childIndex;</span><br><span class="line">    <span class="keyword">if</span> (customOrder) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;3.1.2】如果 view group 重写了绘制顺序，那么这会获取重写后的绘制顺序；</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childIndex1</span> <span class="operator">=</span> getChildDrawingOrder(childrenCount, i);</span><br><span class="line">        <span class="keyword">if</span> (childIndex1 &gt;= childrenCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;getChildDrawingOrder() &quot;</span></span><br><span class="line">                    + <span class="string">&quot;returned invalid index &quot;</span> + childIndex1</span><br><span class="line">                    + <span class="string">&quot; (child count is &quot;</span> + childrenCount + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        childIndex = childIndex1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        childIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> childIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-getChildDrawingOrder"><a href="#3-1-3-getChildDrawingOrder" class="headerlink" title="3.1.3 getChildDrawingOrder"></a>3.1.3 getChildDrawingOrder</h3><p>修改绘制顺序，如果要更改子代的绘制顺序，ViewGroup 要重写此方法。默认情况下，它返回 drawingPosition！</p><p>想要这个方法生效，那么就要先调用：setChildrenDrawingOrderEnabled</p><p>参数：drawingPosition，当前的绘制顺序；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getChildDrawingOrder</span><span class="params">(<span class="type">int</span> childCount, <span class="type">int</span> drawingPosition)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> drawingPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-drawChild-核心"><a href="#3-2-drawChild-核心" class="headerlink" title="3.2 drawChild - 核心"></a>3.2 drawChild - 核心</h2><p>绘制 child view。</p><p>这个是直接翻译的注视：此方法负责使画布处于正确的状态。这包括剪切，平移以使孩子的滚动原点位于 0、0，并应用任何动画转换。</p><p>可以看出子至少有个作用：</p><p>1、修正 canvas 的自己状态；2、动画处理；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">drawChild</span><span class="params">(Canvas canvas, View child, <span class="type">long</span> drawingTime)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;4.2】绘制 child 开始了，调用了每个 child 的 draw 方法；</span></span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="built_in">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制 child 的逻辑是在 view 的 draw[3] 里面；</p><h2 id="3-3-dispatchGetDisplayList-核心"><a href="#3-3-dispatchGetDisplayList-核心" class="headerlink" title="3.3 dispatchGetDisplayList - 核心"></a>3.3 dispatchGetDisplayList - 核心</h2><p>ViewGroup 通知 child view 重新创建自身的 DisplayList：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">dispatchGetDisplayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> children[i];</span><br><span class="line">        <span class="keyword">if</span> (((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;3.3.1】对于每个可见或者有动画的 child view，创建其 DisplayList！</span></span><br><span class="line">            recreateChildDisplayList(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mOverlay != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">overlayView</span> <span class="operator">=</span> mOverlay.getOverlayView();</span><br><span class="line">        recreateChildDisplayList(overlayView);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDisappearingChildren != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">disappearingCount</span> <span class="operator">=</span> disappearingChildren.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; disappearingCount; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> disappearingChildren.get(i);</span><br><span class="line">            recreateChildDisplayList(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-1-recreateChildDisplayList"><a href="#3-3-1-recreateChildDisplayList" class="headerlink" title="3.3.1 recreateChildDisplayList"></a>3.3.1 recreateChildDisplayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recreateChildDisplayList</span><span class="params">(View child)</span> &#123;</span><br><span class="line">    child.mRecreateDisplayList = (child.mPrivateFlags &amp; PFLAG_INVALIDATED) != <span class="number">0</span>;</span><br><span class="line">    child.mPrivateFlags &amp;= ~PFLAG_INVALIDATED;</span><br><span class="line">    <span class="comment">//【--&gt;4.2.1】这里又调用了 updateDisplayListIfDirty 方法：</span></span><br><span class="line">    child.updateDisplayListIfDirty();</span><br><span class="line">    child.mRecreateDisplayList = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-View"><a href="#4-View" class="headerlink" title="4 View"></a>4 View</h1><h2 id="4-1-draw-1-核心"><a href="#4-1-draw-1-核心" class="headerlink" title="4.1 draw[1] - 核心"></a>4.1 draw[1] - 核心</h2><p>View 的方法是最核心的部分：</p><p>将 View（及其所有 child）绘制（渲染）到给定的 Canvas。 在调用此函数之前，View 必须完成测量和布局。</p><p>自定义 View 时，请实现 onDraw 而不要重写 draw（draw 方法会调用 onDraw）。</p><p> 如果确实需要重写 draw，一定要调用 super.draw!!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">privateFlags</span> <span class="operator">=</span> mPrivateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">dirtyOpaque</span> <span class="operator">=</span> (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == <span class="literal">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> saveCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】绘制背景：</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;4.1.1】绘制背景；</span></span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】是否跳过 2 到 5 的步骤，这里判断了 ViewFlags 是否设置了 FADING_EDGE_HORIZONTAL/FADING_EDGE_VERTICAL</span></span><br><span class="line">    <span class="comment">// 这两个标志位表示，如果 view 滚动的话，那么他的边缘会变淡（淡入淡出效果）；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">horizontalEdges</span> <span class="operator">=</span> (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">verticalEdges</span> <span class="operator">=</span> (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;4.1.2】绘制当前 view 的内容；</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【--&gt;4.1.2】如果是 view 的话，只是一个空实现；</span></span><br><span class="line">        <span class="comment">//【--&gt;3.1】如果是 ViewGroup 的话，尝试绘制 child view 的内容；</span></span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【5】绘制叠加层；</span></span><br><span class="line">        <span class="keyword">if</span> (mOverlay != <span class="literal">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【--&gt;4.1.4】绘制装饰前景（前景，滚动条等等）</span></span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常来说，到这里绘制就结束了；</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】如果设置了 fade 效果的话，那么上面会跳过一系列的绘制操作；</span></span><br><span class="line">    <span class="comment">// 因为下面会特殊的处理；</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">drawTop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">drawBottom</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">drawLeft</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">drawRight</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="variable">topFadeStrength</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">bottomFadeStrength</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">leftFadeStrength</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">rightFadeStrength</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【8】如果是设置了 fade 效果的话，下面会对 canvas 的 layer 图层进行保存；</span></span><br><span class="line">    <span class="comment">// 下面先是计算了下要绘制的边界距离；</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">paddingLeft</span> <span class="operator">=</span> mPaddingLeft;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">offsetRequired</span> <span class="operator">=</span> isPaddingOffsetRequired();</span><br><span class="line">    <span class="keyword">if</span> (offsetRequired) &#123;</span><br><span class="line">        paddingLeft += getLeftPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> mScrollX + paddingLeft;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + mRight - mLeft - mPaddingRight - paddingLeft;</span><br><span class="line">    <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> mScrollY + getFadeTop(offsetRequired);</span><br><span class="line">    <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> top + getFadeHeight(offsetRequired);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offsetRequired) &#123;</span><br><span class="line">        right += getRightPaddingOffset();</span><br><span class="line">        bottom += getBottomPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ScrollabilityCache</span> <span class="variable">scrollabilityCache</span> <span class="operator">=</span> mScrollCache;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">fadeHeight</span> <span class="operator">=</span> scrollabilityCache.fadingEdgeLength;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>) fadeHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clip the fade length if top and bottom fades overlap</span></span><br><span class="line">    <span class="comment">// overlapping fades produce odd-looking artifacts</span></span><br><span class="line">    <span class="keyword">if</span> (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</span><br><span class="line">        length = (bottom - top) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also clip horizontal fades if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</span><br><span class="line">        length = (right - left) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【9】判断下四个方向是否要绘制效果；</span></span><br><span class="line">    <span class="keyword">if</span> (verticalEdges) &#123;</span><br><span class="line">        topFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getTopFadingEdgeStrength()));</span><br><span class="line">        drawTop = topFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">        bottomFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getBottomFadingEdgeStrength()));</span><br><span class="line">        drawBottom = bottomFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (horizontalEdges) &#123;</span><br><span class="line">        leftFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getLeftFadingEdgeStrength()));</span><br><span class="line">        drawLeft = leftFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">        rightFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getRightFadingEdgeStrength()));</span><br><span class="line">        drawRight = rightFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    saveCount = canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">solidColor</span> <span class="operator">=</span> getSolidColor();</span><br><span class="line">    <span class="keyword">if</span> (solidColor == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line">        <span class="comment">//【10】这里开始保存了画布的 layer，length 表示这个 fade 区域的宽度。</span></span><br><span class="line">        <span class="comment">// 这里相当于创建了一个新的 layer 并入栈，四个坐标构成了一个矩形区域；</span></span><br><span class="line">        <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, right, top + length, <span class="literal">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">            canvas.saveLayer(left, bottom - length, right, bottom, <span class="literal">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, left + length, bottom, <span class="literal">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">            canvas.saveLayer(right - length, top, right, bottom, <span class="literal">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【--&gt;4.1.2】保存完 layer 后，我们先绘制当前 view 的内容；</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【--&gt;4.1.3】然后绘制 child 的内容；</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【11】绘制淡入淡出效果，并还原图层，淡入淡出实际上是在另外一个 layer 上绘制的；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Paint</span> <span class="variable">p</span> <span class="operator">=</span> scrollabilityCache.paint;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Matrix</span> <span class="variable">matrix</span> <span class="operator">=</span> scrollabilityCache.matrix;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Shader</span> <span class="variable">fade</span> <span class="operator">=</span> scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * topFadeStrength);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * bottomFadeStrength);</span><br><span class="line">        matrix.postRotate(<span class="number">180</span>);</span><br><span class="line">        matrix.postTranslate(left, bottom);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, bottom - length, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * leftFadeStrength);</span><br><span class="line">        matrix.postRotate(-<span class="number">90</span>);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, left + length, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * rightFadeStrength);</span><br><span class="line">        matrix.postRotate(<span class="number">90</span>);</span><br><span class="line">        matrix.postTranslate(right, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(right - length, top, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas.restoreToCount(saveCount); <span class="comment">// 还原图层；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【12】绘制叠加层；</span></span><br><span class="line">    <span class="keyword">if</span> (mOverlay != <span class="literal">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">        mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【13】绘制装饰前景（前景，滚动条等等）</span></span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注视我们可以看出，绘制过程有如下的绘制步骤，这些绘制步骤必须以适当的顺序执行：</p><p>1、绘制背景<br>2、如有必要，保存画布的图层以准备淡入淡出<br>3、绘制视图的内容<br>4、绘制 child<br>5、如有必要，绘制褪色边缘并还原图层<br>6、绘制装饰（例如滚动条）</p><p>对于增加了淡入淡出效果情况，也是很类似，只不过增加了 savelayer 和 restore 的操作；</p><h3 id="4-1-1-drawBackground"><a href="#4-1-1-drawBackground" class="headerlink" title="4.1.1 drawBackground"></a>4.1.1 drawBackground</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawBackground</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Drawable</span> <span class="variable">background</span> <span class="operator">=</span> mBackground;</span><br><span class="line">    <span class="keyword">if</span> (background == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setBackgroundBounds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】如果是硬件加速的话，通过 renderNode 记录绘制操作；</span></span><br><span class="line">    <span class="keyword">if</span> (canvas.isHardwareAccelerated() &amp;&amp; mAttachInfo != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; mAttachInfo.mHardwareRenderer != <span class="literal">null</span>) &#123;</span><br><span class="line">        mBackgroundRenderNode = getDrawableRenderNode(background, mBackgroundRenderNode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RenderNode</span> <span class="variable">renderNode</span> <span class="operator">=</span> mBackgroundRenderNode;</span><br><span class="line">        <span class="keyword">if</span> (renderNode != <span class="literal">null</span> &amp;&amp; renderNode.isValid()) &#123;</span><br><span class="line">            setBackgroundRenderNodeProperties(renderNode);</span><br><span class="line">            <span class="comment">//【1.1】可以看到硬件加速的 canvas 是 DisplayListCanvas 类型的；</span></span><br><span class="line">            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">scrollX</span> <span class="operator">=</span> mScrollX;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">scrollY</span> <span class="operator">=</span> mScrollY;</span><br><span class="line">    <span class="comment">//【2】软件绘制，就是调用 Drawable.draw 方法；</span></span><br><span class="line">    <span class="keyword">if</span> ((scrollX | scrollY) == <span class="number">0</span>) &#123;</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        canvas.translate(scrollX, scrollY);</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">        canvas.translate(-scrollX, -scrollY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不多说了；</p><h3 id="4-1-2-onDraw-核心"><a href="#4-1-2-onDraw-核心" class="headerlink" title="4.1.2 onDraw - 核心"></a>4.1.2 onDraw - 核心</h3><p>默认是空方法，需要自己实现；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是绘制 background 的；</p><h3 id="4-1-3-dispatchDraw-核心"><a href="#4-1-3-dispatchDraw-核心" class="headerlink" title="4.1.3 dispatchDraw - 核心"></a>4.1.3 dispatchDraw - 核心</h3><p>默认是空方法，需要自己实现；</p><p>这个方法由 draw 调用，用于绘制 child view，一般来说 view group 肯定是需要重写这个方法，在 onDraw 方法调用后再调用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">dispatchDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-4-onDrawForeground"><a href="#4-1-4-onDrawForeground" class="headerlink" title="4.1.4 onDrawForeground"></a>4.1.4 onDrawForeground</h3><p>绘制 view 的所有前景内容。</p><p>前景内容可能包括滚动条、可绘制对象或其他特定于视图的装饰。前景会被绘制在 view 内容的顶部。</p><p>前景可以通过 setForeground 方法设置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDrawForeground</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    onDrawScrollIndicators(canvas);</span><br><span class="line">    onDrawScrollBars(canvas);</span><br><span class="line">    <span class="comment">//【1】依然是获取 Drawable，然后将 Drawable 会知道 canvas 上去；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Drawable</span> <span class="variable">foreground</span> <span class="operator">=</span> mForegroundInfo != <span class="literal">null</span> ? mForegroundInfo.mDrawable : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (foreground != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mForegroundInfo.mBoundsChanged) &#123;</span><br><span class="line">            mForegroundInfo.mBoundsChanged = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Rect</span> <span class="variable">selfBounds</span> <span class="operator">=</span> mForegroundInfo.mSelfBounds;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Rect</span> <span class="variable">overlayBounds</span> <span class="operator">=</span> mForegroundInfo.mOverlayBounds;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mForegroundInfo.mInsidePadding) &#123;</span><br><span class="line">                selfBounds.set(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                selfBounds.set(getPaddingLeft(), getPaddingTop(),</span><br><span class="line">                        getWidth() - getPaddingRight(), getHeight() - getPaddingBottom());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ld</span> <span class="operator">=</span> getLayoutDirection();</span><br><span class="line">            Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(),</span><br><span class="line">                    foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld);</span><br><span class="line">            foreground.setBounds(overlayBounds);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】核心逻辑，软件绘制；</span></span><br><span class="line">        foreground.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-draw-3-核心"><a href="#4-2-draw-3-核心" class="headerlink" title="4.2 draw[3] - 核心"></a>4.2 draw[3] - 核心</h2><p> 这个方法由 ViewGroup.drawChild() 触发，绘制 child；</p><p>其实可以看到，无论是软件绘制，还是硬件绘制，都会进入这个方法，最终都会调用到<code>draw(Canvas canvas)</code>方法来绘制，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="type">long</span> drawingTime)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】判断是否开启了硬件加速，软件绘制返回 false，硬件绘制对应的是 DisplayListCanvas 返回的是 true；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hardwareAcceleratedCanvas</span> <span class="operator">=</span> canvas.isHardwareAccelerated();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果使用的是硬件加速，那么是通过 RenderNode + DisplayList 的方式绘制，那么 drawingWithRenderNode 为 true；</span></span><br><span class="line">    <span class="comment">//（对于没有 attach 的 view（不需要显示），他是没有 DisplayList；如果不是通过硬件减速的话，那么不会通过 RenderNode 绘制）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">drawingWithRenderNode</span> <span class="operator">=</span> mAttachInfo != <span class="literal">null</span></span><br><span class="line">        &amp;&amp; mAttachInfo.mHardwareAccelerated</span><br><span class="line">        &amp;&amp; hardwareAcceleratedCanvas;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">more</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">childHasIdentityMatrix</span> <span class="operator">=</span> hasIdentityMatrix();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentFlags</span> <span class="operator">=</span> parent.mGroupFlags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((parentFlags &amp; ViewGroup.FLAG_CLEAR_TRANSFORMATION) != <span class="number">0</span>) &#123;</span><br><span class="line">        parent.getChildTransformation().clear();</span><br><span class="line">        parent.mGroupFlags &amp;= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Transformation</span> <span class="variable">transformToApply</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">concatMatrix</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//【3】对动画的一些处理；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">scalingRequired</span> <span class="operator">=</span> mAttachInfo != <span class="literal">null</span> &amp;&amp; mAttachInfo.mScalingRequired;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Animation</span> <span class="variable">a</span> <span class="operator">=</span> getAnimation(); <span class="comment">// 获取当前 view 关联的动画；</span></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);</span><br><span class="line">        concatMatrix = a.willChangeTransformationMatrix();</span><br><span class="line">        <span class="keyword">if</span> (concatMatrix) &#123;</span><br><span class="line">            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;</span><br><span class="line">        &#125;</span><br><span class="line">        transformToApply = parent.getChildTransformation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有动画的话，就就清除掉动画相关的数据 matrix；</span></span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != <span class="number">0</span>) &#123;</span><br><span class="line">            mRenderNode.setAnimationMatrix(<span class="literal">null</span>);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!drawingWithRenderNode</span><br><span class="line">            &amp;&amp; (parentFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Transformation</span> <span class="variable">t</span> <span class="operator">=</span> parent.getChildTransformation();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hasTransform</span> <span class="operator">=</span> parent.getChildStaticTransformation(<span class="built_in">this</span>, t);</span><br><span class="line">            <span class="keyword">if</span> (hasTransform) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">transformType</span> <span class="operator">=</span> t.getTransformationType();</span><br><span class="line">                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : <span class="literal">null</span>;</span><br><span class="line">                concatMatrix = (transformType &amp; Transformation.TYPE_MATRIX) != <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    concatMatrix |= !childHasIdentityMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】设置该标志位，draw 才能成功调用 invalidate 方法；</span></span><br><span class="line">    mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!concatMatrix &amp;&amp;</span><br><span class="line">        (parentFlags &amp; (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS |</span><br><span class="line">                        ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN &amp;&amp;</span><br><span class="line">        canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) &amp;&amp;</span><br><span class="line">        (mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) == <span class="number">0</span>) &#123;</span><br><span class="line">        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;</span><br><span class="line">        <span class="keyword">return</span> more;</span><br><span class="line">    &#125;</span><br><span class="line">    mPrivateFlags2 &amp;= ~PFLAG2_VIEW_QUICK_REJECTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】如果是使用的硬件加速，那么会处理下 INVALIDATED 标记；</span></span><br><span class="line">    <span class="keyword">if</span> (hardwareAcceleratedCanvas) &#123;</span><br><span class="line">        <span class="comment">//【5.1】清除 PFLAG_INVALIDATED 标志，让 invalidate 在渲染过程中发生，但将标志的值临时保留在 mRecreateDisplayList 标志中</span></span><br><span class="line">        mRecreateDisplayList = (mPrivateFlags &amp; PFLAG_INVALIDATED) != <span class="number">0</span>;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_INVALIDATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">RenderNode</span> <span class="variable">renderNode</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 硬件绘制用到的渲染节点（gpu）</span></span><br><span class="line">    <span class="type">Bitmap</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 软件绘制用到的绘制缓存（cpu）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】针对 layer 做处理；</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">layerType</span> <span class="operator">=</span> getLayerType();</span><br><span class="line">    <span class="keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layerType != LAYER_TYPE_NONE) &#123;</span><br><span class="line">            <span class="comment">// 如果不是硬件绘制，也没制定 layer 类型，则将 HW 图层视为 SW，同时创建绘制缓存；</span></span><br><span class="line">            layerType = LAYER_TYPE_SOFTWARE;</span><br><span class="line">            <span class="comment">//【--&gt;4.2.2】创建绘制缓存；</span></span><br><span class="line">            buildDrawingCache(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【--&gt;4.2.3】获取绘制缓存；</span></span><br><span class="line">        cache = getDrawingCache(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【7】如果是硬件绘制的话，这里会对 display list 做处理；</span></span><br><span class="line">    <span class="keyword">if</span> (drawingWithRenderNode) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;4.2.1】更新 gpu 绘制列表，保存在 RenderNode 中；</span></span><br><span class="line">        renderNode = updateDisplayListIfDirty();</span><br><span class="line">        <span class="keyword">if</span> (!renderNode.isValid()) &#123;</span><br><span class="line">            <span class="comment">// 如果在调用 getDisplayList() 的过程中将 View 从层次结构中删除，</span></span><br><span class="line">            <span class="comment">// 显示列表将被标记为无效，那么这就不会是使用 renderNode 绘制；</span></span><br><span class="line">            renderNode = <span class="literal">null</span>;</span><br><span class="line">            drawingWithRenderNode = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sy</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!drawingWithRenderNode) &#123;</span><br><span class="line">        computeScroll();</span><br><span class="line">        sx = mScrollX;</span><br><span class="line">        sy = mScrollY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【8】判断下是否使用缓存进行绘制（不是硬件绘制，可能是上面的 renderNode inValid 了，同时缓存不为 null）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">drawingWithDrawingCache</span> <span class="operator">=</span> cache != <span class="literal">null</span> &amp;&amp; !drawingWithRenderNode;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">offsetForScroll</span> <span class="operator">=</span> cache == <span class="literal">null</span> &amp;&amp; !drawingWithRenderNode;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">restoreTo</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!drawingWithRenderNode || transformToApply != <span class="literal">null</span>) &#123;</span><br><span class="line">        restoreTo = canvas.save();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offsetForScroll) &#123;</span><br><span class="line">        canvas.translate(mLeft - sx, mTop - sy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!drawingWithRenderNode) &#123;</span><br><span class="line">            canvas.translate(mLeft, mTop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (scalingRequired) &#123;</span><br><span class="line">            <span class="keyword">if</span> (drawingWithRenderNode) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Might not need this if we put everything inside the DL</span></span><br><span class="line">                restoreTo = canvas.save();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mAttachInfo cannot be null, otherwise scalingRequired == false</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">float</span> <span class="variable">scale</span> <span class="operator">=</span> <span class="number">1.0f</span> / mAttachInfo.mApplicationScale;</span><br><span class="line">            canvas.scale(scale, scale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【9】处理 alpha 的变化；</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">alpha</span> <span class="operator">=</span> drawingWithRenderNode ? <span class="number">1</span> : (getAlpha() * getTransitionAlpha());</span><br><span class="line">    <span class="keyword">if</span> (transformToApply != <span class="literal">null</span></span><br><span class="line">        || alpha &lt; <span class="number">1</span></span><br><span class="line">        || !hasIdentityMatrix()</span><br><span class="line">        || (mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (transformToApply != <span class="literal">null</span> || !childHasIdentityMatrix) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">transX</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">transY</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (offsetForScroll) &#123;</span><br><span class="line">                transX = -sx;</span><br><span class="line">                transY = -sy;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (transformToApply != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (concatMatrix) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (drawingWithRenderNode) &#123;</span><br><span class="line">                        renderNode.setAnimationMatrix(transformToApply.getMatrix());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Undo the scroll translation, apply the transformation matrix,</span></span><br><span class="line">                        <span class="comment">// then redo the scroll translate to get the correct result.</span></span><br><span class="line">                        canvas.translate(-transX, -transY);</span><br><span class="line">                        canvas.concat(transformToApply.getMatrix());</span><br><span class="line">                        canvas.translate(transX, transY);</span><br><span class="line">                    &#125;</span><br><span class="line">                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> <span class="variable">transformAlpha</span> <span class="operator">=</span> transformToApply.getAlpha();</span><br><span class="line">                <span class="keyword">if</span> (transformAlpha &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    alpha *= transformAlpha;</span><br><span class="line">                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!childHasIdentityMatrix &amp;&amp; !drawingWithRenderNode) &#123;</span><br><span class="line">                canvas.translate(-transX, -transY);</span><br><span class="line">                canvas.concat(getMatrix());</span><br><span class="line">                canvas.translate(transX, transY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deal with alpha if it is or used to be &lt;1</span></span><br><span class="line">        <span class="keyword">if</span> (alpha &lt; <span class="number">1</span> || (mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (alpha &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mPrivateFlags3 &amp;= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;</span><br><span class="line">            &#125;</span><br><span class="line">            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">            <span class="keyword">if</span> (!drawingWithDrawingCache) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">multipliedAlpha</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="number">255</span> * alpha);</span><br><span class="line">                <span class="keyword">if</span> (!onSetAlpha(multipliedAlpha)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (drawingWithRenderNode) &#123;</span><br><span class="line">                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layerType == LAYER_TYPE_NONE) &#123;</span><br><span class="line">                        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(),</span><br><span class="line">                                              multipliedAlpha);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Alpha is handled by the child directly, clobber the layer&#x27;s alpha</span></span><br><span class="line">                    mPrivateFlags |= PFLAG_ALPHA_SET;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) &#123;</span><br><span class="line">        onSetAlpha(<span class="number">255</span>);</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_ALPHA_SET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【10】对于软件绘制的情况，处理 clip</span></span><br><span class="line">    <span class="keyword">if</span> (!drawingWithRenderNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((parentFlags &amp; ViewGroup.FLAG_CLIP_CHILDREN) != <span class="number">0</span> &amp;&amp; cache == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (offsetForScroll) &#123;</span><br><span class="line">                canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!scalingRequired || cache == <span class="literal">null</span>) &#123;</span><br><span class="line">                    canvas.clipRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    canvas.clipRect(<span class="number">0</span>, <span class="number">0</span>, cache.getWidth(), cache.getHeight());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mClipBounds != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// clip bounds ignore scroll</span></span><br><span class="line">            canvas.clipRect(mClipBounds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【11】如果不使用绘制缓存的话，会进行不同的处理；</span></span><br><span class="line">    <span class="keyword">if</span> (!drawingWithDrawingCache) &#123;</span><br><span class="line">        <span class="comment">//【11.1】如果是硬件加速，这里会调用 DisplayListCanvas.drawRenderNode 方法，根据</span></span><br><span class="line">        <span class="comment">// 收集到的 renderNode 树进行绘制；</span></span><br><span class="line">        <span class="keyword">if</span> (drawingWithRenderNode) &#123;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【11.2】对于软件绘制，这里会判断下当前的 view 是否要跳过绘制；</span></span><br><span class="line">            <span class="comment">// 这里可能是硬件绘制被取消了，也可能就是软件绘制～～</span></span><br><span class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">                <span class="comment">//【--&gt;4.1.3】如果跳过绘制，那就会触发 dispatchDraw 方法；</span></span><br><span class="line">                dispatchDraw(canvas);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【--&gt;4.1】如果需要绘制，就绘制自身，如果是 ViewGroup 的话，还会触发 dispatchDraw 方法；</span></span><br><span class="line">                draw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【10.3】这里是使用绘制缓存，必须是软件绘制才行；</span></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">        <span class="keyword">if</span> (layerType == LAYER_TYPE_NONE || mLayerPaint == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// no layer paint, use temporary paint to draw bitmap</span></span><br><span class="line">            <span class="type">Paint</span> <span class="variable">cachePaint</span> <span class="operator">=</span> parent.mCachePaint;</span><br><span class="line">            <span class="keyword">if</span> (cachePaint == <span class="literal">null</span>) &#123;</span><br><span class="line">                cachePaint = <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">                cachePaint.setDither(<span class="literal">false</span>);</span><br><span class="line">                parent.mCachePaint = cachePaint;</span><br><span class="line">            &#125;</span><br><span class="line">            cachePaint.setAlpha((<span class="type">int</span>) (alpha * <span class="number">255</span>));</span><br><span class="line">            <span class="comment">//【10.4】把存储 cpu 绘制缓存的 Bitmap 绘制到 canvas 上 ( skia 渲染引擎 )</span></span><br><span class="line">            <span class="comment">// 下面也是一样的；</span></span><br><span class="line">            canvas.drawBitmap(cache, <span class="number">0.0f</span>, <span class="number">0.0f</span>, cachePaint);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// use layer paint to draw the bitmap, merging the two alphas, but also restore</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">layerPaintAlpha</span> <span class="operator">=</span> mLayerPaint.getAlpha();</span><br><span class="line">            <span class="keyword">if</span> (alpha &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                mLayerPaint.setAlpha((<span class="type">int</span>) (alpha * layerPaintAlpha));</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.drawBitmap(cache, <span class="number">0.0f</span>, <span class="number">0.0f</span>, mLayerPaint);</span><br><span class="line">            <span class="keyword">if</span> (alpha &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                mLayerPaint.setAlpha(layerPaintAlpha);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (restoreTo &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        canvas.restoreToCount(restoreTo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">null</span> &amp;&amp; !more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hardwareAcceleratedCanvas &amp;&amp; !a.getFillAfter()) &#123;</span><br><span class="line">            onSetAlpha(<span class="number">255</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        parent.finishAnimatingView(<span class="built_in">this</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (more &amp;&amp; hardwareAcceleratedCanvas) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.hasAlpha() &amp;&amp; (mPrivateFlags &amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) &#123;</span><br><span class="line">            <span class="comment">// alpha animations should cause the child to recreate its display list</span></span><br><span class="line">            invalidate(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mRecreateDisplayList = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li><p>对于软件绘制：</p><ul><li>会有一个叫绘制缓存的概念，buildDrawingCache 负责创建绘制缓存，view 会将自身绘制到缓存上，然后再绘制到 parent 的 canvas 上；</li><li>如果不使用绘制缓存的话，就会直接绘制到  parent 传进来的 canvas 上；</li></ul></li><li><p>对于硬件绘制：</p><ul><li>会有一个叫 RenderBode 和 DisplayList 的概念；</li></ul></li></ul><h3 id="4-2-1-updateDisplayListIfDirty"><a href="#4-2-1-updateDisplayListIfDirty" class="headerlink" title="4.2.1 updateDisplayListIfDirty"></a>4.2.1 updateDisplayListIfDirty</h3><p> 获取 View 的 RenderNode，同时更新显示列表 DisplayList；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> RenderNode <span class="title function_">updateDisplayListIfDirty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//【1】将自身的 rn 保存到 renderNode 临时变量中；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RenderNode</span> <span class="variable">renderNode</span> <span class="operator">=</span> mRenderNode;</span><br><span class="line">    <span class="keyword">if</span> (!canHaveDisplayList()) &#123;</span><br><span class="line">        <span class="comment">// 如果不是硬件加速，不能有 DisplayList，直接返回 renderNode 内部有属性呀；</span></span><br><span class="line">        <span class="keyword">return</span> renderNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】这里是针对硬件绘制的情况，PFLAG_DRAWING_CACHE_VALID 标志位表示是否通过缓存绘制；</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="number">0</span></span><br><span class="line">            || !renderNode.isValid()</span><br><span class="line">            || (mRecreateDisplayList)) &#123;</span><br><span class="line">        <span class="comment">//【2.1】如果没有设置了 PFLAG_DRAWING_CACHE_VALID 标志位的话，那么会进入这里：</span></span><br><span class="line">        <span class="keyword">if</span> (renderNode.isValid()  <span class="comment">// isValid：返回 RenderNode 的显示列表内容当前是否可用。</span></span><br><span class="line">                &amp;&amp; !mRecreateDisplayList) &#123; <span class="comment">// 无需重新创建 DisplayList；</span></span><br><span class="line">            <span class="comment">//【2.2】这里设置了标志位 PFLAG_DRAWING_CACHE_VALID</span></span><br><span class="line">            mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">            <span class="comment">//【--&gt;3.3】硬件绘制，无需重新创建 DisplayList，只需要告诉 child 恢复/重新创建自身即可；</span></span><br><span class="line">            dispatchGetDisplayList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> renderNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】表示要重新创建显示列表；</span></span><br><span class="line">        <span class="comment">// 如此标记以确保我们将子显示列表中的内容复制到 drawChild() 中？？</span></span><br><span class="line">        mRecreateDisplayList = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> mRight - mLeft;</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> mBottom - mTop;</span><br><span class="line">        <span class="type">int</span> <span class="variable">layerType</span> <span class="operator">=</span> getLayerType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4.1】这是硬件绘制的情况，开始记录渲染节点的显示列表，返回一个 DisplayListCanvas，用于记录绘制操作；</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">DisplayListCanvas</span> <span class="variable">canvas</span> <span class="operator">=</span> renderNode.start(width, height);</span><br><span class="line">        canvas.setHighContrastText(mAttachInfo.mHighContrastText);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【5】这里针对 layer 的情况做了区分；</span></span><br><span class="line">            <span class="keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE) &#123;</span><br><span class="line">                <span class="comment">//【--&gt;4.2.2】如果是 SOFTWARE 层的话，那么会构建绘制缓存，通过缓存绘制；</span></span><br><span class="line">                buildDrawingCache(<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">//【--&gt;】获取缓存 cache，并绘制；</span></span><br><span class="line">                <span class="type">Bitmap</span> <span class="variable">cache</span> <span class="operator">=</span> getDrawingCache(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">                    canvas.drawBitmap(cache, <span class="number">0</span>, <span class="number">0</span>, mLayerPaint);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【5.1】如果是 HARDWARE 层的话，那就不使用缓存了；</span></span><br><span class="line">                computeScroll();</span><br><span class="line"></span><br><span class="line">                canvas.translate(-mScrollX, -mScrollY);</span><br><span class="line">                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Fast path for layouts with no backgrounds</span></span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">                    <span class="comment">//【--&gt;4.1.3】如果跳过自身的话，那就分发出去；</span></span><br><span class="line">                    dispatchDraw(canvas);</span><br><span class="line">                    <span class="keyword">if</span> (mOverlay != <span class="literal">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                        mOverlay.getOverlayView().draw(canvas);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//【--&gt;4.1】绘制自身；</span></span><br><span class="line">                    draw(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//【6】结束记录；</span></span><br><span class="line">            renderNode.end(canvas);</span><br><span class="line">            setDisplayListProperties(renderNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> renderNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个标志位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRecreateDisplayList = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>表示 View 在当前图形绘制之前被标记为 INVALIDATED 或者起 DisplayList 无效。</p><p>如果为 true，则 View 必须重新计算其 DisplayList，仅在硬件加速时使用。</p><p>系统会清除 INVALIDATED 标志，同时将是否 INVALIDATED 保存到该变量中，硬件加速后续会用到</p><p>（ 比如在 getDisplayList() 时和在 drawChild() 中，当我们决定将视图的子级显示列表绘制到我们自己的状态中）。</p><h3 id="4-2-2-buildDrawingCache"><a href="#4-2-2-buildDrawingCache" class="headerlink" title="4.2.2 buildDrawingCache"></a>4.2.2 buildDrawingCache</h3><p>构建绘制缓存，参数 autoScale 表示是否自动缩放；</p><p>如果未启用自动缩放，则此方法将创建与该 view 相同大小的 bitmap 缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildDrawingCache</span><span class="params">(<span class="type">boolean</span> autoScale)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】如果没有设置 PFLAG_DRAWING_CACHE_VALID 有效性标志位，或者要强制进入的话；</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="number">0</span> || (autoScale ?</span><br><span class="line">            mDrawingCache == <span class="literal">null</span> : mUnscaledDrawingCache == <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW,</span><br><span class="line">                    <span class="string">&quot;buildDrawingCache/SW Layer for &quot;</span> + getClass().getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【--&gt;4.2.2.1】创建绘制缓存；</span></span><br><span class="line">            buildDrawingCacheImpl(autoScale);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果图形缓存无效，则强制构建图形缓存，如果只调用  buildDrawingCache() 而没有调用 setDrawingCacheEnabled(true)<br>则应在之后调用  destroyDrawingCache()；</p><p>启用硬件加速后，不应使用此方法。如果不需要图形缓存，则调用此方法将增加内存使用量，并使 view 一次性通过软件绘制出来，从而对性能产生负面影响。</p><h4 id="4-2-2-1-buildDrawingCacheImpl"><a href="#4-2-2-1-buildDrawingCacheImpl" class="headerlink" title="4.2.2.1 buildDrawingCacheImpl"></a>4.2.2.1 buildDrawingCacheImpl</h4><p>构建绘制缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildDrawingCacheImpl</span><span class="params">(<span class="type">boolean</span> autoScale)</span> &#123;</span><br><span class="line">      mCachingFailed = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//【1】计算一下绘制的宽/高；</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> mRight - mLeft;</span><br><span class="line">      <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> mBottom - mTop;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="type">AttachInfo</span> <span class="variable">attachInfo</span> <span class="operator">=</span> mAttachInfo;</span><br><span class="line">      <span class="comment">//【2】是否需要缩放，如果需要的话，会根据 view root 设置的缩放比，对绘制宽高缩放；</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">scalingRequired</span> <span class="operator">=</span> attachInfo != <span class="literal">null</span> &amp;&amp; attachInfo.mScalingRequired;</span><br><span class="line">      <span class="keyword">if</span> (autoScale &amp;&amp; scalingRequired) &#123;</span><br><span class="line">          width = (<span class="type">int</span>) ((width * attachInfo.mApplicationScale) + <span class="number">0.5f</span>);</span><br><span class="line">          height = (<span class="type">int</span>) ((height * attachInfo.mApplicationScale) + <span class="number">0.5f</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">drawingCacheBackgroundColor</span> <span class="operator">=</span> mDrawingCacheBackgroundColor;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">opaque</span> <span class="operator">=</span> drawingCacheBackgroundColor != <span class="number">0</span> || isOpaque();</span><br><span class="line">      <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">use32BitCache</span> <span class="operator">=</span> attachInfo != <span class="literal">null</span> &amp;&amp; attachInfo.mUse32BitDrawingCache;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">projectedBitmapSize</span> <span class="operator">=</span> width * height * (opaque &amp;&amp; !use32BitCache ? <span class="number">2</span> : <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">final</span> <span class="type">long</span> <span class="variable">drawingCacheSize</span> <span class="operator">=</span></span><br><span class="line">              ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize();</span><br><span class="line">      <span class="comment">//【3】这里比较了下要绘制的图案的内存大小是不是比允许缓存的最大值大，如果是的话，不允许缓存；</span></span><br><span class="line">      <span class="keyword">if</span> (width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span> || projectedBitmapSize &gt; drawingCacheSize) &#123;</span><br><span class="line">          <span class="keyword">if</span> (width &gt; <span class="number">0</span> &amp;&amp; height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              Log.w(VIEW_LOG_TAG, getClass().getSimpleName() + <span class="string">&quot; not displayed because it is&quot;</span></span><br><span class="line">                      + <span class="string">&quot; too large to fit into a software layer (or drawing cache), needs &quot;</span></span><br><span class="line">                      + projectedBitmapSize + <span class="string">&quot; bytes, only &quot;</span></span><br><span class="line">                      + drawingCacheSize + <span class="string">&quot; available&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          destroyDrawingCache();</span><br><span class="line">          mCachingFailed = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">clear</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">//【4】选择哪一种缓存；</span></span><br><span class="line">      <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> autoScale ? mDrawingCache : mUnscaledDrawingCache;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//【5】选择缓存对应的质量；</span></span><br><span class="line">      <span class="keyword">if</span> (bitmap == <span class="literal">null</span> || bitmap.getWidth() != width || bitmap.getHeight() != height) &#123;</span><br><span class="line">          Bitmap.Config quality;</span><br><span class="line">          <span class="keyword">if</span> (!opaque) &#123;</span><br><span class="line">              <span class="comment">// Never pick ARGB_4444 because it looks awful</span></span><br><span class="line">              <span class="comment">// Keep the DRAWING_CACHE_QUALITY_LOW flag just in case</span></span><br><span class="line">              <span class="keyword">switch</span> (mViewFlags &amp; DRAWING_CACHE_QUALITY_MASK) &#123;</span><br><span class="line">                  <span class="keyword">case</span> DRAWING_CACHE_QUALITY_AUTO:</span><br><span class="line">                  <span class="keyword">case</span> DRAWING_CACHE_QUALITY_LOW:</span><br><span class="line">                  <span class="keyword">case</span> DRAWING_CACHE_QUALITY_HIGH:</span><br><span class="line">                  <span class="keyword">default</span>:</span><br><span class="line">                      quality = Bitmap.Config.ARGB_8888;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Optimization for translucent windows</span></span><br><span class="line">              <span class="comment">// If the window is translucent, use a 32 bits bitmap to benefit from memcpy()</span></span><br><span class="line">              quality = use32BitCache ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (bitmap != <span class="literal">null</span>) bitmap.recycle();</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//【6】创建一个 Bitmap 缓存保存到 mDrawingCache/mUnscaledDrawingCache 中；</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(),</span><br><span class="line">                      width, height, quality);</span><br><span class="line">              bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);</span><br><span class="line">              <span class="keyword">if</span> (autoScale) &#123;</span><br><span class="line">                  mDrawingCache = bitmap;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  mUnscaledDrawingCache = bitmap;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (opaque &amp;&amp; use32BitCache) bitmap.setHasAlpha(<span class="literal">false</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line"><span class="comment">// 如果没有足够的内存的话，那就不使用缓存了；</span></span><br><span class="line">              <span class="keyword">if</span> (autoScale) &#123;</span><br><span class="line">                  mDrawingCache = <span class="literal">null</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  mUnscaledDrawingCache = <span class="literal">null</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              mCachingFailed = <span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          clear = drawingCacheBackgroundColor != <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Canvas canvas;</span><br><span class="line">      <span class="comment">//【7】这里的 attachInfo 来自于 ViewRootImpl。下面会对 canvas 做一下调整；</span></span><br><span class="line">      <span class="keyword">if</span> (attachInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">          canvas = attachInfo.mCanvas;</span><br><span class="line">          <span class="keyword">if</span> (canvas == <span class="literal">null</span>) &#123;</span><br><span class="line">              canvas = <span class="keyword">new</span> <span class="title class_">Canvas</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//【7.1】canvas 的 Bitmap 设置为我们创建的缓存 Bitmap；</span></span><br><span class="line">          canvas.setBitmap(bitmap);</span><br><span class="line">          <span class="comment">// Temporarily clobber the cached Canvas in case one of our children</span></span><br><span class="line">          <span class="comment">// is also using a drawing cache. Without this, the children would</span></span><br><span class="line">          <span class="comment">// steal the canvas by attaching their own bitmap to it and bad, bad</span></span><br><span class="line">          <span class="comment">// thing would happen (invisible views, corrupted drawings, etc.)</span></span><br><span class="line">          attachInfo.mCanvas = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 这是极端的情况，view 没有 attach 上；</span></span><br><span class="line">          canvas = <span class="keyword">new</span> <span class="title class_">Canvas</span>(bitmap);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (clear) &#123;</span><br><span class="line">          bitmap.eraseColor(drawingCacheBackgroundColor);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      computeScroll();</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">restoreCount</span> <span class="operator">=</span> canvas.save();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (autoScale &amp;&amp; scalingRequired) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="type">float</span> <span class="variable">scale</span> <span class="operator">=</span> attachInfo.mApplicationScale;</span><br><span class="line">          canvas.scale(scale, scale);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      canvas.translate(-mScrollX, -mScrollY);</span><br><span class="line"></span><br><span class="line">      mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line">      <span class="keyword">if</span> (mAttachInfo == <span class="literal">null</span> || !mAttachInfo.mHardwareAccelerated ||</span><br><span class="line">              mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class="line">          mPrivateFlags |= PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//【8】注意：这里又执行了一次绘制，但这是将自身绘制到这个缓存 bitmap 上；</span></span><br><span class="line">      <span class="comment">// 同时将缓存 canvas 传递给了 child view（如果有的话）</span></span><br><span class="line">      <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">          mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">          <span class="comment">//【--&gt;4.1.3】分发绘制；</span></span><br><span class="line">          dispatchDraw(canvas);</span><br><span class="line">          <span class="keyword">if</span> (mOverlay != <span class="literal">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">              mOverlay.getOverlayView().draw(canvas);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//【--&gt;4.1】绘制自身以及 child view</span></span><br><span class="line">          draw(canvas);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      canvas.restoreToCount(restoreCount);</span><br><span class="line">      canvas.setBitmap(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (attachInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">//【9】将缓存画布保存到 attachInfo，下次再用；</span></span><br><span class="line">          attachInfo.mCanvas = canvas;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-getDrawingCache"><a href="#4-2-3-getDrawingCache" class="headerlink" title="4.2.3 getDrawingCache"></a>4.2.3 getDrawingCache</h3><p>返回一个绘制缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Bitmap <span class="title function_">getDrawingCache</span><span class="params">(<span class="type">boolean</span> autoScale)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】该 view 不创建绘制缓存，返回 null；</span></span><br><span class="line">    <span class="keyword">if</span> ((mViewFlags &amp; WILL_NOT_CACHE_DRAWING) == WILL_NOT_CACHE_DRAWING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((mViewFlags &amp; DRAWING_CACHE_ENABLED) == DRAWING_CACHE_ENABLED) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;4.2.2】创建一个绘制缓存；</span></span><br><span class="line">        buildDrawingCache(autoScale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】根据是否自动缩放，返回对应的 cache；</span></span><br><span class="line">    <span class="keyword">return</span> autoScale ? mDrawingCache : mUnscaledDrawingCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-dispatchGetDisplayList-核心"><a href="#4-3-dispatchGetDisplayList-核心" class="headerlink" title="4.3 dispatchGetDisplayList - 核心"></a>4.3 dispatchGetDisplayList - 核心</h2><p>ViewGroup 使用该方法来还原或重新创建 child view 的显示列表。</p><p>常规的 draw/dispatchDraw 过程中，当 ViewGroup 不需要重新创建自己的显示列表时，getDisplayList() 会调用此方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">dispatchGetDisplayList</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到。真正的实现在 ViewGroup 中。</p><h1 id="5-ThreadedRenderer-硬件绘制简单记录"><a href="#5-ThreadedRenderer-硬件绘制简单记录" class="headerlink" title="5 ThreadedRenderer - 硬件绘制简单记录"></a>5 ThreadedRenderer - 硬件绘制简单记录</h1><p>硬件绘制的操作要比软件绘制复杂的多，这里只简单的分析下：</p><h2 id="5-1-draw-核心"><a href="#5-1-draw-核心" class="headerlink" title="5.1 draw - 核心"></a>5.1 draw - 核心</h2><p>我们来看看硬件绘制的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(View view, AttachInfo attachInfo, HardwareDrawCallbacks callbacks)</span> &#123;</span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Choreographer</span> <span class="variable">choreographer</span> <span class="operator">=</span> attachInfo.mViewRootImpl.mChoreographer;</span><br><span class="line">    choreographer.mFrameInfo.markDrawStart();</span><br><span class="line">    <span class="comment">//【--&gt;5.2】更新 DecorView 的 DisplayList 显示列表；</span></span><br><span class="line">    <span class="comment">// 该方法会遍历整个树形视图结构，从 DecorView 开始，更新所有视图的 DisplayList。</span></span><br><span class="line">    updateRootDisplayList(view, callbacks);</span><br><span class="line"></span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register animating rendernodes which started animating prior to renderer</span></span><br><span class="line">    <span class="comment">// creation, which is typical for animators started prior to first draw</span></span><br><span class="line">    <span class="keyword">if</span> (attachInfo.mPendingAnimatingRenderNodes != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> attachInfo.mPendingAnimatingRenderNodes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            registerAnimatingRenderNode(</span><br><span class="line">                    attachInfo.mPendingAnimatingRenderNodes.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        attachInfo.mPendingAnimatingRenderNodes.clear();</span><br><span class="line">        <span class="comment">// We don&#x27;t need this anymore as subsequent calls to</span></span><br><span class="line">        <span class="comment">// ViewRootImpl#attachRenderNodeAnimator will go directly to us.</span></span><br><span class="line">        attachInfo.mPendingAnimatingRenderNodes = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span>[] frameInfo = choreographer.mFrameInfo.mFrameInfo;</span><br><span class="line">    <span class="comment">//【2】同步帧数据，最终目的是将 OpenGL 指令写入 gpu；</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">syncResult</span> <span class="operator">=</span> nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);</span><br><span class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_LOST_SURFACE_REWARD_IF_FOUND) != <span class="number">0</span>) &#123;</span><br><span class="line">        setEnabled(<span class="literal">false</span>);</span><br><span class="line">        attachInfo.mViewRootImpl.mSurface.release();</span><br><span class="line">        <span class="comment">// Invalidate since we failed to draw. This should fetch a Surface</span></span><br><span class="line">        <span class="comment">// if it is still needed or do nothing if we are no longer drawing</span></span><br><span class="line">        attachInfo.mViewRootImpl.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_INVALIDATE_REQUIRED) != <span class="number">0</span>) &#123;</span><br><span class="line">        attachInfo.mViewRootImpl.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>硬件绘制的 canvas 它是一个 DisplayListCanvas 对象，它的每一个 drawxxx 的方法并不是真正的绘制，而是在记录绘制的操作；</p><p>和软件绘制绘制类似，由于 View 体系是一个树形结构，所以硬件绘制也要遍历这个 tree，但是他的遍历是记录每个 view 的绘制操作，而不是直接绘制；</p><p>而触发这个遍历的方法就是：updateRootDisplayList，updateViewTreeDisplayList 还有 updateDisplayListIfDirty 方法；</p><h2 id="5-2-updateRootDisplayList-核心"><a href="#5-2-updateRootDisplayList-核心" class="headerlink" title="5.2 updateRootDisplayList - 核心"></a>5.2 updateRootDisplayList - 核心</h2><p>继续看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRootDisplayList</span><span class="params">(View view, HardwareDrawCallbacks callbacks)</span> &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Record View#draw()&quot;</span>);</span><br><span class="line">    <span class="comment">//【--&gt;5.3】遍历整个树形视图结构，从 DecorView 开始，更新所有视图的 DisplayList。</span></span><br><span class="line">    updateViewTreeDisplayList(view);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.isValid()) &#123;</span><br><span class="line">        <span class="comment">//【1】开始记录渲染节点的显示列表，返回一个 DisplayListCanvas，用于记录绘制操作；</span></span><br><span class="line">        <span class="type">DisplayListCanvas</span> <span class="variable">canvas</span> <span class="operator">=</span> mRootNode.start(mSurfaceWidth, mSurfaceHeight);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">saveCount</span> <span class="operator">=</span> canvas.save();</span><br><span class="line">            canvas.translate(mInsetLeft, mInsetTop);</span><br><span class="line">            callbacks.onHardwarePreDraw(canvas);</span><br><span class="line">            <span class="comment">//【2】插入栅栏，隔离 canvas 操作</span></span><br><span class="line">            canvas.insertReorderBarrier();</span><br><span class="line">            <span class="comment">//【3】绘制顶层视图 RenderNode；</span></span><br><span class="line">            canvas.drawRenderNode(view.updateDisplayListIfDirty());</span><br><span class="line">            canvas.insertInorderBarrier();</span><br><span class="line"></span><br><span class="line">            callbacks.onHardwarePostDraw(canvas);</span><br><span class="line">            canvas.restoreToCount(saveCount);</span><br><span class="line">            mRootNodeNeedsUpdate = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//【4】停止记录；</span></span><br><span class="line">            mRootNode.end(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看：</p><h2 id="5-3-updateViewTreeDisplayList-核心"><a href="#5-3-updateViewTreeDisplayList-核心" class="headerlink" title="5.3 updateViewTreeDisplayList - 核心"></a>5.3 updateViewTreeDisplayList - 核心</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateViewTreeDisplayList</span><span class="params">(View view)</span> &#123;</span><br><span class="line">    view.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line">    view.mRecreateDisplayList = (view.mPrivateFlags &amp; </span><br><span class="line">                View.PFLAG_INVALIDATED)== View.PFLAG_INVALIDATED;</span><br><span class="line">    view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED;</span><br><span class="line">    <span class="comment">//【--&gt;4.2.1】更新 DecorView 的 DisplayList；</span></span><br><span class="line">    view.updateDisplayListIfDirty();</span><br><span class="line">    view.mRecreateDisplayList = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>我们用一张图来总结下整个的软件绘制的流程；</p><p>最近加班多，要休息下～～～（略）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇文章基于 Android N - 7.1.1 主要分析下 draw 方法的执行流程；&lt;/p&gt;
&lt;h1 id=&quot;1-回顾&quot;&gt;&lt;a href=&quot;#1-回顾&quot; class=&quot;headerlink&quot; title=&quot;1 回顾&quot;&gt;&lt;/a&gt;1 回顾&lt;/h1&gt;&lt;p&gt;在上面的 perfo</summary>
      
    
    
    
    <category term="View 视图" scheme="https://lishuaiqi.top/categories/View-%E8%A7%86%E5%9B%BE/"/>
    
    <category term="View 的加载和绘制" scheme="https://lishuaiqi.top/categories/View-%E8%A7%86%E5%9B%BE/View-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%BB%98%E5%88%B6/"/>
    
    
    <category term="ViewDraw" scheme="https://lishuaiqi.top/tags/ViewDraw/"/>
    
  </entry>
  
  <entry>
    <title>ViewDraw 第五篇 layout 流程分析</title>
    <link href="https://lishuaiqi.top/2020/04/21/ViewDraw-5-layout/"/>
    <id>https://lishuaiqi.top/2020/04/21/ViewDraw-5-layout/</id>
    <published>2020-04-21T12:46:25.000Z</published>
    <updated>2025-10-03T07:20:52.984Z</updated>
    
    <content type="html"><![CDATA[<p>基于 Android N 分析下 View 的 layout，N 虽然看起来略有些旧，但是框架的核心思想才是最重要的，新的一天开始了。</p><h1 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h1><p>我们来回顾下，performLayout 请求布局的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="type">int</span> desiredWindowWidth,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> desiredWindowHeight)</span> &#123;</span><br><span class="line">    mLayoutRequested = <span class="literal">false</span>;</span><br><span class="line">    mScrollMayChange = <span class="literal">true</span>;</span><br><span class="line">    mInLayout = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">host</span> <span class="operator">=</span> mView;</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123;</span><br><span class="line">        Log.v(mTag, <span class="string">&quot;Laying out &quot;</span> + host + <span class="string">&quot; to (&quot;</span> +</span><br><span class="line">                host.getMeasuredWidth() + <span class="string">&quot;, &quot;</span> + host.getMeasuredHeight() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;layout&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1-core】调用 DecorView（ViewGroup）的 layout；</span></span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">        mInLayout = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numViewsRequestingLayout</span> <span class="operator">=</span> mLayoutRequesters.size();</span><br><span class="line">        <span class="comment">//【2】如果 mLayoutRequesters 大小不为 0 ；说明我们在布局的过程中调用了 requestLayout 方法；</span></span><br><span class="line">        <span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 在布局期间调用了 requestLayout()。</span></span><br><span class="line">            <span class="comment">// 如果在请求的视图上未设置布局请求标志，则没有问题。</span></span><br><span class="line">            <span class="comment">// 如果某些请求仍在等待处理中，那么我们需要清除这些标志并进行完整的请求/度量/布局传递以处理这种情况。</span></span><br><span class="line">            <span class="comment">//【--&gt;2.5.1】获取有效的布局请求；</span></span><br><span class="line">            ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                    <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (validLayoutRequesters != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【3】设置此标志，表示即将进入第二次布局中，这样的话，如果再发起 requestlayout 的话；</span></span><br><span class="line">                <span class="comment">// 这些请求会延迟到下一帧</span></span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【4】处理有效的布局请求；</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">numValidRequests</span> <span class="operator">=</span> validLayoutRequesters.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> validLayoutRequesters.get(i);</span><br><span class="line">                    Log.w(<span class="string">&quot;View&quot;</span>, <span class="string">&quot;requestLayout() improperly called by &quot;</span> + view +</span><br><span class="line">                            <span class="string">&quot; during layout: running second layout pass&quot;</span>);</span><br><span class="line">                    <span class="comment">//【4.1-core】调用每一个 View 的 layout 方法；</span></span><br><span class="line">                    view.requestLayout();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【--&gt;2.2】再次预测量；</span></span><br><span class="line">                measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                        desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                mInLayout = <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【5-core】调用 DecorView（GroupView）的 layout，再次布局；</span></span><br><span class="line">                host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【--&gt;2.5.1】再次获取有效的布局请求，注意这里第二个参数传入的是 true</span></span><br><span class="line">                <span class="comment">// 这次不会清除布局标志，因为在第二次布局中的请求会延迟到下一帧;</span></span><br><span class="line">                validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (validLayoutRequesters != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;</span><br><span class="line">                    <span class="comment">//【6】将第二次的请求发布到下一帧，这个 runnable 会在 performTraversals 中执行；</span></span><br><span class="line">                    getRunQueue().post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">numValidRequests</span> <span class="operator">=</span> finalRequesters.size();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> finalRequesters.get(i);</span><br><span class="line">                                Log.w(<span class="string">&quot;View&quot;</span>, <span class="string">&quot;requestLayout() improperly called by &quot;</span> + view +</span><br><span class="line">                                        <span class="string">&quot; during second layout pass: posting in next frame&quot;</span>);</span><br><span class="line">                                <span class="comment">//【6.1】触发 requestLayout 方法！</span></span><br><span class="line">                                view.requestLayout();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    mInLayout = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在测量后布局阶段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【--&gt;2.1】调用 DecorView（ViewGroup）的 layout；</span></span><br><span class="line">host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br></pre></td></tr></table></figure><p>是通过 view 的 layout 方法出发布局的；</p><h1 id="2-ViewGroup"><a href="#2-ViewGroup" class="headerlink" title="2 ViewGroup"></a>2 ViewGroup</h1><h2 id="2-1-layout-核心"><a href="#2-1-layout-核心" class="headerlink" title="2.1 layout - 核心"></a>2.1 layout - 核心</h2><p>DecorView 是一个 ViewGroup，所以会先执行 ViewGroup 的 layout：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">layout</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="literal">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTransition != <span class="literal">null</span>) &#123;</span><br><span class="line">            mTransition.layoutChange(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【--&gt;2.1】执行 view 的 layout 方法：</span></span><br><span class="line">        <span class="built_in">super</span>.layout(l, t, r, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// record the fact that we noop&#x27;d it; request layout when transition finishes</span></span><br><span class="line">        mLayoutCalledWhileSuppressed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewGroup -&gt; View</p><h1 id="3-View"><a href="#3-View" class="headerlink" title="3 View"></a>3 View</h1><h2 id="3-1-layout-核心"><a href="#3-1-layout-核心" class="headerlink" title="3.1 layout - 核心"></a>3.1 layout - 核心</h2><p>执行布局，参数是左上角，右下角的测量坐标，是相对于 parent 的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layout</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】如果设置了这个的 flags 的话，那么在 measure 阶段实际上是没有执行，而是放到了 layout 阶段</span></span><br><span class="line">    <span class="comment">// 这个 flags 是在 measure 时期判断是否；使用缓存的时候调用的；</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//【1.1】执行测量操作，这里就不再分析了；</span></span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldL</span> <span class="operator">=</span> mLeft;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldT</span> <span class="operator">=</span> mTop;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldB</span> <span class="operator">=</span> mBottom;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldR</span> <span class="operator">=</span> mRight;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> isLayoutModeOptical(mParent) ? <span class="comment">// 这里是针对于 Optical bounds 的处理，先不关注；</span></span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果设置了 PFLAG_LAYOUT_REQUIRED 标志位的话，那么就要执行布局了。</span></span><br><span class="line">    <span class="comment">// 这个 flags 依然是在 measure 阶段设置的；</span></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;4.1--&gt;5.1】执行布局，这里 DecorView，FlameLayout 均复写了这个方法；</span></span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldDrawRoundScrollbar()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mRoundScrollbarRenderer == <span class="literal">null</span>) &#123;</span><br><span class="line">                mRoundScrollbarRenderer = <span class="keyword">new</span> <span class="title class_">RoundScrollbarRenderer</span>(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRoundScrollbarRenderer = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="literal">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            <span class="type">int</span> <span class="variable">numListeners</span> <span class="operator">=</span> listenersCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                <span class="comment">//【2.2】如果有注册 LayoutChangeListener 的话，这里会回调通知；</span></span><br><span class="line">                listenersCopy.get(i).onLayoutChange(<span class="built_in">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这里的核心的方法就是执行了 onLayout 方法：</p><h2 id="3-2-onLayout-核心"><a href="#3-2-onLayout-核心" class="headerlink" title="3.2 onLayout - 核心"></a>3.2 onLayout - 核心</h2><p>可以看到 view 的 onLayout  方法是一个空的实现!!</p><ul><li>当 View 需要为每个 child view 分配大小和位置时，会通过 layout 方法调用。</li><li>有 child 的 ViewGroup 要重写该方法，并在每个子级上调用布局。</li></ul><p>参数分析：</p><ul><li>boolean changed：表示 VIew 的大小或位置是否发生了变化；</li><li>int left：相对于父级的左侧位置</li><li>int top：相对于父级的顶部位置</li><li>int right：相对于父级的右侧位置</li><li>int bottom：相对于父级的底部位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不多说；</p><h2 id="3-3-getLayoutDirection"><a href="#3-3-getLayoutDirection" class="headerlink" title="3.3 getLayoutDirection"></a>3.3 getLayoutDirection</h2><p>用于获取水平的布局方向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewDebug</span>.ExportedProperty(category = <span class="string">&quot;layout&quot;</span>, mapping = &#123;</span><br><span class="line">    <span class="meta">@ViewDebug</span>.IntToString(from = LAYOUT_DIRECTION_LTR, to = <span class="string">&quot;RESOLVED_DIRECTION_LTR&quot;</span>),</span><br><span class="line">    <span class="meta">@ViewDebug</span>.IntToString(from = LAYOUT_DIRECTION_RTL, to = <span class="string">&quot;RESOLVED_DIRECTION_RTL&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@ResolvedLayoutDir</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLayoutDirection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">targetSdkVersion</span> <span class="operator">=</span> getContext().getApplicationInfo().targetSdkVersion;</span><br><span class="line">    <span class="comment">//【1】当目标 sdk 小于 JELLY_BEAN_MR1，默认返回的是 LTR；</span></span><br><span class="line">    <span class="keyword">if</span> (targetSdkVersion &lt; JELLY_BEAN_MR1) &#123;</span><br><span class="line">        mPrivateFlags2 |= PFLAG2_LAYOUT_DIRECTION_RESOLVED;</span><br><span class="line">        <span class="keyword">return</span> LAYOUT_DIRECTION_RESOLVED_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】否则，根据属性色设置返回；</span></span><br><span class="line">    <span class="keyword">return</span> ((mPrivateFlags2 &amp; PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) ==</span><br><span class="line">            PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL) ? LAYOUT_DIRECTION_RTL : LAYOUT_DIRECTION_LTR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值是通过 setLayoutDirection 方法或者 android:layoutDirection 设置的纸；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 水平方向从左到右；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LAYOUT_DIRECTION_LTR</span> <span class="operator">=</span> LayoutDirection.LTR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 水平方向从右到左（相反）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LAYOUT_DIRECTION_RTL</span> <span class="operator">=</span> LayoutDirection.RTL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认方向：LTR</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LAYOUT_DIRECTION_RESOLVED_DEFAULT</span> <span class="operator">=</span> LAYOUT_DIRECTION_LTR;</span><br></pre></td></tr></table></figure><h1 id="4-DecorView"><a href="#4-DecorView" class="headerlink" title="4 DecorView"></a>4 DecorView</h1><h2 id="4-1-onLayout-核心"><a href="#4-1-onLayout-核心" class="headerlink" title="4.1 onLayout - 核心"></a>4.1 onLayout - 核心</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;5.1】进入 FrameLayout 中，进行布局；</span></span><br><span class="line">    <span class="built_in">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">    <span class="comment">//【1】处理下 mOutsets 的数据；</span></span><br><span class="line">    getOutsets(mOutsets);</span><br><span class="line">    <span class="keyword">if</span> (mOutsets.left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        offsetLeftAndRight(-mOutsets.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mOutsets.top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        offsetTopAndBottom(-mOutsets.top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mApplyFloatingVerticalInsets) &#123;</span><br><span class="line">        offsetTopAndBottom(mFloatingInsets.top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mApplyFloatingHorizontalInsets) &#123;</span><br><span class="line">        offsetLeftAndRight(mFloatingInsets.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the application changed its SystemUI metrics, we might also have to adapt</span></span><br><span class="line">    <span class="comment">// our shadow elevation.</span></span><br><span class="line">    updateElevation();</span><br><span class="line">    mAllowUpdateElevation = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changed &amp;&amp; mResizeMode == RESIZE_MODE_DOCKED_DIVIDER) &#123;</span><br><span class="line">        getViewRootImpl().requestInvalidateRootRenderNode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看～</p><h1 id="5-FrameLayout"><a href="#5-FrameLayout" class="headerlink" title="5 FrameLayout"></a>5 FrameLayout</h1><h2 id="5-1-onLayout-核心"><a href="#5-1-onLayout-核心" class="headerlink" title="5.1 onLayout - 核心"></a>5.1 onLayout - 核心</h2><p>我们看到 child layout 实际上是在 FrameLayout 中发起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;5.2】进行 child layout 布局；</span></span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="literal">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-layoutChildren-核心"><a href="#5-2-layoutChildren-核心" class="headerlink" title="5.2 layoutChildren - 核心"></a>5.2 layoutChildren - 核心</h2><p>对 child 进行布局：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">layoutChildren</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom, <span class="type">boolean</span> forceLeftGravity)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】获取到所有的孩子；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getChildCount();</span><br><span class="line">    <span class="comment">//【2】child 的坐标是基于 parent 的，所以可以看到这里计算了基于 parent 的坐标；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentLeft</span> <span class="operator">=</span> getPaddingLeftWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentRight</span> <span class="operator">=</span> right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentTop</span> <span class="operator">=</span> getPaddingTopWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentBottom</span> <span class="operator">=</span> bottom - top - getPaddingBottomWithForeground();</span><br><span class="line">    <span class="comment">//【3】遍历每一个 child view；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="comment">//【4】获取到 child 的布局参数；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="comment">//【5】获取到 child 的测量宽/高，基于此决定 right/bottom；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> childLeft;</span><br><span class="line">            <span class="type">int</span> childTop;</span><br><span class="line">   </span><br><span class="line">            <span class="comment">//【--&gt;2.3】根据布局参数 LayoutParams 的 gravity 属性，就是 android:layout_gravity</span></span><br><span class="line">            <span class="comment">// 如果没有指定的话，那么默认是 DEFAULT_CHILD_GRAVITY，也就是左上角开始；</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">gravity</span> <span class="operator">=</span> lp.gravity;</span><br><span class="line">            <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【--&gt;3.3】返回 view 的布局方向：LTR 或者 RTL</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">layoutDirection</span> <span class="operator">=</span> getLayoutDirection();</span><br><span class="line">            <span class="comment">//【--&gt;6.1】将相对对其转为绝对对齐；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">absoluteGravity</span> <span class="operator">=</span> Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            <span class="comment">//【6】获取 TOP BOTTOM 的设置情况</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">verticalGravity</span> <span class="operator">=</span> gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【7】获取 LEFT RIGHT 的设置情况，来计算 childLeft 值； </span></span><br><span class="line">            <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    <span class="comment">//【7.1】如果设置了 CENTER_HORIZONTAL，那么显然是水平居中了</span></span><br><span class="line">                    childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                    <span class="comment">//【7.2】如果是 RIGHT，那就要靠右布局了；</span></span><br><span class="line">                    <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">//【7.3】如果是 LEFT 或者其他，那就要靠左布局了；</span></span><br><span class="line">                    childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【8】获取 TOP BOTTOM 的设置情况，来计算 childTop 值； </span></span><br><span class="line">            <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                    <span class="comment">//【7.1】如果设置了 TOP，那么显然是靠上布局了；</span></span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                    <span class="comment">//【7.2】如果设置了 CENTER_VERTICAL，那么显然是垂直居中布局了；</span></span><br><span class="line">                    childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                    <span class="comment">//【7.3】如果设置了 BOTTOM，那么显然是垂直居中布局了；</span></span><br><span class="line">                    childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【--&gt;3.1/2.1】这有会执行 child view 的 layout 执行布局，注意 child 可能 view 也可能是 view group</span></span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DEFAULT_CHILD_GRAVITY 的取值如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CHILD_GRAVITY</span> <span class="operator">=</span> Gravity.TOP | Gravity.START;</span><br></pre></td></tr></table></figure><p>对于 Gravity 的 TOP BOTTOM LEFT RIGHT 取值如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Push object to the top of its container, not changing its size. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TOP</span> <span class="operator">=</span> (AXIS_PULL_BEFORE|AXIS_SPECIFIED)&lt;&lt;AXIS_Y_SHIFT;</span><br><span class="line"><span class="comment">/** Push object to the bottom of its container, not changing its size. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BOTTOM</span> <span class="operator">=</span> (AXIS_PULL_AFTER|AXIS_SPECIFIED)&lt;&lt;AXIS_Y_SHIFT;</span><br><span class="line"><span class="comment">/** Push object to the left of its container, not changing its size. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEFT</span> <span class="operator">=</span> (AXIS_PULL_BEFORE|AXIS_SPECIFIED)&lt;&lt;AXIS_X_SHIFT;</span><br><span class="line"><span class="comment">/** Push object to the right of its container, not changing its size. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RIGHT</span> <span class="operator">=</span> (AXIS_PULL_AFTER|AXIS_SPECIFIED)&lt;&lt;AXIS_X_SHIFT;</span><br></pre></td></tr></table></figure><p>所以可以根据上看的  gravity &amp; Gravity.VERTICAL_GRAVITY_MASK 操作获取的是什么了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 LEFT RIGHT 的设置情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HORIZONTAL_GRAVITY_MASK</span> <span class="operator">=</span> (AXIS_SPECIFIED |</span><br><span class="line">        AXIS_PULL_BEFORE | AXIS_PULL_AFTER) &lt;&lt; AXIS_X_SHIFT;</span><br><span class="line"><span class="comment">// 获取 TOP BOTTOM 的设置情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VERTICAL_GRAVITY_MASK</span> <span class="operator">=</span> (AXIS_SPECIFIED |</span><br><span class="line">        AXIS_PULL_BEFORE | AXIS_PULL_AFTER) &lt;&lt; AXIS_Y_SHIFT;</span><br></pre></td></tr></table></figure><p>不多说了～</p><h1 id="6-Gravity"><a href="#6-Gravity" class="headerlink" title="6 Gravity"></a>6 Gravity</h1><h2 id="6-1-getAbsoluteGravity"><a href="#6-1-getAbsoluteGravity" class="headerlink" title="6.1 getAbsoluteGravity"></a>6.1 getAbsoluteGravity</h2><p>将相对对齐转为绝对对齐，根据 RTL 或者 LTR 进行设置：</p><ul><li>如果水平方向为 LTR，则 START 将设置 LEFT，而 END 将设置 RIGHT。</li><li>如果水平方向是 RTL，则 START 将设置 RIGHT，而 END 将设置 LEFT。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getAbsoluteGravity</span><span class="params">(<span class="type">int</span> gravity, <span class="type">int</span> layoutDirection)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> gravity;</span><br><span class="line">    <span class="comment">//【1】判断下对齐方式是不是相对的，start 和 end 多一个 RELATIVE_LAYOUT_DIRECTION 的标志位；</span></span><br><span class="line">    <span class="keyword">if</span> ((result &amp; RELATIVE_LAYOUT_DIRECTION) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((result &amp; Gravity.START) == Gravity.START) &#123;</span><br><span class="line">            <span class="comment">//【1.1】去掉 START，如果是 RTL，那么就设置成 RIGHT，不是就是 LEFT</span></span><br><span class="line">            result &amp;= ~START;</span><br><span class="line">            <span class="keyword">if</span> (layoutDirection == View.LAYOUT_DIRECTION_RTL) &#123;</span><br><span class="line">                result |= RIGHT;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                result |= LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((result &amp; Gravity.END) == Gravity.END) &#123;</span><br><span class="line">            <span class="comment">//【1.1】去掉 END，如果是 RTL，那么就设置成 LEFT，不是就是 RIGHT</span></span><br><span class="line">            result &amp;= ~END;</span><br><span class="line">            <span class="keyword">if</span> (layoutDirection == View.LAYOUT_DIRECTION_RTL) &#123;</span><br><span class="line">                result |= LEFT;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result |= RIGHT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【2】去掉相对标志位</span></span><br><span class="line">        result &amp;= ~RELATIVE_LAYOUT_DIRECTION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于 gravity：</li></ul><p>这里的 gravity 是 android:layout_gravity 的取值，就是相对 parent 的布局比重；</p><ul><li>关于绝对/相对对齐</li></ul><p>我们在设置 view 的 android:gravity＝”” 的时候，会设置比如 “left|bottom” 这样的值，那么这些值具体的意思是什么呢？</p><p>left 和 right 代表一种绝对的对齐，而 start 和 end 表示基于阅读顺序的对齐。</p><p>如何理解呢，我们可以通过 android:layoutDirection=”rtl” 来设置视图的排列顺序，对于阿拉伯语的话，需要 RTL 的显示方式的。</p><p>当使用 left 的时候，无论是 LTR 还是 RTL，总是左对齐的；</p><p>而使用 start，在 LTR 中是左对齐，而在 RTL 中则是右对齐。</p><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h1><p>我们用一张图直观的看下 layout 的流程：</p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/23/View.layout-process.png" alt="View.layout-process" style="zoom: 33%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于 Android N 分析下 View 的 layout，N 虽然看起来略有些旧，但是框架的核心思想才是最重要的，新的一天开始了。&lt;/p&gt;
&lt;h1 id=&quot;1-回顾&quot;&gt;&lt;a href=&quot;#1-回顾&quot; class=&quot;headerlink&quot; title=&quot;1 回顾&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="View 视图" scheme="https://lishuaiqi.top/categories/View-%E8%A7%86%E5%9B%BE/"/>
    
    <category term="View 的加载和绘制" scheme="https://lishuaiqi.top/categories/View-%E8%A7%86%E5%9B%BE/View-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%BB%98%E5%88%B6/"/>
    
    
    <category term="ViewDraw" scheme="https://lishuaiqi.top/tags/ViewDraw/"/>
    
  </entry>
  
  <entry>
    <title>ViewDraw 第四篇 measure 流程分析</title>
    <link href="https://lishuaiqi.top/2020/04/15/ViewDraw-4-measure/"/>
    <id>https://lishuaiqi.top/2020/04/15/ViewDraw-4-measure/</id>
    <published>2020-04-15T12:46:25.000Z</published>
    <updated>2025-10-03T07:57:43.346Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章基于 Android N - 7.1.1 主要分析下 measure 方法的执行流程；</p><h1 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h1><p>我们来回顾下，performMeasure 请求测量的地方：</p><p>这里的参数：childWidthMeasureSpec 和 childHeightMeasureSpec 是 root view 也就是 DecorView 的测量标准！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performMeasure</span><span class="params">(<span class="type">int</span> childWidthMeasureSpec, <span class="type">int</span> childHeightMeasureSpec)</span> &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;measure&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.1】最终调用了 DecorView（ViewGroup）的 measure 方法，并将测量规范传递下去；</span></span><br><span class="line">        <span class="comment">// 这里的 childWidthMeasureSpec 和 childHeightMeasureSpec 是 parent 指定的 child view 的测量规格，也就是 DecorView 的；</span></span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mView 就是我们 DecorView，然而 DecorView 有如下的继承实现关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecorView</span> <span class="keyword">extends</span> <span class="title class_">FrameLayout</span> <span class="keyword">implements</span> <span class="title class_">RootViewSurfaceTaker</span>, WindowCallbacks &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FrameLayout</span> <span class="keyword">extends</span> <span class="title class_">ViewGroup</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ViewGroup</span> <span class="keyword">extends</span> <span class="title class_">View</span> <span class="keyword">implements</span> <span class="title class_">ViewParent</span>, ViewManager &#123;</span><br></pre></td></tr></table></figure><p>实际上 measure 是 view 的方法；</p><h2 id="1-1-MeasureSpec-测量规格"><a href="#1-1-MeasureSpec-测量规格" class="headerlink" title="1.1 MeasureSpec - 测量规格"></a>1.1 MeasureSpec - 测量规格</h2><p>MeasureSpec 是 View 的内部类。他表示一种测量规格。MeasureSpec 由测量模式 mode 和测量大小 size 组成；</p><p><strong>View 的测量规格是由 parent view 的测量规格和自身的 LayoutParams 共同决定的</strong>。</p><h3 id="1-1-1-测量模式"><a href="#1-1-1-测量模式" class="headerlink" title="1.1.1 测量模式"></a>1.1.1 测量模式</h3><ul><li><strong>UNSPECIFIED</strong>：父视图不对 View 大小做限制，当然并不是真的说想要多大最后就真有多大，例如：ListView，ScrollView；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父视图没有对 child 施加任何约束。它可以是任何大小；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNSPECIFIED</span> <span class="operator">=</span> <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br></pre></td></tr></table></figure><ul><li><strong>EXACTLY</strong>：父试图已经知道了 view 确切的大小，例如：100dp 或者 march_parent</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父视图已经确定了孩子的确切尺寸。不管孩子想要多大，都会给孩子以这些界限；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXACTLY</span>     <span class="operator">=</span> <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br></pre></td></tr></table></figure><ul><li><strong>AT_MOST</strong>：大小不可超过某数值，例如：wrap_content</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// child 可以根据自身需要的大小而确定大小，但是存在上限，上限一般为父视图大小。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AT_MOST</span>     <span class="operator">=</span> <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br></pre></td></tr></table></figure><h3 id="1-1-2-makeMeasureSpec"><a href="#1-1-2-makeMeasureSpec" class="headerlink" title="1.1.2 makeMeasureSpec"></a>1.1.2 makeMeasureSpec</h3><p>根据测量大小 size 和测量模式 mode 创建测量规格：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">makeMeasureSpec</span><span class="params">(<span class="meta">@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1)</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@MeasureSpecMode</span> <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】使用旧的方式建立 MeasureSpecs，sUseBrokenMakeMeasureSpec 值默认为 false。</span></span><br><span class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123; </span><br><span class="line">        <span class="keyword">return</span> size + mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【2】模式占高 2 位，大小占低 30 位，合成 MeasureSpec</span></span><br><span class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，MeasureSpec 是 32 位的  Int 型，高两位表示 mode，低 30 位表示 size，这里的 MODE_MASK 的作用实际上就是做位操作！</p><p>MODE_MASK 取如下的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MODE_SHIFT</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MODE_MASK</span>  <span class="operator">=</span> <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br></pre></td></tr></table></figure><p>其中 0x3 是十六进制，转为二进制是 11，向左移位30，结果是 11000…..0000（一共 30 个 0）！</p><ul><li>size &amp; ~MODE_MASK：获取 size 的低 30 位；</li><li>mode &amp; MODE_MASK：获取 mode 的高两位；</li></ul><p>最终合成测量规格；</p><h1 id="2-View"><a href="#2-View" class="headerlink" title="2 View"></a>2 View</h1><h2 id="2-1-measure-核心1"><a href="#2-1-measure-核心1" class="headerlink" title="2.1 measure - 核心1"></a>2.1 measure - 核心1</h2><p>View 的这个方法是被它的 parent view 调用的，而 widthMeasureSpec 和 heightMeasureSpec 则是 parent 指定的当前 view 的测量规格；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">measure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">optical</span> <span class="operator">=</span> isLayoutModeOptical(<span class="built_in">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123; <span class="comment">// 这里是对其做一个调整，我们先不看；</span></span><br><span class="line">          <span class="type">Insets</span> <span class="variable">insets</span> <span class="operator">=</span> getOpticalInsets();</span><br><span class="line">          <span class="type">int</span> <span class="variable">oWidth</span>  <span class="operator">=</span> insets.left + insets.right;</span><br><span class="line">          <span class="type">int</span> <span class="variable">oHeight</span> <span class="operator">=</span> insets.top  + insets.bottom;</span><br><span class="line">          widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</span><br><span class="line">          heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//【1】计算缓存的 key，高 32 低 32 位交错取值；</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">key</span> <span class="operator">=</span> (<span class="type">long</span>) widthMeasureSpec &lt;&lt; <span class="number">32</span> | (<span class="type">long</span>) heightMeasureSpec &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">      <span class="keyword">if</span> (mMeasureCache == <span class="literal">null</span>) mMeasureCache = <span class="keyword">new</span> <span class="title class_">LongSparseLongArray</span>(<span class="number">2</span>);</span><br><span class="line">      <span class="comment">//【2】判断是否强制布局；</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">forceLayout</span> <span class="operator">=</span> (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Optimize layout by avoiding an extra EXACTLY pass when the view is</span></span><br><span class="line">      <span class="comment">// already measured as the correct size. In API 23 and below, this</span></span><br><span class="line">      <span class="comment">// extra pass is required to make LinearLayout re-distribute weight.</span></span><br><span class="line">      <span class="comment">// 如果视图已经被测量获得了正确的尺寸，那么这里会判断下测量模式是否是 EXACTLY 如果是的话，那么就可能不会重新测量；</span></span><br><span class="line">      <span class="comment">// 在 API 23 及以下版本中，需要这样的额外遍历才能使 LinearLayout 重新分配权重。</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">specChanged</span> <span class="operator">=</span> widthMeasureSpec != mOldWidthMeasureSpec</span><br><span class="line">              || heightMeasureSpec != mOldHeightMeasureSpec; <span class="comment">// 测量标准是否变化</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isSpecExactly</span> <span class="operator">=</span> MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY</span><br><span class="line">              &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY; <span class="comment">// 是否是精确布局</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">matchesSpecSize</span> <span class="operator">=</span> getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">              &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec); <span class="comment">// 尺寸是否变化</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needsLayout</span> <span class="operator">=</span> specChanged <span class="comment">// 判断是否需要布局；</span></span><br><span class="line">              &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (forceLayout || needsLayout) &#123;</span><br><span class="line">          <span class="comment">// 这里会清除掉测量的标志位 measured dimension flag；</span></span><br><span class="line">          mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line"></span><br><span class="line">          resolveRtlPropertiesIfNeeded(); <span class="comment">// 处理 RTL 左右翻转属性；</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//【3】判断是否需要使用缓存，forceLayout 的话，或者忽视缓存的话，那就会使用本次新的测量模式；</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">cacheIndex</span> <span class="operator">=</span> forceLayout ? -<span class="number">1</span> : mMeasureCache.indexOfKey(key);</span><br><span class="line">          <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">              <span class="comment">//【--&gt;3.1】开始测量自身，这里会把清除掉测量的标志位 measured dimension flag 设置回去；</span></span><br><span class="line">              <span class="comment">// 这里会先调用 DecorView 的 onMeasure 方法；</span></span><br><span class="line">              <span class="comment">// (当然如果是 view 的话，这里会直接进入 view 的 onMeasure 的【--&gt;2.2】)</span></span><br><span class="line">              onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">              mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">              <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class="line">              setMeasuredDimensionRaw((<span class="type">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="type">int</span>) value);</span><br><span class="line">              mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果 measured dimension flag 没有设置或者 setMeasuredDimension 方法咩有执行，抛出异常；</span></span><br><span class="line">          <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;View with id &quot;</span> + getId() + <span class="string">&quot;: &quot;</span></span><br><span class="line">                      + getClass().getName() + <span class="string">&quot;#onMeasure() did not set the&quot;</span></span><br><span class="line">                      + <span class="string">&quot; measured dimension by calling&quot;</span></span><br><span class="line">                      + <span class="string">&quot; setMeasuredDimension()&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; <span class="comment">// 设置需要布局的标志</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//【4】保存本次的测量模式；</span></span><br><span class="line">      mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">      mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//【5】将其保存到布局缓存中；</span></span><br><span class="line">      mMeasureCache.put(key, ((<span class="type">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</span><br><span class="line">              (<span class="type">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>执行测量！</p><h2 id="2-2-onMeasure-核心2-1"><a href="#2-2-onMeasure-核心2-1" class="headerlink" title="2.2 onMeasure - 核心2.1"></a>2.2 onMeasure - 核心2.1</h2><p>view 的 onMeasure 实际上很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;2.2.1】设置测量后的宽高像素值；</span></span><br><span class="line">    <span class="comment">//【--&gt;2.2.3】获取默认的宽/高；</span></span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用于测量视图及其内容，以确定测量的宽度和测量的高度。 </p><p>measure 方法会调用此方法，并且子类必须重写此方法，同时提供对其自身的准确测量。</p><p>复写此方法时， 必须调用 setMeasuredDimension 来存储此视图的测量宽度和高度。否则，将抛出 IllegalStateException 的异常。</p><p>调用超类的 onMeasure 是有效的用法。</p><p>子类应重写 onMeasure，以提供对其内容更好的度量。</p><p>如果重写此方法，则子类必须要确保测量的高度和宽度至少为视图的最小高度和宽度 getSuggestedMinimumHeight  getSuggestedMinimumWidth</p><h3 id="2-2-1-setMeasuredDimension-核心7"><a href="#2-2-1-setMeasuredDimension-核心7" class="headerlink" title="2.2.1 setMeasuredDimension - 核心7"></a>2.2.1 setMeasuredDimension - 核心7</h3><p>保存测量的宽度和测量的高度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setMeasuredDimension</span><span class="params">(<span class="type">int</span> measuredWidth, <span class="type">int</span> measuredHeight)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">optical</span> <span class="operator">=</span> isLayoutModeOptical(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123; <span class="comment">// 这部份是根据 outInsert 调整；</span></span><br><span class="line">        <span class="type">Insets</span> <span class="variable">insets</span> <span class="operator">=</span> getOpticalInsets();</span><br><span class="line">        <span class="type">int</span> <span class="variable">opticalWidth</span>  <span class="operator">=</span> insets.left + insets.right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">opticalHeight</span> <span class="operator">=</span> insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">        measuredWidth  += optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">        measuredHeight += optical ? opticalHeight : -opticalHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;2.2.2】继续设置；</span></span><br><span class="line">    setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法必须要被 onMeasure(int, int) 调用，不然的话会抛出异常；</p><h3 id="2-2-2-setMeasuredDimensionRaw-核心8"><a href="#2-2-2-setMeasuredDimensionRaw-核心8" class="headerlink" title="2.2.2 setMeasuredDimensionRaw - 核心8"></a>2.2.2 setMeasuredDimensionRaw - 核心8</h3><p>存储测量的宽度和测量的高度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMeasuredDimensionRaw</span><span class="params">(<span class="type">int</span> measuredWidth, <span class="type">int</span> measuredHeight)</span> &#123;</span><br><span class="line">    mMeasuredWidth = measuredWidth;</span><br><span class="line">    mMeasuredHeight = measuredHeight;</span><br><span class="line">    <span class="comment">//【1】更新标志位，不然上面会抛异常的；</span></span><br><span class="line">    mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-getDefaultSize-核心3-1"><a href="#2-2-3-getDefaultSize-核心3-1" class="headerlink" title="2.2.3 getDefaultSize - 核心3.1"></a>2.2.3 getDefaultSize - 核心3.1</h3><p>参数 size 表示的是这个 view 默认的测量大小，measureSpec 则是 view 的测量规格，返回值表示这个 view 测量大小: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDefaultSize</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> measureSpec)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="comment">//【1】获取测量约束指定的模式和距离；</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">//【2】如果是 view 的测量模式是 UNSPECIFIED 数值，那么就去取自己的默认值；</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//【3】如果是其他的两种情况，取测量规格指定的大小；       </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，自定义 view，重写 onMeasure 方法的，如果不针对 AT_MOST 和 EXACTLY 做处理，那么使用 wrap_content 时与 match_parent 的效果将会是一样；</p><h4 id="2-2-3-1-getSuggestedMinimumXXXX"><a href="#2-2-3-1-getSuggestedMinimumXXXX" class="headerlink" title="2.2.3.1 getSuggestedMinimumXXXX"></a>2.2.3.1 getSuggestedMinimumXXXX</h4><p>返回最小的宽/高：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getSuggestedMinimumWidth</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="literal">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getSuggestedMinimumHeight</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="literal">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有设置背景，则获取背景 Background 的宽/高度，如果没有设置背景，则取 xml 中 android:minWidth/mMinHeight 的值；</p><h2 id="2-3-combineMeasuredStates"><a href="#2-3-combineMeasuredStates" class="headerlink" title="2.3 combineMeasuredStates"></a>2.3 combineMeasuredStates</h2><p>合并测量状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">combineMeasuredStates</span><span class="params">(<span class="type">int</span> curState, <span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> curState | newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-getMeasuredState"><a href="#2-4-getMeasuredState" class="headerlink" title="2.4 getMeasuredState"></a>2.4 getMeasuredState</h2><p>返回测量状态，实际上就是宽和高的复合整型数；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getMeasuredState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (mMeasuredWidth &amp; MEASURED_STATE_MASK) <span class="comment">// 取宽的高 8 位；</span></span><br><span class="line">            | ((mMeasuredHeight &gt;&gt; MEASURED_HEIGHT_STATE_SHIFT) <span class="comment">// 取高的高 8 位置，然后右移了 16 位；</span></span><br><span class="line">                    &amp; (MEASURED_STATE_MASK &gt;&gt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int 是 32 位，可以看到：</p><ul><li><p>将 mMeasuredWidth 左起高 8 位作为宽的测量状态；</p></li><li><p>将 mMeasuredHeight 左起高 8 位作为高的测量状态；</p></li></ul><p>但它将二者存到了一个复合整型中，对于 mMeasuredWidth 取左起高 8 位，mMeasuredHeight 也是左起高 8 位；但是右移了 16 位；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高 8 位都是 1；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEASURED_STATE_MASK</span> <span class="operator">=</span> <span class="number">0xff000000</span>;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于将宽高合并成一个复合整型；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEASURED_HEIGHT_STATE_SHIFT</span> <span class="operator">=</span> <span class="number">16</span>; <span class="comment">// 用于将高的测量值右移 16 位；</span></span><br></pre></td></tr></table></figure><p>实际结果如下：</p><p><code>wwww 0000 hhhh 0000</code></p><h2 id="2-5-resolveSizeAndState-核心6"><a href="#2-5-resolveSizeAndState-核心6" class="headerlink" title="2.5 resolveSizeAndState-核心6"></a>2.5 resolveSizeAndState-核心6</h2><p>回顾下前面的代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的 maxWidth 和 maxHeight 表示了 child view 中最大的宽度和高度，那么对于 view group，</span></span><br><span class="line"><span class="comment">// 需要基于这个值来设置自身的宽高；</span></span><br><span class="line">setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), <span class="comment">// 宽的测量状态在高 8 位；</span></span><br><span class="line">        resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); <span class="comment">// 高的测量状态在第三个 8 位，所以要左移 16 位；</span></span><br></pre></td></tr></table></figure><p>参数 size：表示的是这个 view 想显示的大小；</p><p>参数 measureSpec：是 parent view 指定的测量规格（或者是自身的测量规格，这个要看情况而定）；</p><p>参数 childMeasuredState：为 child view 的测量状态；</p><p>此时上面的代码调用，我们要基于 child view 的测量结果，设置 view group 的宽高；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">resolveSizeAndState</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> measureSpec, <span class="type">int</span> childMeasuredState)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】获取测量规格指定的测量模式和测量大小；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(measureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="comment">//【2】如果此时 view (parent) 的测量模式是 AT_MOST，那么说明 view (parent) 最大不能超过 specSize；</span></span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">            <span class="keyword">if</span> (specSize &lt; size) &#123;</span><br><span class="line">                <span class="comment">//【2.1】如果 view (parent) 的测量大小 specSize 小于 view 实际想要 size，</span></span><br><span class="line">                <span class="comment">// 应该以测量大小 specSize 为准，同时设置 MEASURED_STATE_TOO_SMALL 标志位；</span></span><br><span class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【2.2】否则的话，测量大小为 view 期望的大小 size；</span></span><br><span class="line">                result = size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            <span class="comment">//【3】如果此时 view (parent) 的测量模式为 EXACTLY，那么 view (parent) 最大不能超过 specSize；</span></span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//【4】未指定为 size</span></span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【5】最后的结果是一个复合整数，这里会 | 上 child 的测量状态（高 8 位）；</span></span><br><span class="line">    <span class="keyword">return</span> result | (childMeasuredState &amp; MEASURED_STATE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值是一个复合整数，实际的大小在 MEASURED_SIZE_MASK 位中，可以看到 32 位，24 位用来存储测量大小，剩下的 8 位是测量状态的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bits of &#123;<span class="doctag">@link</span> #getMeasuredWidthAndState()&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getMeasuredWidthAndState()&#125; that provide the actual measured size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEASURED_SIZE_MASK</span> <span class="operator">=</span> <span class="number">0x00ffffff</span>; <span class="comment">// 低 24 位；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bits of &#123;<span class="doctag">@link</span> #getMeasuredWidthAndState()&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getMeasuredWidthAndState()&#125; that provide the additional state bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEASURED_STATE_MASK</span> <span class="operator">=</span> <span class="number">0xff000000</span>; <span class="comment">// 高 8 位；</span></span><br></pre></td></tr></table></figure><p>那么这个状态是什么呢，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bit of &#123;<span class="doctag">@link</span> #getMeasuredWidthAndState()&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getMeasuredWidthAndState()&#125; that indicates the measured size</span></span><br><span class="line"><span class="comment"> * is smaller that the space the view would like to have.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MEASURED_STATE_TOO_SMALL</span> <span class="operator">=</span> <span class="number">0x01000000</span>; <span class="comment">// 表示测量值小于 view 想显示的大小；</span></span><br></pre></td></tr></table></figure><p>如果如果测量约束指定的 size 小于 view 想要的 size ，那么会设置 MEASURED_STATE_TOO_SMALL 标志位</p><h1 id="3-DecorView"><a href="#3-DecorView" class="headerlink" title="3 DecorView"></a>3 DecorView</h1><h2 id="3-1-onMeasure-核心2"><a href="#3-1-onMeasure-核心2" class="headerlink" title="3.1 onMeasure - 核心2"></a>3.1 onMeasure - 核心2</h2><p>参数是 parent 指定的测量规格，里面包含了测量模式和 parent 的剩余大小，这里根据 parent 的测量规格，计算自身的测量模式；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得屏幕的信息;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">DisplayMetrics</span> <span class="variable">metrics</span> <span class="operator">=</span> getContext().getResources().getDisplayMetrics();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isPortrait</span> <span class="operator">=</span> <span class="comment">// 判断下横屏竖屏;</span></span><br><span class="line">            getResources().getConfiguration().orientation == ORIENTATION_PORTRAIT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】获得宽高的测量模式;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">widthMode</span> <span class="operator">=</span> getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">heightMode</span> <span class="operator">=</span> getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">fixedWidth</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    mApplyFloatingHorizontalInsets = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//【2】如果宽的测量模式是 AT_MOST，表示不能超过 parent 指定的值;</span></span><br><span class="line">    <span class="keyword">if</span> (widthMode == AT_MOST) &#123;</span><br><span class="line">        <span class="comment">//【2.1】这会根据横竖屏，判断宽度的最大值，调整宽度;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TypedValue</span> <span class="variable">tvw</span> <span class="operator">=</span> isPortrait ? mWindow.mFixedWidthMinor : mWindow.mFixedWidthMajor;</span><br><span class="line">        <span class="keyword">if</span> (tvw != <span class="literal">null</span> &amp;&amp; tvw.type != TypedValue.TYPE_NULL) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> w;</span><br><span class="line">            <span class="keyword">if</span> (tvw.type == TypedValue.TYPE_DIMENSION) &#123; <span class="comment">// 具体像素值;</span></span><br><span class="line">                w = (<span class="type">int</span>) tvw.getDimension(metrics);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tvw.type == TypedValue.TYPE_FRACTION) &#123; <span class="comment">// 百分比因子;</span></span><br><span class="line">                w = (<span class="type">int</span>) tvw.getFraction(metrics.widthPixels, metrics.widthPixels);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                w = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MEASURE) Log.d(mLogTag, <span class="string">&quot;Fixed width: &quot;</span> + w);</span><br><span class="line">            <span class="comment">//【2.2】获取测量约束的指定的宽度，然后计算新的测量模式;</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">widthSize</span> <span class="operator">=</span> MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">            <span class="keyword">if</span> (w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                widthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        Math.min(w, widthSize), EXACTLY); <span class="comment">// 如果 w 大于 0，说明已经可以计算出确切的大小;</span></span><br><span class="line">                <span class="comment">// 标示已经修复了宽度;</span></span><br><span class="line">                fixedWidth = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 特殊情况，w 为 0，这里会用 DecorView 的宽度减去 mFloatingInsets 和 AT_MOST</span></span><br><span class="line">                <span class="comment">// 计算新的测量模式，child 会以此为标准;</span></span><br><span class="line">                widthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        widthSize - mFloatingInsets.left - mFloatingInsets.right,</span><br><span class="line">                        AT_MOST);</span><br><span class="line">                mApplyFloatingHorizontalInsets = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mApplyFloatingVerticalInsets = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//【3】如果高的测量模式是 AT_MOST，那么就不能超过 parent 指定的 size 值;</span></span><br><span class="line">    <span class="keyword">if</span> (heightMode == AT_MOST) &#123;</span><br><span class="line">        <span class="comment">//【3.1】这会根据横竖屏，判断宽度的最大值，调整组件的宽度;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TypedValue</span> <span class="variable">tvh</span> <span class="operator">=</span> isPortrait ? mWindow.mFixedHeightMajor</span><br><span class="line">                : mWindow.mFixedHeightMinor;</span><br><span class="line">        <span class="keyword">if</span> (tvh != <span class="literal">null</span> &amp;&amp; tvh.type != TypedValue.TYPE_NULL) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> h;</span><br><span class="line">            <span class="keyword">if</span> (tvh.type == TypedValue.TYPE_DIMENSION) &#123;</span><br><span class="line">                h = (<span class="type">int</span>) tvh.getDimension(metrics);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tvh.type == TypedValue.TYPE_FRACTION) &#123;</span><br><span class="line">                h = (<span class="type">int</span>) tvh.getFraction(metrics.heightPixels, metrics.heightPixels);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MEASURE) Log.d(mLogTag, <span class="string">&quot;Fixed height: &quot;</span> + h);</span><br><span class="line">            <span class="comment">//【3.2】获取设置的高度，然后计算孩子的测量模式；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">heightSize</span> <span class="operator">=</span> MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">            <span class="keyword">if</span> (h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                heightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        Math.min(h, heightSize), EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((mWindow.getAttributes().flags &amp; FLAG_LAYOUT_IN_SCREEN) == <span class="number">0</span>) &#123;</span><br><span class="line">                heightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        heightSize - mFloatingInsets.top - mFloatingInsets.bottom, AT_MOST);</span><br><span class="line">                mApplyFloatingVerticalInsets = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】如果设置了 outset 区域，那么要对测量模式再次进行调整；</span></span><br><span class="line">    getOutsets(mOutsets);</span><br><span class="line">    <span class="keyword">if</span> (mOutsets.top &gt; <span class="number">0</span> || mOutsets.bottom &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mode</span> <span class="operator">=</span> MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        <span class="keyword">if</span> (mode != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">            heightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                    height + mOutsets.top + mOutsets.bottom, mode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mOutsets.left &gt; <span class="number">0</span> || mOutsets.right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mode</span> <span class="operator">=</span> MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">if</span> (mode != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">            widthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                    width + mOutsets.left + mOutsets.right, mode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【--&gt;4.1】进入父类的 onMeasure 方法，传入新的测量模式；</span></span><br><span class="line">    <span class="built_in">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> getMeasuredWidth();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">measure</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里会获取测量的宽度，然后测试模式使用 EXACTLY 定义新的测量标准，进行第二次调整；</span></span><br><span class="line">    widthMeasureSpec = MeasureSpec.makeMeasureSpec(width, EXACTLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fixedWidth &amp;&amp; widthMode == AT_MOST) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TypedValue</span> <span class="variable">tv</span> <span class="operator">=</span> isPortrait ? mWindow.mMinWidthMinor : mWindow.mMinWidthMajor;</span><br><span class="line">        <span class="keyword">if</span> (tv.type != TypedValue.TYPE_NULL) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> min;</span><br><span class="line">            <span class="keyword">if</span> (tv.type == TypedValue.TYPE_DIMENSION) &#123;</span><br><span class="line">                min = (<span class="type">int</span>)tv.getDimension(metrics);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tv.type == TypedValue.TYPE_FRACTION) &#123;</span><br><span class="line">                min = (<span class="type">int</span>)tv.getFraction(mAvailableWidth, mAvailableWidth);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MEASURE) Log.d(mLogTag, <span class="string">&quot;Adjust for min width: &quot;</span> + min + <span class="string">&quot;, value::&quot;</span></span><br><span class="line">                    + tv.coerceToString() + <span class="string">&quot;, mAvailableWidth=&quot;</span> + mAvailableWidth);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (width &lt; min) &#123;</span><br><span class="line">                widthMeasureSpec = MeasureSpec.makeMeasureSpec(min, EXACTLY);</span><br><span class="line">                measure = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【--&gt;4.1】进入父类的 onMeasure 方法；</span></span><br><span class="line">    <span class="keyword">if</span> (measure) &#123;</span><br><span class="line">        <span class="built_in">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，上面的方法对 measure 传入的测量规格做了调整；</p><p>代码逻辑很简单，就不多说了；</p><h3 id="3-1-1-getMeasuredWidth"><a href="#3-1-1-getMeasuredWidth" class="headerlink" title="3.1.1 getMeasuredWidth"></a>3.1.1 getMeasuredWidth</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Like &#123;<span class="doctag">@link</span> #getMeasuredWidthAndState()&#125;, but only returns the</span></span><br><span class="line"><span class="comment"> * raw width component (that is the result is masked by</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #MEASURED_SIZE_MASK&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The raw measured width of this view.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getMeasuredWidth</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mMeasuredWidth &amp; MEASURED_SIZE_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-getMode"><a href="#3-1-2-getMode" class="headerlink" title="3.1.2 getMode"></a>3.1.2 getMode</h3><p>获取测量模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MeasureSpecMode</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMode</span><span class="params">(<span class="type">int</span> measureSpec)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-FrameLayout"><a href="#4-FrameLayout" class="headerlink" title="4 FrameLayout"></a>4 FrameLayout</h1><h2 id="4-1-onMeasure-核心3"><a href="#4-1-onMeasure-核心3" class="headerlink" title="4.1 onMeasure - 核心3"></a>4.1 onMeasure - 核心3</h2><p>DecorView.onMeasure 进入 FrameLayout.onMeasure 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;4.1.1】获取所有的 child view;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getChildCount();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】EXACTLY 表示父视图已经确定了孩子的确切尺寸。不管孩子想要多大，都会给孩子这些值；</span></span><br><span class="line">    <span class="comment">// 比如具体数值，或者 match_parent；</span></span><br><span class="line">    <span class="comment">// 但是如果不是 EXACTLY 那就要每个 child 重新测量;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">measureMatchParentChildren</span> <span class="operator">=</span></span><br><span class="line">            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">    mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 maxHeight 和 maxWidth 用来保存当前 view 的最大宽/高;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">childState</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】遍历每个 child view，可以看到，对于 ViewGroup，必须要先测量一下内部的 child view;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;5.1】测量 child view;</span></span><br><span class="line">            measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2.1】获取到 child view 的布局参数，同时确定所有 child 的最大高度和最大宽度</span></span><br><span class="line">            <span class="comment">// 需要考虑 child 占用的 margin 距离;</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">            maxWidth = Math.max(maxWidth,</span><br><span class="line">                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">            maxHeight = Math.max(maxHeight,</span><br><span class="line">                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【--&gt;2.4】获取每个 child view 的测量状态，同时【--&gt;2.3】合并 child 的测量状态;</span></span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2.2】如果需要对 child view 进行重新测量的话，同时 child view 的 lp 的 width/height</span></span><br><span class="line">            <span class="comment">// 至少有一个为 MATCH_PARENT，那么这个 view 就会被添加到 mMatchParentChildren 中;</span></span><br><span class="line">            <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                        lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    mMatchParentChildren.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】累加 padding 区域，这个是 FlameLayout 独有的；</span></span><br><span class="line">    maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">    maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】检查下最小的宽/高；</span></span><br><span class="line">    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】检查下前景的宽/高；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Drawable</span> <span class="variable">drawable</span> <span class="operator">=</span> getForeground();</span><br><span class="line">    <span class="keyword">if</span> (drawable != <span class="literal">null</span>) &#123;</span><br><span class="line">        maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">        maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【--&gt;2.2.1】设置 DecorView/FlameLayout 自身的测量宽高值，可以看到 viewGroup 的宽高值依赖 child view 的 max 宽高；</span></span><br><span class="line">    <span class="comment">//【--&gt;2.5】这里会根据 child 的测量状态，调整 FlameLayout 的测量状态；</span></span><br><span class="line">    <span class="comment">// 这里的 maxWidth 和 maxHeight 表示了 child view 中最大的宽度和高度，那么对于 view group，</span></span><br><span class="line">    <span class="comment">// 需要基于这个值来设置自身的宽高；</span></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                    childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是正式处理 child view；</span></span><br><span class="line">    count = mMatchParentChildren.size();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 【3】count 大于 0，说明部分 child 也需要测量调整！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> mMatchParentChildren.get(i);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">MarginLayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="comment">//【3.1】重新计算 child view 的宽/高测量约束；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> childWidthMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="comment">// 如果 child view 的布局参数是 match parent 的话，那么 child 的测量模式为 EXACTLY；</span></span><br><span class="line">                <span class="comment">// 同时会计算新的测量宽度 width（在父 view 的距离基础上 - 父 view 的 padding - child 的 margin）</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, getMeasuredWidth()</span><br><span class="line">                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                        - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                <span class="comment">// 计算新的测量规格；</span></span><br><span class="line">                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        width, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【--&gt;5.2】如果 child view 的布局参数不是 match parent 的话，这里会调用</span></span><br><span class="line">                <span class="comment">// 新的方法计算测量规格；</span></span><br><span class="line">                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                        lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> childHeightMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, getMeasuredHeight()</span><br><span class="line">                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                        - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        height, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin,</span><br><span class="line">                        lp.height);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【--&gt;2.1】child view 处理，如果是 ViewGroup 的话，流程和 DecorView 类似；</span></span><br><span class="line">            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到了，对于 ViewGroup u </p><h3 id="4-1-1-getChildCount"><a href="#4-1-1-getChildCount" class="headerlink" title="4.1.1 getChildCount"></a>4.1.1 getChildCount</h3><p>返回内部的 child view 的个数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getChildCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mChildrenCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-ViewGroup"><a href="#5-ViewGroup" class="headerlink" title="5 ViewGroup"></a>5 ViewGroup</h1><h2 id="5-1-measureChildWithMargins-核心4"><a href="#5-1-measureChildWithMargins-核心4" class="headerlink" title="5.1 measureChildWithMargins - 核心4"></a>5.1 measureChildWithMargins - 核心4</h2><p>测量 child view 自身，但是要考虑到 child 的 Margin 距离和 parent 的 padding 距离；</p><ul><li>参数 View child：要测量的 child view；</li><li>参数 int parentWidthMeasureSpec：parent 的 width 测量约束；</li><li>参数 int widthUsed：parent view 已经被使用的距离（这个距离可能是被其他 view 使用了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">measureChildWithMargins</span><span class="params">(View child,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> parentWidthMeasureSpec, <span class="type">int</span> widthUsed,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> parentHeightMeasureSpec, <span class="type">int</span> heightUsed)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】获取到 child 布局参数 LayoutParams；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">MarginLayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【--&gt;5.1.1】根据 parent 的测量规格和 child 的布局参数，计算 child view 的测量规格！！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【--&gt;2.1】每个 view 进行自身的测量的递归；</span></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewGroup 继承了 View，他没有 measure 方法呀，调用的依然是 View 的 measure 方法；</p><h3 id="5-1-1-getChildMeasureSpec-核心5"><a href="#5-1-1-getChildMeasureSpec-核心5" class="headerlink" title="5.1.1 getChildMeasureSpec - 核心5"></a>5.1.1 getChildMeasureSpec - 核心5</h3><p>getChildMeasureSpec 将 parent view 的 MeasureSpec 信息与 child 的 LayoutParams 结合起来，为一个 child 视图的高度或宽度，确定正确的 MeasureSpec。</p><ul><li><p>参数 int spec：parent view 的测量规格，parent 指定，child 需要根据他来计算自身实际的测量规格；</p></li><li><p>参数 int padding：parent view 里已经被占用的空间；</p></li><li><p>参数 int childDimension：child view 的  LayoutParams 指定的显示的大小；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildMeasureSpec</span><span class="params">(<span class="type">int</span> spec, <span class="type">int</span> padding, <span class="type">int</span> childDimension)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】根据测量约束返回测量模式和测量距离；</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(spec);</span><br><span class="line">    <span class="comment">//【2】由于 specSize 是 parent 指定的测量距离，换要减去 padding 的距离，才是 child 的测量距离；</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">resultSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resultMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】处理测量模式；</span></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">//【3.1】如果 parent 的模式是 EXACTLY，表示 parent 知道了自己确切的大小；</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//【3.1.1】如果 child 布局参数指定了具体大小，那么 child 的测量规格定下来了，</span></span><br><span class="line">            <span class="comment">// 测量大小就是 child 布局参数指定的，测量模式为 EXACTLY；</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">//【3.1.2】如果 child 布局参数指定了 MATCH_PARENT，意味着 child 要和 parent 一样，而 parent 已经确定自己的大小了，</span></span><br><span class="line">            <span class="comment">// 那么 child 的测量大小就是 parent 的大小，测量模式就是 EXACTLY；</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">//【3.1.3】如果 child 布局参数指定了 WRAP_CONTENT，意味着 child 自适应内容，但是不能超过 parent</span></span><br><span class="line">            <span class="comment">// 那么 child 可以自适应，但大小不能超过 parent size，而测试模式为 AT_MOST；</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.2】如果 parent 的模式是 AT_MOST，也就是说 parent 还未确定自己的尺寸，但是大小不能超过 size</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//【3.2.1】如果 child 布局参数指定了大小，那么 child 的测量规格可以定下来了，虽然 parent 不定，但是</span></span><br><span class="line">            <span class="comment">// 依然可以满足 child 的要求，测试大小为 child 布局参数指定的，测试模式为 EXACTLY；</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">//【3.2.2】如果 child 没有指定具体的大小，而是 MATCH_PARENT，但是由于 parent 的模式是 AT_MOST，无法确定自己的大小</span></span><br><span class="line">            <span class="comment">// 所以，child 和 parent 一样，测量大小是 parent 的上限 size，测试模式为 AT_MOST；</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">//【3.2.3】如果 child 布局参数指定了 WRAP_CONTENT，意味着 child 自适应内容，但是不能超过 parent</span></span><br><span class="line">            <span class="comment">// 那么 child 可以自适应，但大小不能超过 parent size，而测试模式同样为 AT_MOST；</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.3】如果是 UNSPECIFIED，表示 parent 无法去确定自己的尺寸大小；</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//【3.3.1】如果 child 指定了大小，那么实际的测量大小就是 child 想要的，模式为 EXACTLY；</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">//【3.3.2】如果 child 没有指定具体的大小，而是 MATCH_PARENT，这里会计算出它实际的大小；</span></span><br><span class="line">            <span class="comment">// 模式为 UNSPECIFIED</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">//【3.3.3】如果 child 没有指定具体的大小，而是 WRAP_CONTENT，</span></span><br><span class="line">            <span class="comment">// 那么 child 想要自适应，自己调整大小，大小不能超过 size，模式为 AT_MOST；</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】生成 child 的测量约束；</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法实际上就是 ViewGroup 的核心之一，他会根据 parent 传入的测量模式，计算每个  child 的测量模式；</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><h2 id="6-1-测量的条件"><a href="#6-1-测量的条件" class="headerlink" title="6.1 测量的条件"></a>6.1 测量的条件</h2><p>每次都会 measure 嘛？未必，情况下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果视图已经被测量获得了正确的尺寸，那么这里会判断下测量模式是否是 EXACTLY 如果是的话，那么就可能不会重新测量；</span></span><br><span class="line"><span class="comment">// 在 API 23 及以下版本中，需要这样的额外遍历才能使 LinearLayout 重新分配权重。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">specChanged</span> <span class="operator">=</span> widthMeasureSpec != mOldWidthMeasureSpec</span><br><span class="line">    || heightMeasureSpec != mOldHeightMeasureSpec; <span class="comment">// 测量标准是否变化</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isSpecExactly</span> <span class="operator">=</span> MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY</span><br><span class="line">    &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY; <span class="comment">// 是否是精确布局</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">matchesSpecSize</span> <span class="operator">=</span> getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">    &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec); <span class="comment">// 尺寸是否变化</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needsLayout</span> <span class="operator">=</span> specChanged <span class="comment">// 判断是否需要布局；</span></span><br><span class="line">    &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (forceLayout || needsLayout) &#123;</span><br></pre></td></tr></table></figure><p>可以看到，其实需要一些条件的；</p><h2 id="6-2-View-和-ViewGroup-的测量不同点"><a href="#6-2-View-和-ViewGroup-的测量不同点" class="headerlink" title="6.2 View 和 ViewGroup 的测量不同点"></a>6.2 View 和 ViewGroup 的测量不同点</h2><p>View：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">measure() -&gt; onMeasure()</span><br></pre></td></tr></table></figure><p>这里传递进来的就是 view 的测量布局；</p><p>View Group：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">measure() -&gt; measureChild()/</span><br></pre></td></tr></table></figure><p>开始是 view group 的测量规格，后面在 measureChild 中，会根据 view group 的测量规格，计算 view 的测量规格，然后进入上面 view 的逻辑：</p><h2 id="6-3-measure-测量"><a href="#6-3-measure-测量" class="headerlink" title="6.3 measure 测量"></a>6.3 measure 测量</h2><p>上面的流程里面 measureChildWithMargins 方法，考虑到了 child view 的 margin 距离，而 ViewGroup 内部还有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">measureChild</span><span class="params">(View child, <span class="type">int</span> parentWidthMeasureSpec,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> parentHeightMeasureSpec)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> child.getLayoutParams();</span><br><span class="line">    <span class="comment">//【1】可以看到，这里只考虑到了 parent view 的 padding 距离</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是实际上，正常情况来说，margin 距离肯定是要有的，所以 measureChildWithMargins 会更有用些；</p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/23/View.measure-process.png" alt="View.measure-process" style="zoom: 33%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇文章基于 Android N - 7.1.1 主要分析下 measure 方法的执行流程；&lt;/p&gt;
&lt;h1 id=&quot;1-回顾&quot;&gt;&lt;a href=&quot;#1-回顾&quot; class=&quot;headerlink&quot; title=&quot;1 回顾&quot;&gt;&lt;/a&gt;1 回顾&lt;/h1&gt;&lt;p&gt;我们来回顾下，</summary>
      
    
    
    
    <category term="View 视图" scheme="https://lishuaiqi.top/categories/View-%E8%A7%86%E5%9B%BE/"/>
    
    <category term="View 的加载和绘制" scheme="https://lishuaiqi.top/categories/View-%E8%A7%86%E5%9B%BE/View-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%BB%98%E5%88%B6/"/>
    
    
    <category term="ViewDraw" scheme="https://lishuaiqi.top/tags/ViewDraw/"/>
    
  </entry>
  
  <entry>
    <title>EventBus 第四篇 - 发送消息</title>
    <link href="https://lishuaiqi.top/2019/09/13/Eventbus-4-postMessage/"/>
    <id>https://lishuaiqi.top/2019/09/13/Eventbus-4-postMessage/</id>
    <published>2019-09-13T12:46:25.000Z</published>
    <updated>2019-09-20T14:09:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章主要分析 EventBus 框架的架构和原理，，基于最新的 <strong>3.1.0</strong> 版本。</p><blockquote><p>这是 EventBus 开源库的地址，大家可以直接访问<br><a href="https://github.com/greenrobot/EventBus">https://github.com/greenrobot/EventBus</a></p></blockquote><p>本篇文章是 EventBus 的第四篇，主要分析发送消息的流程；</p><h1 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h1><p>我们回顾下 eventbus 的使用：</p><ul><li>发送普通的消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(messageEvent);</span><br></pre></td></tr></table></figure><ul><li>发送 sticky 消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(messageEvent)</span><br></pre></td></tr></table></figure><p>这里我们来分析下 <strong>post</strong> 的流程，也是最后一篇了；</p><h1 id="2-EventBus"><a href="#2-EventBus" class="headerlink" title="2 EventBus"></a>2 EventBus</h1><h2 id="2-1-post"><a href="#2-1-post" class="headerlink" title="2.1 post"></a>2.1 post</h2><p>发送普通消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;3.1】获取当前线程的 PostingThreadState 实例；</span></span><br><span class="line">    <span class="type">PostingThreadState</span> <span class="variable">postingState</span> <span class="operator">=</span> currentPostingThreadState.get();</span><br><span class="line">    <span class="comment">//【2】获取每个线程的事件队列 queue；</span></span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line">    <span class="comment">//【3】如果当前的状态不是正在 posting；</span></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        <span class="comment">//【4】判断当前是否是主线程；</span></span><br><span class="line">        postingState.isMainThread = isMainThread();</span><br><span class="line">        <span class="comment">//【5】将 posting 状态设置为 true；</span></span><br><span class="line">        postingState.isPosting = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Internal error. Abort state was not reset&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【4】事件队列不为 Empty，所以要分发事件；</span></span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//【--&gt;2.1.1】分发单个消息；</span></span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="literal">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段逻辑不是很复杂！！</p><p>isMainThread 方法很简单，就不多说了。。。</p><h3 id="2-1-1-postSingleEvent"><a href="#2-1-1-postSingleEvent" class="headerlink" title="2.1.1 postSingleEvent"></a>2.1.1 postSingleEvent</h3><p>发送单个事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error &#123;</span><br><span class="line">    <span class="comment">//【1】获取事件的 class 实例；</span></span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">subscriptionFound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//【2】如果允许继承的话，那就要针对事件类型做处理，因为可能有继承的关系；</span></span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.1.1.1】查询所有的事件类型；</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">        <span class="type">int</span> <span class="variable">countTypes</span> <span class="operator">=</span> eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            <span class="comment">//【--&gt;2.1.2】开始根据每一种事件类型去分发事件（多态）；</span></span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.1.2】开始根据传入的事件类型去分发事件（无需继承）；</span></span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】处理没有订阅者的情况；</span></span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">            logger.log(Level.FINE, <span class="string">&quot;No subscribers registered for event &quot;</span> + eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">            post(<span class="keyword">new</span> <span class="title class_">NoSubscriberEvent</span>(<span class="built_in">this</span>, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EventBus  中有一个 eventTypesCache 的 hash：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>key 是事件的 class，而 value 是一个 list，用于保存 class 和其 superClass，以及其他的所有接口；</p><p>因为如果允许事件继承的话，那么根据多态的概念，必须要收集所有的父类和接口；</p><h4 id="2-1-1-1-lookupAllEventTypes"><a href="#2-1-1-1-lookupAllEventTypes" class="headerlink" title="2.1.1.1  lookupAllEventTypes"></a>2.1.1.1  lookupAllEventTypes</h4><p>查询所有的事件类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (eventTypesCache) &#123;</span><br><span class="line">        <span class="comment">//【1】从 eventTypesCache 中获取事件 class 对应的事件类型列表；</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</span><br><span class="line">        <span class="keyword">if</span> (eventTypes == <span class="literal">null</span>) &#123;</span><br><span class="line">            eventTypes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            Class&lt;?&gt; clazz = eventClass;</span><br><span class="line">            <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                eventTypes.add(clazz);</span><br><span class="line">                <span class="comment">//【--&gt;2.1.1.2】添加接口，也就是获取 class 的所有接口；</span></span><br><span class="line">                addInterfaces(eventTypes, clazz.getInterfaces());、</span><br><span class="line">                <span class="comment">//【2】获取其父类，继续遍历；</span></span><br><span class="line">                clazz = clazz.getSuperclass();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【3】最后放到 cache 目录中；</span></span><br><span class="line">            eventTypesCache.put(eventClass, eventTypes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eventTypes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这<strong>部分的代码</strong>，<strong>主要逻辑如下</strong>：</p><ul><li>将 <strong>eventClass</strong> 加入到 <strong>eventTypesCache</strong> 的 <strong>eventTypes list</strong> 中；</li><li><strong>向上遍历</strong>，对于每一个 <strong>super class</strong>，都会将其加入到  <strong>eventTypesCache</strong> 的 <strong>eventTypes list</strong> 中；</li><li>对于<strong>每个 class</strong>，将其直接实现和间接实现的所有接口，都添加到 <strong>eventTypesCache</strong> 的 <strong>eventTypes list</strong> 中；</li></ul><h4 id="2-1-1-2-addInterfaces"><a href="#2-1-1-2-addInterfaces" class="headerlink" title="2.1.1.2 addInterfaces"></a>2.1.1.2 addInterfaces</h4><p>添加接口集合，就是事件类实现的所有接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addInterfaces</span><span class="params">(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[] interfaces)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】遍历所有的接口，将其收集到 eventTypes 中；</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; interfaceClass : interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!eventTypes.contains(interfaceClass)) &#123;</span><br><span class="line">            eventTypes.add(interfaceClass);</span><br><span class="line">            <span class="comment">//【--&gt;】处理的接口的接口；</span></span><br><span class="line">            addInterfaces(eventTypes, interfaceClass.getInterfaces());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很简单！</p><h3 id="2-1-2-postSingleEventForEventType"><a href="#2-1-2-postSingleEventForEventType" class="headerlink" title="2.1.2  postSingleEventForEventType"></a>2.1.2  postSingleEventForEventType</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> &#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】首先去查询该事件是否已经有订阅关系了，这个关系在 register 的时候会确定；</span></span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】存在订阅关系的话，那就 post 消息；</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="literal">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//【2.1】处理每一个订阅关系；</span></span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">aborted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【--&gt;2.2.1】分发事件；</span></span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                <span class="comment">//【2.2】判断是否取消事件分发；</span></span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.event = <span class="literal">null</span>;</span><br><span class="line">                postingState.subscription = <span class="literal">null</span>;</span><br><span class="line">                postingState.canceled = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (aborted) &#123; <span class="comment">// 如果要取消分发，那么会跳出循环；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单；</p><h4 id="2-2-1-postToSubscription-线程模式处理"><a href="#2-2-1-postToSubscription-线程模式处理" class="headerlink" title="2.2.1 postToSubscription - 线程模式处理"></a>2.2.1 postToSubscription - 线程模式处理</h4><p>分发事件，根据订阅方法的线程模式启动不同的 poster；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="type">boolean</span> isMainThread)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            <span class="comment">//【1】POSTING，就在事件分发的线程分发订阅；</span></span><br><span class="line">            <span class="comment">//【--&gt;2.2.2】分发订阅；</span></span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="comment">//【2】MAIN，在主线程分发订阅，这里会判断是否已经在 main 线程，</span></span><br><span class="line">            <span class="comment">// 如果是的话，那就直接分发订阅，否则就通过 mainThreadPoster 分发；</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event); <span class="comment">//【--&gt;2.2.2】分发订阅；</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event); <span class="comment">//【--&gt;4.1.2】加入队列；</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="comment">//【3】BACKGROUND，通过子线程分发订阅，如果当前是在 main 线程，</span></span><br><span class="line">            <span class="comment">// 那就通过 backgroundPoster 新起一个线程分发，如果当前是在自线程，那就当前线程分发；</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event); <span class="comment">//【--&gt;4.2.2】加入队列；</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event); <span class="comment">//【--&gt;2.2.2】分发订阅；</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            <span class="comment">//【4】ASYNC，异步分发订阅，通过 asyncPoster 每次都新起一个线程分发；</span></span><br><span class="line">            asyncPoster.enqueue(subscription, event); <span class="comment">//【--&gt;4.3.2】加入队列；</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unknown thread mode: &quot;</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到了四种不同的线程模式，每种模式有着不同的处理！</p><p>同时也看到了一个重要的数据结构：Poster</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Poster mainThreadPoster; <span class="comment">// 主线程 poster，指向一个 HandlerPoster 实例；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BackgroundPoster backgroundPoster; <span class="comment">// 后台线程 poster</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AsyncPoster asyncPoster; <span class="comment">// 异步 poster</span></span><br></pre></td></tr></table></figure><p>对于 mainThreadPoster，他是在 AndroidHandlerMainThreadSupport 中创建的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Poster <span class="title function_">createPoster</span><span class="params">(EventBus eventBus)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HandlerPoster</span>(eventBus, looper, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不多说了！</p><h3 id="2-2-2-invokeSubscriber"><a href="#2-2-2-invokeSubscriber" class="headerlink" title="2.2.2 invokeSubscriber"></a>2.2.2 invokeSubscriber</h3><p>分发订阅，也就是调用订阅者的方法处理订阅事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】method.invoke 反射调用；</span></span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，不多说了；</p><h2 id="2-2-postSticky"><a href="#2-2-postSticky" class="headerlink" title="2.2 postSticky"></a>2.2 postSticky</h2><p>发送粘性消息，这可以看到，该方法会将 <strong>event</strong> 保存到 <strong>stickyEvents</strong> 表中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postSticky</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">        <span class="comment">//【1】保存到 stickyEvents 中；</span></span><br><span class="line">        stickyEvents.put(event.getClass(), event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;2.1】发送该消息；</span></span><br><span class="line">    post(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面 <strong>register</strong> 的时候，我们有分析过在 <strong>register</strong> 时会立刻处理 <strong>Sticky</strong> 事件的分发；</p><p>这里就不再多说了；</p><h1 id="3-PostingThreadState"><a href="#3-PostingThreadState" class="headerlink" title="3 PostingThreadState"></a>3 PostingThreadState</h1><p>这个类用于保存 <strong>thread post</strong> 的状态，在 <strong>EventBus</strong> 中有个 <strong>ThreadLocal</strong> 成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> PostingThreadState <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;3.1】创建 PostingThreadState 对象；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PostingThreadState</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用于保存每一个线程的 <strong>post</strong> 状态！！</p><h2 id="3-1-成员变量"><a href="#3-1-成员变量" class="headerlink" title="3.1 成员变量"></a>3.1 成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PostingThreadState</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 事件队列；</span></span><br><span class="line">    <span class="type">boolean</span> isPosting; <span class="comment">// 线程是否正在 post 消息；</span></span><br><span class="line">    <span class="type">boolean</span> isMainThread; <span class="comment">// post 的线程是否是主线程；</span></span><br><span class="line">    Subscription subscription; <span class="comment">// 订阅关系；</span></span><br><span class="line">    Object event; <span class="comment">// 正在 post 的事件，会从 eventQueue 按照顺序来分发；</span></span><br><span class="line">    <span class="type">boolean</span> canceled; <span class="comment">// 是否被取消了；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-Poster"><a href="#4-Poster" class="headerlink" title="4 Poster"></a>4 Poster</h1><p>poster 用于订阅事件的最终分发，所有的 Poster 都实现了下面的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Posts events.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> William Ferguson</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Poster</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enqueue an event to be posted for a particular subscription.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subscription Subscription which will receive the event.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event        Event that will be posted to subscribers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Subscription subscription, Object event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着分析：</p><h2 id="4-1-HandlerPoster"><a href="#4-1-HandlerPoster" class="headerlink" title="4.1 HandlerPoster"></a>4.1 HandlerPoster</h2><p>处理 main thread 的事件分发：</p><h3 id="4-1-1-成员变量"><a href="#4-1-1-成员变量" class="headerlink" title="4.1.1 成员变量"></a>4.1.1 成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerPoster</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Poster</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue; <span class="comment">// 正在分发的 post 队列；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxMillisInsideHandleMessage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> handlerActive; <span class="comment">// 是否处于激活状态；</span></span><br></pre></td></tr></table></figure><p>参数 maxMillisInsideHandleMessage 表示处理消息的函数的执行事件，单位是毫秒，传入的是 10；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---&gt; [AndroidHandlerMainThreadSupport.java]</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Poster <span class="title function_">createPoster</span><span class="params">(EventBus eventBus)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HandlerPoster</span>(eventBus, looper, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AndroidHandlerMainThreadSupport 创建了一个 HandlerPoster，他会作为 EventBus 单例的成员变量；</p><h3 id="4-1-2-enqueue"><a href="#4-1-2-enqueue" class="headerlink" title="4.1.2 enqueue"></a>4.1.2 enqueue</h3><p>添加 post 到队列 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;6.2】创建一个 PendingPost；</span></span><br><span class="line">    <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;7.2】入队列：</span></span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">            handlerActive = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//【3】发送消息；</span></span><br><span class="line">            <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Could not send handler message&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HandlerPoster 本质上是一个 handler！</p><h3 id="4-1-3-run"><a href="#4-1-3-run" class="headerlink" title="4.1.3 run"></a>4.1.3 run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">rescheduled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">started</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">//【1】一个 while 循环，处理 PendingPostQueue 中所有的 post 操作；</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;7.3】post 出队列；</span></span><br><span class="line">            <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="comment">//【--&gt;7.3】第一次为 null，post 出队列；</span></span><br><span class="line">                    pendingPost = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                        handlerActive = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【--&gt;2.2.2】执行方法；</span></span><br><span class="line">            eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">            <span class="type">long</span> <span class="variable">timeInMethod</span> <span class="operator">=</span> SystemClock.uptimeMillis() - started;</span><br><span class="line">            <span class="comment">//【2】判断了函数的执行时间，如果大于 10 毫秒，那么说明主线程比较卡顿，</span></span><br><span class="line">            <span class="comment">// 这里会再次发送消息，然后立刻退出循环，这是防止 while 循环堵塞主线程；</span></span><br><span class="line">            <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Could not send handler message&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【3】设置为 true，handlerActive 会被设置为 rescheduled</span></span><br><span class="line">                <span class="comment">// 因为上面已经再次发送了消息。</span></span><br><span class="line">                rescheduled = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        handlerActive = rescheduled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，主线程的分发策略是：</p><ul><li>尽可能一次性处理完成 <strong>PendingPostQueue</strong> 中的所有消息；</li><li>如果某个消息的处理时间超过 <strong>10</strong> 毫秒，说明主线程很卡，那么就会退出 <strong>while</strong> 循环；</li></ul><h2 id="4-2-BackgroundPoster"><a href="#4-2-BackgroundPoster" class="headerlink" title="4.2 BackgroundPoster"></a>4.2 BackgroundPoster</h2><p>处理 background thread 的事件分发：</p><h3 id="4-2-1-成员变量"><a href="#4-2-1-成员变量" class="headerlink" title="4.2.1 成员变量"></a>4.2.1 成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, Poster &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue; <span class="comment">// 消息队列；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> executorRunning; <span class="comment">// 线程池是否在运行；</span></span><br></pre></td></tr></table></figure><p>可以看到 BackgroundPoster 是一个 Runnable；</p><h3 id="4-2-2-enqueue"><a href="#4-2-2-enqueue" class="headerlink" title="4.2.2 enqueue"></a>4.2.2 enqueue</h3><p>添加消息到 poster 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;6.2】创建一个 PendingPost；</span></span><br><span class="line">    <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;7.2】入队列：</span></span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        <span class="keyword">if</span> (!executorRunning) &#123; <span class="comment">// executorRunning 设置为 true；</span></span><br><span class="line">            executorRunning = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//【--&gt;4.2.3】执行 BackgroundPoster;</span></span><br><span class="line">            eventBus.getExecutorService().execute(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方加了锁，这是因为 <strong>post</strong> 方法可以在多线程调用；</p><h3 id="4-2-3-run"><a href="#4-2-3-run" class="headerlink" title="4.2.3 run"></a>4.2.3 run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//【1】post 出队列，这里有个超时处理：</span></span><br><span class="line">                <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> queue.poll(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">// 这里加锁了；</span></span><br><span class="line">                        <span class="comment">//【2】如果为 null，那就再次检查，如果依然为 null</span></span><br><span class="line">                        <span class="comment">// 那就退出 run 执行，executorRunning 设置为 false；</span></span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                            executorRunning = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【--&gt;2.2.2】执行方法；</span></span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + <span class="string">&quot; was interruppted&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executorRunning = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个线程因为 while (true) 一直处于 runnable/running 的状态；</p><h2 id="4-3-AsyncPoster"><a href="#4-3-AsyncPoster" class="headerlink" title="4.3 AsyncPoster"></a>4.3 AsyncPoster</h2><p>处理 async thread 的事件分发：</p><h3 id="4-3-1-成员变量"><a href="#4-3-1-成员变量" class="headerlink" title="4.3.1 成员变量"></a>4.3.1 成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncPoster</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, Poster &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue; <span class="comment">// 队列；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-enqueue"><a href="#4-3-2-enqueue" class="headerlink" title="4.3.2 enqueue"></a>4.3.2 enqueue</h3><p>添加消息到 poster 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;6.2】创建一个 PendingPost；</span></span><br><span class="line">    <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="comment">//【--&gt;7.2】入队列：</span></span><br><span class="line">    queue.enqueue(pendingPost);</span><br><span class="line">    eventBus.getExecutorService().execute(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个人地方竟然没有加锁，奇怪啊～</p><h3 id="4-3-3-run"><a href="#4-3-3-run" class="headerlink" title="4.3.3 run"></a>4.3.3 run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;7.3】post 出队列；</span></span><br><span class="line">    <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No pending post available&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;2.2.2】执行方法；</span></span><br><span class="line">    eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-PendingPost"><a href="#6-PendingPost" class="headerlink" title="6 PendingPost"></a>6 PendingPost</h1><p>表示一个正在分发的 post。</p><h2 id="6-1-成员变量"><a href="#6-1-成员变量" class="headerlink" title="6.1 成员变量"></a>6.1 成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PendingPost</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存 post，用于复用；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;PendingPost&gt; pendingPostPool = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;PendingPost&gt;(); </span><br><span class="line">    Object event; <span class="comment">// 要分发的事件；</span></span><br><span class="line">    Subscription subscription; <span class="comment">// 订阅关系；</span></span><br><span class="line">    PendingPost next; <span class="comment">// 下一个要分发的 post，用户构成链表结构；！</span></span><br></pre></td></tr></table></figure><h2 id="6-2-obtainPendingPost"><a href="#6-2-obtainPendingPost" class="headerlink" title="6.2 obtainPendingPost"></a>6.2 obtainPendingPost</h2><p>获取一个 <strong>PendingPost</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PendingPost <span class="title function_">obtainPendingPost</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> pendingPostPool.size();</span><br><span class="line">        <span class="comment">//【1】优先从 pendingPostPool 中获取；</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> pendingPostPool.remove(size - <span class="number">1</span>);</span><br><span class="line">            pendingPost.event = event;</span><br><span class="line">            pendingPost.subscription = subscription;</span><br><span class="line">            pendingPost.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> pendingPost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】没有的话，再创建新的；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PendingPost</span>(event, subscription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有加锁的！</p><h2 id="6-3-releasePendingPost"><a href="#6-3-releasePendingPost" class="headerlink" title="6.3 releasePendingPost"></a>6.3 releasePendingPost</h2><p>消息 <strong>post</strong> 完成后，会缓存 <strong>post</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">releasePendingPost</span><span class="params">(PendingPost pendingPost)</span> &#123;</span><br><span class="line">    pendingPost.event = <span class="literal">null</span>;</span><br><span class="line">    pendingPost.subscription = <span class="literal">null</span>;</span><br><span class="line">    pendingPost.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">        <span class="comment">//【1】缓存已经 post 的消息的 PendingPost！！！</span></span><br><span class="line">        <span class="keyword">if</span> (pendingPostPool.size() &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">            pendingPostPool.add(pendingPost);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：pendingPostPool 不会超过 10000 个；</p><h1 id="7-PendingPostQueue"><a href="#7-PendingPostQueue" class="headerlink" title="7 PendingPostQueue"></a>7 PendingPostQueue</h1><p>这是一个由链表构成的 正在分发的 post 的队列！</p><h2 id="7-1-成员变量"><a href="#7-1-成员变量" class="headerlink" title="7.1 成员变量"></a>7.1 成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PendingPostQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PendingPost head; <span class="comment">// 队列头；</span></span><br><span class="line">    <span class="keyword">private</span> PendingPost tail; <span class="comment">// 队列尾；</span></span><br></pre></td></tr></table></figure><p>内部有队列头和队列尾两个属性；</p><p>这个方法的 <strong>enqueue</strong> 和 <strong>poll</strong> 是加锁的～</p><h2 id="7-2-enqueue"><a href="#7-2-enqueue" class="headerlink" title="7.2 enqueue"></a>7.2 enqueue</h2><p>将 PendingPost 放入到队列中，默认是加入到队尾，该方法是加锁了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(PendingPost pendingPost)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;null cannot be enqueued&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】入队列；</span></span><br><span class="line">    <span class="keyword">if</span> (tail != <span class="literal">null</span>) &#123;</span><br><span class="line">        tail.next = pendingPost;</span><br><span class="line">        tail = pendingPost;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        head = tail = pendingPost;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Head present, but no tail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】提醒其他阻塞的线程；</span></span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-poll"><a href="#7-3-poll" class="headerlink" title="7.3 poll"></a>7.3 poll</h2><p>PendingPost 出队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> PendingPost <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//【1】从 head 出队列，更改指针；</span></span><br><span class="line">    <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            tail = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pendingPost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> PendingPost <span class="title function_">poll</span><span class="params">(<span class="type">int</span> maxMillisToWait)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【2】这个方法会在队列为 null 的时候，等待一会儿；</span></span><br><span class="line">        wait(maxMillisToWait);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h1><p>到这里，EventBus 就整完了，驾鹤西去呦～～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列文章主要分析 EventBus 框架的架构和原理，，基于最新的 &lt;strong&gt;3.1.0&lt;/strong&gt; 版本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是 EventBus 开源库的地址，大家可以直接访问&lt;br&gt;&lt;a href=&quot;https://github.</summary>
      
    
    
    
    <category term="开源库源码分析" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="EventBus" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/EventBus/"/>
    
    
    <category term="EventBus" scheme="https://lishuaiqi.top/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>EventBus 第三篇 - 初始化、注册和取消注册</title>
    <link href="https://lishuaiqi.top/2019/09/10/Eventbus-3-getDefaultAndRegister/"/>
    <id>https://lishuaiqi.top/2019/09/10/Eventbus-3-getDefaultAndRegister/</id>
    <published>2019-09-10T12:46:25.000Z</published>
    <updated>2019-09-16T14:13:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章主要分析 EventBus 框架的架构和原理，，基于最新的 <strong>3.1.0</strong> 版本。</p><blockquote><p>这是 EventBus 开源库的地址，大家可以直接访问<br><a href="https://github.com/greenrobot/EventBus">https://github.com/greenrobot/EventBus</a></p></blockquote><p>本篇文章是 EventBus 的第三篇，主要分析 初始化，注册和取消注册；</p><p>Eventbus 翻译过来就是事件总线，用于简化组件和组件，线程和线程之间的消息通信，可以看成是 Handler + Thread 的替代品。</p><h1 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h1><p>我们在使用的过程中，需要先进行注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure><p>当我们的组件在销毁以后，就要执行取消注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure><p>本篇文章，主要分析 register 和 unregister 的流程！</p><h1 id="2-EventBus"><a href="#2-EventBus" class="headerlink" title="2 EventBus"></a>2 EventBus</h1><p>EventBus 这个类是总的入口，我们可以通过 getDefault 返回默认配置的 EventBus，也可以通过 EventBusBuilder 去自定义配置：</p><p>EventBus 使用了单例模式！</p><h2 id="2-1-成员属性"><a href="#2-1-成员属性" class="headerlink" title="2.1 成员属性"></a>2.1 成员属性</h2><p>我们先去看看 EventBus 的成员属性，当然我们后面也会详细分析：</p><ul><li><strong>核心的变量：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 保存了 [订阅事件 class 实例 --&gt; 该事件的订阅关系的 list] 的映射关系；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"><span class="comment">// 保存了 [订阅者实例 --&gt; 订阅事件 class 的 list] 的映射关系；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"><span class="comment">// 保存了 [粘性订阅事件 class 实例 --&gt; 粘性订阅事件实例] 的映射关系，只要是已经发送过的 sticky event 都会被加入这里；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于保存每个 post 线程的状态；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> PostingThreadState <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PostingThreadState</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【--&gt;4】保存主线程的支持类，对 Looper 的封装；@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MainThreadSupport mainThreadSupport; </span><br><span class="line"></span><br><span class="line"><span class="comment">//【--&gt;4】用于分发消息；@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Poster mainThreadPoster;  <span class="comment">// 用于主线程的消息分发处理；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BackgroundPoster backgroundPoster; <span class="comment">// 用于后台线程的消息分发处理；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AsyncPoster asyncPoster; <span class="comment">// 用于异步线程的消息分发处理；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【--&gt;5】用于查找订阅方法；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SubscriberMethodFinder subscriberMethodFinder;</span><br></pre></td></tr></table></figure><ul><li><strong>其他的变量：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance; <span class="comment">//【1】EventBus 的单例对象；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EventBusBuilder</span> <span class="variable">DEFAULT_BUILDER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBusBuilder</span>(); <span class="comment">//【--&gt;3.1】默认配置的 EventBusBuilder</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService; <span class="comment">// 线程池，用于分发异步和后台的消息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> throwSubscriberException; <span class="comment">// 这些变量请参考 EventBusBuidler，这里不再多说！</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> logSubscriberExceptions;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> logNoSubscriberMessages;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> sendSubscriberExceptionEvent;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> sendNoSubscriberEvent;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> eventInheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> indexCount; <span class="comment">// subscriberInfoIndex 实例的个数；</span></span><br></pre></td></tr></table></figure><p>这里我简单的解释下：</p><ul><li>mainThreadPoster，backgroundPoster，asyncPoster 用于不同类型消息的分发，它们都是实现了 Post 接口，后面我们分析的时候再看！</li><li>currentPostingThreadState 是一个 ThreadLocal 变量，每个 post 线程都会有一个 PostingThreadState 属性，表示 post 的状态！</li><li>SubscriberMethodFinder 用于查找订阅方法；    </li></ul><h2 id="2-2-创建-EventBus-实例"><a href="#2-2-创建-EventBus-实例" class="headerlink" title="2.2 创建 EventBus 实例"></a>2.2 创建 EventBus 实例</h2><p>EventBus 提供了多种创建方式，既可以通过单例模式创建一个统一的 EventBus 对象，也可以创建多个 EventBus 实例，每个实例都是一个单独的作用域！</p><h3 id="2-2-1-getDefault"><a href="#2-2-1-getDefault" class="headerlink" title="2.2.1 getDefault"></a>2.2.1 getDefault</h3><p>单例模式方法，创建默认的 EventBus：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title function_">getDefault</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (defaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (defaultInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【--&gt;2.2.2】构造器；</span></span><br><span class="line">                defaultInstance = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-new-EventBus"><a href="#2-2-2-new-EventBus" class="headerlink" title="2.2.2 new EventBus"></a>2.2.2 new EventBus</h3><p>非单例模式方法，两个构造器，默认构造器会传入一个默认的 <code>DEFAULT_BUILDER</code>，另一个需要传入指定的 EventBusBuilder 实例；</p><p>但是，我们只能通过无参数的构造器创建非单例的  EventBus 实例！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">    ... ... ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">EventBus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//【1】默认的构造器是通过默认的 builder 对象处理的；【--&gt;2.1】默认的 buidler 实例；</span></span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_BUILDER); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】通过建造者模式来初始化，注意这个构造器是 protected 的，我们无法访问！</span></span><br><span class="line">    EventBus(EventBusBuilder builder) &#123; </span><br><span class="line">        <span class="comment">//【--&gt;3.2.3】通过 EventBusBuilder 初始化 log 系统；</span></span><br><span class="line">        logger = builder.getLogger();</span><br><span class="line">        subscriptionsByEventType = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        typesBySubscriber = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        stickyEvents = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//【--&gt;3.2.1】通过 EventBusBuilder 初始化 mainThread 相关变量；</span></span><br><span class="line">        mainThreadSupport = builder.getMainThreadSupport();</span><br><span class="line">      </span><br><span class="line">        mainThreadPoster = mainThreadSupport != <span class="literal">null</span> ? mainThreadSupport.createPoster(<span class="built_in">this</span>) : <span class="literal">null</span>;</span><br><span class="line">        backgroundPoster = <span class="keyword">new</span> <span class="title class_">BackgroundPoster</span>(<span class="built_in">this</span>);</span><br><span class="line">        asyncPoster = <span class="keyword">new</span> <span class="title class_">AsyncPoster</span>(<span class="built_in">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【--&gt;3.1】通过 EventBusBuilder 初始化 EventBus 内部的变量：</span></span><br><span class="line">        indexCount = builder.subscriberInfoIndexes != <span class="literal">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">        subscriberMethodFinder = <span class="keyword">new</span> <span class="title class_">SubscriberMethodFinder</span>(builder.subscriberInfoIndexes,</span><br><span class="line">                builder.strictMethodVerification, builder.ignoreGeneratedIndex); <span class="comment">//【--&gt;5.2】创建 SubscriberMethodFinder 对象；</span></span><br><span class="line">        logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">        logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">        throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">        eventInheritance = builder.eventInheritance;</span><br><span class="line">        executorService = builder.executorService;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过建造者模式来初始化部分变量，同时也会对其他变量做默认的初始化；</p><h3 id="2-2-3-通过-EventBusBuilder-创建"><a href="#2-2-3-通过-EventBusBuilder-创建" class="headerlink" title="2.2.3 通过 EventBusBuilder 创建"></a>2.2.3 通过 EventBusBuilder 创建</h3><p>EventBusBuilder 也提供了两个方法，通过 build 模式创建 EventBus 实例！</p><h4 id="2-2-3-1-installDefaultEventBus"><a href="#2-2-3-1-installDefaultEventBus" class="headerlink" title="2.2.3.1 installDefaultEventBus"></a>2.2.3.1 installDefaultEventBus</h4><p>单例模式方法，创建默认的 EventBus，但是如果已经创建了 EventBus 的单例，那就不能调用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> EventBus <span class="title function_">installDefaultEventBus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (EventBus.defaultInstance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Default instance already exists.&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; It may be only set once before it&#x27;s used the first time to ensure consistent behavior.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【--&gt;2.2.3.2】通过 build 方法创建单例！</span></span><br><span class="line">        EventBus.defaultInstance = build();</span><br><span class="line">        <span class="keyword">return</span> EventBus.defaultInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-2-build"><a href="#2-2-3-2-build" class="headerlink" title="2.2.3.2 build"></a>2.2.3.2 build</h4><p>这个方法可以用与创建非单例的 EventBus 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> EventBus <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;2.2.2】调用一参数构造器；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-register-注册"><a href="#2-3-register-注册" class="headerlink" title="2.3 register - 注册"></a>2.3 register - 注册</h2><p>我们来看 register  的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object subscriber)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】获取订阅者的 class 对象；</span></span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    <span class="comment">//【--&gt;5.3】查询订阅者的方法；</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;2.3.1】建立订阅关系；</span></span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体流程简单，不多说了；</p><p>注意：这里的 subscriberClass 是调用 register 方法所在的类；</p><h3 id="2-3-1-subscribe"><a href="#2-3-1-subscribe" class="headerlink" title="2.3.1 subscribe"></a>2.3.1 subscribe</h3><p>创建订阅关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】获取事件类型 eventType</span></span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    <span class="comment">//【--&gt;7.1】创建订阅关系；</span></span><br><span class="line">    <span class="type">Subscription</span> <span class="variable">newSubscription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subscription</span>(subscriber, subscriberMethod);</span><br><span class="line">    <span class="comment">//【2】获取该 eventType 对应的订阅关系的 list；</span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions == <span class="literal">null</span>) &#123;</span><br><span class="line">        subscriptions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions); <span class="comment">// 初始化操作；</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Subscriber &quot;</span> + subscriber.getClass() + <span class="string">&quot; already registered to event &quot;</span></span><br><span class="line">                    + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】调整优先级顺序，订阅关系的 list 是以 priority 从小到大排序的；</span></span><br><span class="line">    <span class="comment">// 将订阅关系加入到 subscriptionsByEventType 中；</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> subscriptions.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】将订阅者实例和要订阅的 eventType 的 class 实例保存到 subscribedEvents 中；</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="literal">null</span>) &#123;</span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents); <span class="comment">// 初始化；</span></span><br><span class="line">    &#125;</span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】方法订阅的事件是 sticky 的，特殊处理；；</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">        <span class="comment">//【5.1】如果允许事件继承，默认是为 true 的，可以去看 EventBusBuilder；</span></span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">            <span class="comment">//【5.2】获取已经存在的 sticky 事件；</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                <span class="comment">//【5.3】因为可能一个父类有多个子类，所以这里要处理所有的 sticky event。</span></span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">stickyEvent</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                    <span class="comment">//【--&gt;2.3.2】分发 sticky Event</span></span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【5.4】如果不允许事件继承，那就只能找对应类型的 sticky event。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">stickyEvent</span> <span class="operator">=</span> stickyEvents.get(eventType);</span><br><span class="line">            <span class="comment">//【--&gt;2.3.2】分发 sticky Event</span></span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程：</p><ul><li>将订阅关系保存到对应的缓存中；</li><li>处理 sticky 事件的分发；</li></ul><p>这里的 eventInheritance 是啥意思呢，其实就是事件继承关系：</p><p>比如 MessageEvent2 继承了 MessageEvent，那么如果订阅方法的参数是 MessageEvent，而粘性事件是 MessageEvent2，那么我们依然可以分发该消息；</p><h3 id="2-3-2-checkPostStickyEventToSubscription"><a href="#2-3-2-checkPostStickyEventToSubscription" class="headerlink" title="2.3.2 checkPostStickyEventToSubscription"></a>2.3.2 checkPostStickyEventToSubscription</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stickyEvent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.3.3】分发 event；</span></span><br><span class="line">        postToSubscription(newSubscription, stickyEvent, isMainThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)<br>–&gt; Strange corner case, which we don’t take care of here.</p><h3 id="2-3-3-postToSubscription"><a href="#2-3-3-postToSubscription" class="headerlink" title="2.3.3 postToSubscription"></a>2.3.3 postToSubscription</h3><p>对于 sticky event 这个和粘性广播的道理是一样，如果它之前就已经分发过，那么他会被存储在系统里，下一个订阅者一旦注册，那就能够收到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="type">boolean</span> isMainThread)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="literal">null</span>) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unknown thread mode: &quot;</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里开始事件的 post 了！</p><p>event post 这里我们不关注，后面会分析；</p><h2 id="2-4-unregister-反注册"><a href="#2-4-unregister-反注册" class="headerlink" title="2.4 unregister - 反注册"></a>2.4 unregister - 反注册</h2><p>我们来看看反注册的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(Object subscriber)</span> &#123;</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;2.4.1】解除订阅；</span></span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.log(Level.WARNING, <span class="string">&quot;Subscriber to unregister was not registered before: &quot;</span> + subscriber.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-1-unsubscribeByEventType"><a href="#2-4-1-unsubscribeByEventType" class="headerlink" title="2.4.1 unsubscribeByEventType"></a>2.4.1 unsubscribeByEventType</h3><p>这个方法很简单，就是将订阅关系移除掉；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】从 subscriptionsByEventType 返回 eventType 的所有订阅关系；</span></span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//【2】处理当前订阅者的订阅关系，设置为 no active，同时从集合中移除；</span></span><br><span class="line">            <span class="type">Subscription</span> <span class="variable">subscription</span> <span class="operator">=</span> subscriptions.get(i);</span><br><span class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                subscription.active = <span class="literal">false</span>;</span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不多说了。</p><h1 id="3-EventBusBuilder"><a href="#3-EventBusBuilder" class="headerlink" title="3 EventBusBuilder"></a>3 EventBusBuilder</h1><p>建造者模式，用于自定义 EventBus 的配置，并创建 EventBus 实例：</p><h2 id="3-1-成员变量"><a href="#3-1-成员变量" class="headerlink" title="3.1 成员变量"></a>3.1 成员变量</h2><p>我们来看下成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBusBuilder</span> &#123;</span><br><span class="line">    <span class="comment">// 内置的默认线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">DEFAULT_EXECUTOR_SERVICE</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">logSubscriberExceptions</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 是否记录订阅者的异常信息；默认为 true；</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">logNoSubscriberMessages</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// </span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">sendSubscriberExceptionEvent</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 是否发送订阅异常的事件；默认为 true；</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">sendNoSubscriberEvent</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 是否发送没有订阅者的消息；默认为 true；</span></span><br><span class="line">    <span class="type">boolean</span> throwSubscriberException; <span class="comment">// 是否抛出订阅异常，用于 debug；默认为 false；</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">eventInheritance</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 是否开启事件继承机制，默认为 true；</span></span><br><span class="line">    <span class="type">boolean</span> ignoreGeneratedIndex; <span class="comment">// 是否强制使用反射，即使开启了 Apt 特性；默认为 false；</span></span><br><span class="line">    <span class="type">boolean</span> strictMethodVerification; <span class="comment">// 是否强制方法校验；默认为 false；</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> DEFAULT_EXECUTOR_SERVICE; <span class="comment">// 线程池，用于分发异步和后台的消息；默认为 DEFAULT_EXECUTOR_SERVICE</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; skipMethodVerificationForClasses; <span class="comment">// 用于保存哪些跳过方法校验的 class</span></span><br><span class="line">    List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes; <span class="comment">// 用于保存 SubscriberInfoIndex 实例，也就是 APT 技术生成的动态 java 类；</span></span><br><span class="line">    </span><br><span class="line">    Logger logger; <span class="comment">// log 系统；</span></span><br><span class="line">    MainThreadSupport mainThreadSupport; <span class="comment">// 用于提供对主线程的支持，指向 AndroidHandlerMainThreadSupport 实例；</span></span><br><span class="line"></span><br><span class="line">    EventBusBuilder() &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果我们使用默认的 EventBusBuilder 来初始化 EventBus 的话，那么 EventBusBuilder 的方法会返回属性的默认值：</p><p>这里我简单的说下：</p><ul><li>阿道夫</li><li>安抚</li><li>党法</li></ul><h2 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2 方法"></a>3.2 方法</h2><p>前面我们顺便看了下通过 EventBusBuilder  创建 EventBus 的相关方法，这里就不再看了，我们来看下 EventBusBuilder 其中的部分方法：</p><h3 id="3-2-1-getMainThreadSupport"><a href="#3-2-1-getMainThreadSupport" class="headerlink" title="3.2.1 getMainThreadSupport"></a>3.2.1 getMainThreadSupport</h3><p>获取主线程的支持对象！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MainThreadSupport <span class="title function_">getMainThreadSupport</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mainThreadSupport != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mainThreadSupport;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AndroidLogger.isAndroidLogAvailable()) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;3.2.1.1】获取主线程的 looper 对象；</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">looperOrNull</span> <span class="operator">=</span> getAndroidMainLooperOrNull();</span><br><span class="line">        <span class="keyword">return</span> looperOrNull == <span class="literal">null</span> ? <span class="literal">null</span> :</span><br><span class="line">          <span class="comment">//【--&gt;4】创建 AndroidHandlerMainThreadSupport 实例对象；</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MainThreadSupport</span>.AndroidHandlerMainThreadSupport((Looper) looperOrNull);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-1-1-getAndroidMainLooperOrNull"><a href="#3-2-1-1-getAndroidMainLooperOrNull" class="headerlink" title="3.2.1.1 getAndroidMainLooperOrNull"></a>3.2.1.1 getAndroidMainLooperOrNull</h4><p>获取主线程的 looper 对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">getAndroidMainLooperOrNull</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Looper.getMainLooper();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不多说了。</p><h3 id="3-2-2-addIndex"><a href="#3-2-2-addIndex" class="headerlink" title="3.2.2 addIndex"></a>3.2.2 addIndex</h3><p>改方法用于将通过 EventBus 的 annotation preprocessor 生成的 SubscriberInfoIndex 子类实例，加入到 EventBusBuilder.subscriberInfoIndexes 中！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> EventBusBuilder <span class="title function_">addIndex</span><span class="params">(SubscriberInfoIndex index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (subscriberInfoIndexes == <span class="literal">null</span>) &#123;</span><br><span class="line">        subscriberInfoIndexes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    subscriberInfoIndexes.add(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不多说了。</p><h3 id="3-2-3-getLogger"><a href="#3-2-3-getLogger" class="headerlink" title="3.2.3 getLogger"></a>3.2.3 getLogger</h3><p>获取 log 系统：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Logger <span class="title function_">getLogger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> logger;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// also check main looper to see if we have &quot;good&quot; Android classes (not Stubs etc.)</span></span><br><span class="line">        <span class="keyword">return</span> AndroidLogger.isAndroidLogAvailable() &amp;&amp; getAndroidMainLooperOrNull() != <span class="literal">null</span></span><br><span class="line">                ? <span class="keyword">new</span> <span class="title class_">AndroidLogger</span>(<span class="string">&quot;EventBus&quot;</span>) :</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Logger</span>.SystemOutLogger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-MainThreadSupport"><a href="#4-MainThreadSupport" class="headerlink" title="4 MainThreadSupport"></a>4 MainThreadSupport</h1><p>是一个接口，AndroidHandlerMainThreadSupport 内部类实现了该接口，作为主线程的支持类，是对 looper 对象的封装；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MainThreadSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isMainThread</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Poster <span class="title function_">createPoster</span><span class="params">(EventBus eventBus)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AndroidHandlerMainThreadSupport</span> <span class="keyword">implements</span> <span class="title class_">MainThreadSupport</span> &#123;</span><br><span class="line">        <span class="comment">//【1】主线程的 looper 对象；</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Looper looper;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AndroidHandlerMainThreadSupport</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.looper = looper;</span><br><span class="line">        &#125;</span><br><span class="line">        ... ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们先不看 AndroidHandlerMainThreadSupport 的其他方法，后面会分析。</p><p>暂时只需要知道，AndroidHandlerMainThreadSupport 的 createPoster 方法会创建一个 <strong>HandlerPoster</strong> 实例，他是 Handler 的子类，同时实现了 Poster 接口！</p><p>看到这里，其实能猜到，HandlerPoster 会持有主线程的 Looper 对象，像主线程发送消息！！</p><h1 id="5-SubscriberMethodFinder"><a href="#5-SubscriberMethodFinder" class="headerlink" title="5 SubscriberMethodFinder"></a>5 SubscriberMethodFinder</h1><p>该类用于查找订阅者的方法：</p><h2 id="5-1-成员变量"><a href="#5-1-成员变量" class="headerlink" title="5.1 成员变量"></a>5.1 成员变量</h2><p>我们来看一些核心的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BRIDGE</span> <span class="operator">=</span> <span class="number">0x40</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SYNTHETIC</span> <span class="operator">=</span> <span class="number">0x1000</span>;</span><br><span class="line"><span class="comment">// 方法校验位。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MODIFIERS_IGNORE</span> <span class="operator">=</span> Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;</span><br><span class="line"><span class="comment">// 方法缓存，key 为订阅者的 class 实例，value 为订阅方法的 list；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下三个变量的值来自 EventBusBuilder，意思我已经解释过了；</span></span><br><span class="line"><span class="keyword">private</span> List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> strictMethodVerification;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> ignoreGeneratedIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于保存 FindState 对象，每一个 FindState 用于记录查询订阅方法的结果和状态；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">POOL_SIZE</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FindState[] FIND_STATE_POOL = <span class="keyword">new</span> <span class="title class_">FindState</span>[POOL_SIZE];</span><br></pre></td></tr></table></figure><p>这里可以看到，subscriberInfoIndexes 是要手动设置到 EventBusBuilder 中；</p><h2 id="5-2-new-SubscriberMethodFinder"><a href="#5-2-new-SubscriberMethodFinder" class="headerlink" title="5.2 new SubscriberMethodFinder"></a>5.2 new SubscriberMethodFinder</h2><ul><li>参数 <strong>List<SubscriberInfoIndex> subscriberInfoIndexes</SubscriberInfoIndex></strong>：表示 SubscriberInfoIndex 集合，就是通过 APT 技术生成的，存储了订阅方法的对象；</li><li>参数 <strong>boolean strictMethodVerification</strong>：是否强制方法校验，默认为 false；</li><li>参数 <strong>boolean ignoreGeneratedIndex</strong>：是否强制使用反射，即使开启了 APT 特性；默认为 false；</li></ul><p>以上参数值均来自于 EventBusBuilder 中的默认值/自定义值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SubscriberMethodFinder(List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes, <span class="type">boolean</span> strictMethodVerification,</span><br><span class="line">                       <span class="type">boolean</span> ignoreGeneratedIndex) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subscriberInfoIndexes = subscriberInfoIndexes;</span><br><span class="line">    <span class="built_in">this</span>.strictMethodVerification = strictMethodVerification;</span><br><span class="line">    <span class="built_in">this</span>.ignoreGeneratedIndex = ignoreGeneratedIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-findSubscriberMethods"><a href="#5-3-findSubscriberMethods" class="headerlink" title="5.3 findSubscriberMethods"></a>5.3 findSubscriberMethods</h2><p>查询订阅者拥有的订阅方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; <span class="title function_">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】默认从方法 cache 中查询；</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】如果从方法 cache中查询不到，那就判断是否不使用 GeneratedIndex；</span></span><br><span class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;5.3.1】不使用的话，就通过反射的方式访问方法；</span></span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;5.3.2】使用的话，就通过 GeneratedIndex 获取方法；</span></span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Subscriber &quot;</span> + subscriberClass</span><br><span class="line">                + <span class="string">&quot; and its super classes have no public methods with the @Subscribe annotation&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【3】加入到方法 cache 中去；</span></span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ignoreGeneratedIndex 默认是 false 的；</p><p>核心代码在 <strong>findUsingReflection</strong> 和 <strong>findUsingInfo</strong> 中！</p><h3 id="5-3-1-findUsingReflection-反射获取"><a href="#5-3-1-findUsingReflection-反射获取" class="headerlink" title="5.3.1 findUsingReflection - 反射获取"></a>5.3.1 findUsingReflection - 反射获取</h3><p>我们来看下通过反射是如何获取的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title function_">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;5.4】返回一个 FindState 对象，用于记录查询的结果和状态；</span></span><br><span class="line">    <span class="type">FindState</span> <span class="variable">findState</span> <span class="operator">=</span> prepareFindState();</span><br><span class="line">    <span class="comment">//【--&gt;6.2】初始化 FindState；</span></span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;5.5】通过发射的方式收集注解方法；</span></span><br><span class="line">        findUsingReflectionInSingleClass(findState);</span><br><span class="line">        <span class="comment">//【--&gt;6.3】处理其 superClass；</span></span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;5.6】返回所有的订阅方法；</span></span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 subscriberClass 是调用 register 方法所在的类，所以找父类肯定是向上搜索；</p><p>对于每一个调用了 register 的 class，都会创建一个 FindState 对象，保存相关信息；</p><h3 id="5-3-2-findUsingInfo-APT-获取"><a href="#5-3-2-findUsingInfo-APT-获取" class="headerlink" title="5.3.2 findUsingInfo - APT 获取"></a>5.3.2 findUsingInfo - APT 获取</h3><p>开启了 APT 预处理技术的话，那就通过动态生成的类获取，这个过程比反射更快；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title function_">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;5.4】返回一个 FindState 对象，用于记录查询的结果和状态；</span></span><br><span class="line">    <span class="type">FindState</span> <span class="variable">findState</span> <span class="operator">=</span> prepareFindState();</span><br><span class="line">    <span class="comment">//【--&gt;6.2】初始化 FindState；</span></span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;5.3.2.1】返回订阅者对应的 SubscriberInfo 实例，保存到 findState.subscriberInfo 中；</span></span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【1】返回 SubscriberInfo 的所有订阅方法 SubscriberMethod[]；</span></span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                <span class="comment">//【--&gt;6.4】对方法做检查，和反射调用一个吊样；</span></span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    <span class="comment">//【2】检查没啥问题，就加入到 findState.subscriberMethods 中；</span></span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【--&gt;5.5】如果订阅者没有对应的 SubscriberInfo 实例，通过发射的方式收集注解方法；</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【--&gt;6.3】处理其 superClass；</span></span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;5.6】返回所有的订阅方法；</span></span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里会优先获取通过 APT 技术生成的类，如果没有对应的 SubscriberInfo，那就仍然通过反射来获取方法 Method；</p><p>这里的 subscriberClass 是调用 register 方法所在的类，所以找父类肯定是向上搜索；</p><h4 id="5-3-2-1-getSubscriberInfo"><a href="#5-3-2-1-getSubscriberInfo" class="headerlink" title="5.3.2.1 getSubscriberInfo"></a>5.3.2.1 getSubscriberInfo</h4><p>返回订阅者对应的 SubscriberInfo 实例，前面我们知道 findState.subscriberInfo  在初始化的时候是 null 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SubscriberInfo <span class="title function_">getSubscriberInfo</span><span class="params">(FindState findState)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】这里是针对于继承关系的，因为是先处理子类，再处理父类，所以先处理的子类的话，findState.subscriberInfo 肯定不是 null</span></span><br><span class="line">    <span class="comment">// 那么就要通过 subscriberInfo.getSuperSubscriberInfo() 获取父类的 SubscriberInfo。</span></span><br><span class="line">    <span class="keyword">if</span> (findState.subscriberInfo != <span class="literal">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">SubscriberInfo</span> <span class="variable">superclassInfo</span> <span class="operator">=</span> findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">        <span class="comment">//【2】额外还要做一次 class 判断，因为 while 循环会调整 clazz；</span></span><br><span class="line">        <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> superclassInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】通过 subscriberInfoIndexes 来查找，getSubscriberInfo 方法是动态类的内置方法，通过 class 实例获取 SubscriberInfo；</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberInfoIndexes != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">            <span class="type">SubscriberInfo</span> <span class="variable">info</span> <span class="operator">=</span> index.getSubscriberInfo(findState.clazz);</span><br><span class="line">            <span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> info;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们知道，通过前面的分析，每一个订阅者都是一个 SubscriberInfo 实例！</p><h2 id="5-4-prepareFindState"><a href="#5-4-prepareFindState" class="headerlink" title="5.4 prepareFindState"></a>5.4 prepareFindState</h2><p>主要是为每个 find 操作，创建一个 FindState 对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> FindState <span class="title function_">prepareFindState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">            <span class="type">FindState</span> <span class="variable">state</span> <span class="operator">=</span> FIND_STATE_POOL[i];</span><br><span class="line">            <span class="keyword">if</span> (state != <span class="literal">null</span>) &#123;</span><br><span class="line">                FIND_STATE_POOL[i] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;6】返回了一个 FindState 实例；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FindState</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，<strong>FIND_STATE_POOL</strong> 是空的，所以会创建一个新的 <strong>FindState</strong> 实例；</p><h2 id="5-5-findUsingReflectionInSingleClass"><a href="#5-5-findUsingReflectionInSingleClass" class="headerlink" title="5.5 findUsingReflectionInSingleClass"></a>5.5 findUsingReflectionInSingleClass</h2><p>通过反射的方式获取注册方法，通过 SubscriberMethod 实例封装，保存到 findState.subscriberMethods 中：</p><p>参数为 FindState 实例，这里获取方法的是通过 findState.clazz，这个要注意；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> &#123;</span><br><span class="line">    Method[] methods;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【0】这个方法比 getMethods 快，特别是当订阅者是像活动这样的方法很多的类的时候；</span></span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        <span class="comment">// 可能会抛出 java.lang.NoClassDefFoundError, see [https://github.com/greenrobot/EventBus/issues/149]</span></span><br><span class="line">        <span class="comment">// 这里会使用 getMethods() 方法获取，注意，会跳过父类；</span></span><br><span class="line">        methods = findState.clazz.getMethods();</span><br><span class="line">        findState.skipSuperClasses = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> method.getModifiers();</span><br><span class="line">        <span class="comment">//【1】这里是对 method 方法访问域做校验，必须是 public，不能是 abstract 和 static 的；</span></span><br><span class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//【1.1】获取方法对应的注解 Subscribe，只处理被该注解修饰的方法;</span></span><br><span class="line">                <span class="type">Subscribe</span> <span class="variable">subscribeAnnotation</span> <span class="operator">=</span> method.getAnnotation(Subscribe.class);</span><br><span class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//【1.2】获取方法对应的参数；</span></span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">//【--&gt;6.4】检查要添加方法的信息，没问题的话，就创建方法对应的 SubscriberMethod，添加到 findState.subscriberMethods；</span></span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        <span class="comment">//【1.3】获取订阅的分发线程信息；</span></span><br><span class="line">                        <span class="type">ThreadMode</span> <span class="variable">threadMode</span> <span class="operator">=</span> subscribeAnnotation.threadMode();</span><br><span class="line">                        <span class="comment">//【1.4】创建方法对应的 SubscriberMethod，添加到 findState.subscriberMethods；</span></span><br><span class="line">                        <span class="comment">// SubscriberMethod 参数：订阅方法 method，订阅事件的 class 实例 eventType，线程模式 threadMode，优先级，粘性；</span></span><br><span class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> <span class="title class_">SubscriberMethod</span>(method, eventType, threadMode,</span><br><span class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                <span class="comment">//【2】如果开启方法校验，那么被 @Subscribe 修饰的方法只能一个参数；</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;@Subscribe method &quot;</span> + methodName +</span><br><span class="line">                        <span class="string">&quot;must have exactly 1 parameter but has &quot;</span> + parameterTypes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(methodName +</span><br><span class="line">                    <span class="string">&quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>strictMethodVerification</strong> 表示是否强制校验方法的访问修饰符；</p><h2 id="5-6-getMethodsAndRelease"><a href="#5-6-getMethodsAndRelease" class="headerlink" title="5.6 getMethodsAndRelease"></a>5.6 getMethodsAndRelease</h2><p>返回收集到的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title function_">getMethodsAndRelease</span><span class="params">(FindState findState)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】通过 FindState 获取查询到的方法；</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">    <span class="comment">//【--&gt;6.5】clear 掉缓存；</span></span><br><span class="line">    findState.recycle();</span><br><span class="line">    <span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                FIND_STATE_POOL[i] = findState; <span class="comment">// 将这个对象缓存下来，防止频繁的创建 FindState 对象；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-FindState"><a href="#6-FindState" class="headerlink" title="6 FindState"></a>6 FindState</h1><p>FindState 是 SubscriberMethodFinder 的内部类，用于保存查询的结果和状态信息（包括子类和父类）：</p><h2 id="6-1-成员变量"><a href="#6-1-成员变量" class="headerlink" title="6.1 成员变量"></a>6.1 成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FindState</span> &#123;</span><br><span class="line">    <span class="comment">// 保存订阅者的方法 SubscriberMethod；</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 保存订阅事件 class 实例 和 [订阅方法 Method/所属 FindState] 的映射关系；</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;Class, Object&gt; anyMethodByEventType = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 保存了 methodKey 和 method 所属的订阅类的 class 实例；</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Class&gt; subscriberClassByMethodKey = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 用于生成 subscriberClassByMethodKey 中的 methodKey</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">methodKeyBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; subscriberClass; <span class="comment">// 订阅者 class 实例，也就是调用 register 方法的类；</span></span><br><span class="line">    Class&lt;?&gt; clazz; <span class="comment">// 初始化时，取值和 subscriberClass 一样，但是在处理继承关系时，会转为 superClass</span></span><br><span class="line">    <span class="type">boolean</span> skipSuperClasses; <span class="comment">// 是否 skip 父类，初始化为 false；</span></span><br><span class="line">    SubscriberInfo subscriberInfo; <span class="comment">// 订阅者信息，开启了 APT 才有，否则为 null；</span></span><br></pre></td></tr></table></figure><ul><li>subscriberClassByMethodKey：如果存在继承关系，同时方法有覆盖，那么以子类为准；</li></ul><h2 id="6-2-initForSubscriber"><a href="#6-2-initForSubscriber" class="headerlink" title="6.2 initForSubscriber"></a>6.2 initForSubscriber</h2><p>初始化操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">initForSubscriber</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】初始化：subscriberClass == clazz</span></span><br><span class="line">    <span class="built_in">this</span>.subscriberClass = clazz = subscriberClass;</span><br><span class="line">    skipSuperClasses = <span class="literal">false</span>;</span><br><span class="line">    subscriberInfo = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-moveToSuperclass"><a href="#6-3-moveToSuperclass" class="headerlink" title="6.3 moveToSuperclass"></a>6.3 moveToSuperclass</h2><p>跳转到 superClass，处理父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">moveToSuperclass</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//【1】如果要跳过 superClass，那么 clazz 为 null；</span></span><br><span class="line">    <span class="keyword">if</span> (skipSuperClasses) &#123;</span><br><span class="line">        clazz = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【2】获取其 superClass；</span></span><br><span class="line">        clazz = clazz.getSuperclass();</span><br><span class="line">        <span class="type">String</span> <span class="variable">clazzName</span> <span class="operator">=</span> clazz.getName();</span><br><span class="line">        <span class="comment">//【3】跳过系统的类；</span></span><br><span class="line">        <span class="keyword">if</span> (clazzName.startsWith(<span class="string">&quot;java.&quot;</span>) || clazzName.startsWith(<span class="string">&quot;javax.&quot;</span>) || clazzName.startsWith(<span class="string">&quot;android.&quot;</span>)) &#123;</span><br><span class="line">            clazz = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不多说了；</p><h2 id="6-4-checkAdd"><a href="#6-4-checkAdd" class="headerlink" title="6.4 checkAdd"></a>6.4 checkAdd</h2><p>检查要添加方法的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】这里会将订阅事件 class 实例 --&gt; 订阅方法 Method 放入 anyMethodByEventType 中；</span></span><br><span class="line">    <span class="comment">// 同时会返回以之前已经存在的 value；</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">existing</span> <span class="operator">=</span> anyMethodByEventType.put(eventType, method);</span><br><span class="line">    <span class="keyword">if</span> (existing == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【2】如果是第一次添加，那么 check 成功，直接返回 true；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【3】如果之前添加过 eventType，说明可能一个类有多个处理该 eventType 的函数；</span></span><br><span class="line">        <span class="comment">// 也有可能是有继承关系，此时处理的是父类的方法，子类覆盖了父类的同名方法；</span></span><br><span class="line">        <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;6.4.1】检查已经添加的方法 existing 的方法签名，只有第二次处理同一个 eventType 才会进入这里</span></span><br><span class="line">            <span class="comment">// 此时该方法是会返回 true 的，因为第一次添加的 method 还没有做签名校验；</span></span><br><span class="line">            <span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType)) &#123;</span><br><span class="line">                <span class="comment">// Paranoia check</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【4】这里很奇怪，直接将之前的 Method 替换成了 FindState 实例；</span></span><br><span class="line">            <span class="comment">// 如果有多个方法都处理同一个 eventType 的话，显然 value 就不是 Method 的实例了；</span></span><br><span class="line">            anyMethodByEventType.put(eventType, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【--&gt;6.4.1】检查新添加的方法 method 的方法签名；</span></span><br><span class="line">        <span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，作者其实在注释里面也有说明：有两级的检查：</p><ul><li>第一级：检查时间类型；</li><li>第二级：检查方法签名；</li></ul><p>可能有多个处理该 eventType 的函数：</p><ul><li>只有第一次添加会进入 <code>if (existing instanceof Method) {</code> 分支；</li><li>第二次就会将 anyMethodByEventType 中的 value 从 Method 变为 FindState，那么就不会进入 <code>if (existing instanceof Method) {</code> 分支了；</li><li>无论一类多方法，还是继承一方法，都是上面的流程；</li></ul><p>（但是看作者的注释：貌似没有考虑一个订阅者有多个监听相同事件类型的方法。）</p><p>如果该 checkAdd 方法返回的是 false，那么 @Subscribe 修饰的方法就不会被收集！！！</p><h3 id="6-4-1-checkAddWithMethodSignature"><a href="#6-4-1-checkAddWithMethodSignature" class="headerlink" title="6.4.1 checkAddWithMethodSignature"></a>6.4.1 checkAddWithMethodSignature</h3><p>检查方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkAddWithMethodSignature</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> &#123;</span><br><span class="line">    methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">    methodKeyBuilder.append(method.getName());</span><br><span class="line">    methodKeyBuilder.append(<span class="string">&#x27;&gt;&#x27;</span>).append(eventType.getName());</span><br><span class="line">    <span class="comment">//【1】生成 methodKey：methodName&gt;eventTypeName</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodKey</span> <span class="operator">=</span> methodKeyBuilder.toString();</span><br><span class="line">    <span class="comment">//【2】获取方法所在的类 class 实例；</span></span><br><span class="line">    Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">    <span class="comment">//【3】将 methodKey 和 methodClass 的映射关系放入 subscriberClassByMethodKey 中，同时返回旧的 value；</span></span><br><span class="line">    Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">    <span class="comment">//【4】这里针对 old class 实例和 new class 做了比较；</span></span><br><span class="line">    <span class="comment">// 如果是第一次 add ，或者有 old class 实例，同时 old class 是 new class 的 super class</span></span><br><span class="line">    <span class="comment">// 那么就用 new class 替换旧的值；</span></span><br><span class="line">    <span class="keyword">if</span> (methodClassOld == <span class="literal">null</span> || methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">        <span class="comment">// Only add if not already found in a sub class</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Revert the put, old class is further down the class hierarchy</span></span><br><span class="line">        subscriberClassByMethodKey.put(methodKey, methodClassOld); <span class="comment">// 恢复旧的值；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实际上是方法的签名：方法名&gt;参数</p><p>对于同一个类，如果有多个函数处理同一个 eventType，显然方法签名是不一样的，那么这个 checkAddWithMethodSignature 返回的是 true；</p><p>对于继承关系，对于子类和父类有相同的方法签名的情况，以子类为准，也就是说父类的同名同参方法是不会被收集的 checkAddWithMethodSignature 返回的是 false；；</p><h2 id="6-5-recycle"><a href="#6-5-recycle" class="headerlink" title="6.5 recycle"></a>6.5 recycle</h2><p>回收内部的变量，就是 clear 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">()</span> &#123;</span><br><span class="line">    subscriberMethods.clear();</span><br><span class="line">    anyMethodByEventType.clear();</span><br><span class="line">    subscriberClassByMethodKey.clear();</span><br><span class="line">    methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">    subscriberClass = <span class="literal">null</span>;</span><br><span class="line">    clazz = <span class="literal">null</span>;</span><br><span class="line">    skipSuperClasses = <span class="literal">false</span>;</span><br><span class="line">    subscriberInfo = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就不多说了，啊哈哈哈哈哈～～</p><h1 id="7-Subscription"><a href="#7-Subscription" class="headerlink" title="7 Subscription"></a>7 Subscription</h1><p>表示一种订阅关系；</p><h2 id="7-1-成员变量"><a href="#7-1-成员变量" class="headerlink" title="7.1 成员变量"></a>7.1 成员变量</h2><p>我们来看下成员属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Subscription</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object subscriber; <span class="comment">// 订阅者；</span></span><br><span class="line">    <span class="keyword">final</span> SubscriberMethod subscriberMethod; <span class="comment">// 订阅方法；</span></span><br></pre></td></tr></table></figure><h2 id="7-2-new-Subscription"><a href="#7-2-new-Subscription" class="headerlink" title="7.2 new Subscription"></a>7.2 new Subscription</h2><p>创建订阅关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subscription(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subscriber = subscriber; <span class="comment">// 订阅者；</span></span><br><span class="line">    <span class="built_in">this</span>.subscriberMethod = subscriberMethod; <span class="comment">// 订阅方法；</span></span><br><span class="line">    active = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h1><p>我们分析了 EventBus 的创建，注册和反注册，整个初始化和注册的过程主要分为下面的基本：</p><ul><li>通过 EventBusBuilder 创建 EventBus；</li><li>EventBus 收集当前类以及其父类所有的订阅方法；</li><li>根据事件类型和每一个订阅方法，创建订阅关系；</li></ul><p>遗留了如下的几个问题：</p><ul><li>post 操作的执行流程；</li><li>不同线程模式的消息是如何分发和处理的；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列文章主要分析 EventBus 框架的架构和原理，，基于最新的 &lt;strong&gt;3.1.0&lt;/strong&gt; 版本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是 EventBus 开源库的地址，大家可以直接访问&lt;br&gt;&lt;a href=&quot;https://github.</summary>
      
    
    
    
    <category term="开源库源码分析" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="EventBus" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/EventBus/"/>
    
    
    <category term="EventBus" scheme="https://lishuaiqi.top/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>EventBus 第二篇 - Subscribe 注解处理</title>
    <link href="https://lishuaiqi.top/2019/08/27/Eventbus-2-SubscribeProcessor/"/>
    <id>https://lishuaiqi.top/2019/08/27/Eventbus-2-SubscribeProcessor/</id>
    <published>2019-08-27T12:46:25.000Z</published>
    <updated>2019-09-16T14:13:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章主要分析 EventBus 框架的架构和原理，，基于最新的 <strong>3.1.0</strong> 版本。</p><blockquote><p>这是 EventBus 开源库的地址，大家可以直接访问<br><a href="https://github.com/greenrobot/EventBus">https://github.com/greenrobot/EventBus</a></p></blockquote><p>本篇文章是 EventBus 的第二篇，主要分析 Subscribe 注解的处理；</p><p>Eventbus 翻译过来就是事件总线，用于简化组件和组件，线程和线程之间的消息通信，可以捆成是 Handler + Thread 的替代品。</p><h1 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h1><p>我们在使用的过程中，需要设置接收消息的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEventMainThread</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">   ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解  Subscribe 可以说是 EventBus 的核心了，我们知道，3.x 版本之前，EventBus 使用的是运行时注解，其实就是 Java 的反射机制，但是这带来了性能的损耗！</p><p>因此，从 3.x 开始，Eventbus 引入了编译时注解处理的特性，核心类就是 EventBusAnnotationProcessor！ </p><p>我们来看看注解的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;</span><br><span class="line">    ThreadMode <span class="title function_">threadMode</span><span class="params">()</span> <span class="keyword">default</span> ThreadMode.POSTING; <span class="comment">// 线程模型：默认 POSTING</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">sticky</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>; <span class="comment">// 默认非粘性；</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">priority</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>; <span class="comment">// 优先级为 0；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Subscribe 用于修饰方法，并且可以保留到运行时，这是因为默认情况下，EventBus 是通过运行时注解，反射加载方法的，除非开启编译时注解处理机制；</p><h1 id="2-EventBusAnnotationProcessor-Subscribe-处理"><a href="#2-EventBusAnnotationProcessor-Subscribe-处理" class="headerlink" title="2 EventBusAnnotationProcessor - Subscribe 处理"></a>2 EventBusAnnotationProcessor - Subscribe 处理</h1><p>浏览 EventBus 的源码目录，我们能看到处理 Subscribe 注解的是 EventBusAnnotationProcessor 类，依然是编译时注解，动态生成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes(&quot;org.greenrobot.eventbus.Subscribe&quot;)</span></span><br><span class="line"><span class="meta">@SupportedOptions(value = &#123;&quot;eventBusIndex&quot;, &quot;verbose&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBusAnnotationProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br></pre></td></tr></table></figure><p>可以看到，它支持的只有一个注解：Subscribe</p><p>同时他支持两个配置属性：</p><ul><li>eventBusIndex：是否开启编译时注解处理，这个特性是 3.x 版本新增的，也就是将运行时的处理放到了编译时注解处理，动态生成 java 代码，用于提升框架的性能；</li><li>verbose：用于控制 log，调试使用；</li></ul><p>这两个属性是在 gradle 中配置的；</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [<span class="attr">eventBusIndex:</span><span class="string">&#x27;com.monster.android.wild.MyEventBusIndex&#x27;</span>, <span class="attr">verbose :</span> <span class="string">&quot;true&quot;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api <span class="string">&#x27;org.greenrobot:eventbus:3.1.0&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.greenrobot:eventbus-annotation-processor:3.0.1&#x27;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>我们在下面的分析中就能看到，注解处理器对于这几个参数的处理：</p><h2 id="2-1-成员变量"><a href="#2-1-成员变量" class="headerlink" title="2.1 成员变量"></a>2.1 成员变量</h2><p>EventBusAnnotationProcessor 内部如下的变量和常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OPTION_EVENT_BUS_INDEX</span> <span class="operator">=</span> <span class="string">&quot;eventBusIndex&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OPTION_VERBOSE</span> <span class="operator">=</span> <span class="string">&quot;verbose&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面的变量用于获取 gradle 的环境变量；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存订阅者（类）和其订阅方法（注解修饰的方法）的映射关系；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ListMap&lt;TypeElement, ExecutableElement&gt; methodsByClass = <span class="keyword">new</span> <span class="title class_">ListMap</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">// 保存需要跳过的订阅者</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;TypeElement&gt; classesToSkip = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> writerRoundDone;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> round;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> verbose;</span><br></pre></td></tr></table></figure><h2 id="2-2-process"><a href="#2-2-process" class="headerlink" title="2.2 process"></a>2.2 process</h2><p>依然是核心方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span> &#123;</span><br><span class="line">  <span class="type">Messager</span> <span class="variable">messager</span> <span class="operator">=</span> processingEnv.getMessager();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//【1】获取 eventBusIndex 编译属性，并判断是否有设置这个，没有的话就不处理；</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">index</span> <span class="operator">=</span> processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="literal">null</span>) &#123;</span><br><span class="line">      messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">&quot;No option &quot;</span> + OPTION_EVENT_BUS_INDEX +</span><br><span class="line">                            <span class="string">&quot; passed to annotation processor&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】判断是否要输出 log；</span></span><br><span class="line">    verbose = Boolean.parseBoolean(processingEnv.getOptions().get(OPTION_VERBOSE));</span><br><span class="line">    <span class="comment">//【3】获取动态创建的 java 类的类名；</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastPeriod</span> <span class="operator">=</span> index.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">indexPackage</span> <span class="operator">=</span> lastPeriod != -<span class="number">1</span> ? index.substring(<span class="number">0</span>, lastPeriod) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    round++;</span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">      messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">&quot;Processing round &quot;</span> + round + <span class="string">&quot;, new annotations: &quot;</span> +</span><br><span class="line">                            !annotations.isEmpty() + <span class="string">&quot;, processingOver: &quot;</span> + env.processingOver());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (env.processingOver()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!annotations.isEmpty()) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR,</span><br><span class="line">                              <span class="string">&quot;Unexpected processing state: annotations still available after processing over&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (annotations.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (writerRoundDone) &#123;</span><br><span class="line">      messager.printMessage(Diagnostic.Kind.ERROR,</span><br><span class="line">                            <span class="string">&quot;Unexpected processing state: annotations still available after writing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;2.2.1】收集注解 Subscribe 修饰的元素；</span></span><br><span class="line">    collectSubscribers(annotations, env, messager);</span><br><span class="line">    <span class="comment">//【--&gt;2.2.2】检查某些注解是否要忽略；</span></span><br><span class="line">    checkForSubscribersToSkip(messager, indexPackage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!methodsByClass.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">//【--&gt;2.2.3】如果收集到了被注解修饰的方法，那么就动态创建 java 类；</span></span><br><span class="line">      createInfoIndexFile(index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      messager.printMessage(Diagnostic.Kind.WARNING, <span class="string">&quot;No @Subscribe annotations found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    writerRoundDone = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">&quot;Unexpected error in EventBusAnnotationProcessor: &quot;</span> + e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程很简单，不多 say；</p><h3 id="2-2-1-collectSubscribers-收集"><a href="#2-2-1-collectSubscribers-收集" class="headerlink" title="2.2.1 collectSubscribers - 收集"></a>2.2.1 collectSubscribers - 收集</h3><p>收集注解 Subscribe 修饰的元素；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">collectSubscribers</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env, Messager messager)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeElement annotation : annotations) &#123;</span><br><span class="line">        Set&lt;? <span class="keyword">extends</span> <span class="title class_">Element</span>&gt; elements = env.getElementsAnnotatedWith(annotation); <span class="comment">// 获得 Subscribe 修饰的所有元素；</span></span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element <span class="keyword">instanceof</span> ExecutableElement) &#123;</span><br><span class="line">                <span class="type">ExecutableElement</span> <span class="variable">method</span> <span class="operator">=</span> (ExecutableElement) element;</span><br><span class="line">                <span class="comment">//【--&gt;2.2.1.1】检查注解修饰的方法是否满足条件；</span></span><br><span class="line">                <span class="keyword">if</span> (checkHasNoErrors(method, messager)) &#123;</span><br><span class="line">                    <span class="comment">//【1】获得方法所属的类元素，加入到 methodsByClass 哈希表中；</span></span><br><span class="line">                    <span class="type">TypeElement</span> <span class="variable">classElement</span> <span class="operator">=</span> (TypeElement) method.getEnclosingElement();</span><br><span class="line">                    methodsByClass.putElement(classElement, method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">&quot;@Subscribe is only valid for methods&quot;</span>, element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-1-1-checkHasNoErrors"><a href="#2-2-1-1-checkHasNoErrors" class="headerlink" title="2.2.1.1 checkHasNoErrors"></a>2.2.1.1 checkHasNoErrors</h4><p>检查是否有错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkHasNoErrors</span><span class="params">(ExecutableElement element, Messager messager)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】方法不能是 static 的；</span></span><br><span class="line">    <span class="keyword">if</span> (element.getModifiers().contains(Modifier.STATIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">&quot;Subscriber method must not be static&quot;</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】方法必须是 public 的；</span></span><br><span class="line">    <span class="keyword">if</span> (!element.getModifiers().contains(Modifier.PUBLIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">&quot;Subscriber method must be public&quot;</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】方法必须至少有一个 param；</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">VariableElement</span>&gt; parameters = ((ExecutableElement) element).getParameters();</span><br><span class="line">    <span class="keyword">if</span> (parameters.size() != <span class="number">1</span>) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">&quot;Subscriber method must have exactly 1 parameter&quot;</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不多说；</p><h3 id="2-2-2-checkForSubscribersToSkip"><a href="#2-2-2-checkForSubscribersToSkip" class="headerlink" title="2.2.2 checkForSubscribersToSkip"></a>2.2.2 checkForSubscribersToSkip</h3><p>跳过一些订阅者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkForSubscribersToSkip</span><span class="params">(Messager messager, String myPackage)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】遍历收集到所有的订阅者；</span></span><br><span class="line">    <span class="keyword">for</span> (TypeElement skipCandidate : methodsByClass.keySet()) &#123;</span><br><span class="line">        <span class="type">TypeElement</span> <span class="variable">subscriberClass</span> <span class="operator">=</span> skipCandidate;</span><br><span class="line">        <span class="keyword">while</span> (subscriberClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;2.2.2.1】判断下注解方法所属的类是否满足条件，如果不满足，加入到 classesToSkip 跳过；</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisible(myPackage, subscriberClass)) &#123;</span><br><span class="line">                <span class="comment">//【2】将要跳过的 class 加入到 classesToSkip 集合中；</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">added</span> <span class="operator">=</span> classesToSkip.add(skipCandidate);</span><br><span class="line">                <span class="keyword">if</span> (added) &#123;</span><br><span class="line">                    String msg;</span><br><span class="line">                    <span class="keyword">if</span> (subscriberClass.equals(skipCandidate)) &#123; <span class="comment">// 是当前类，还是父类呢？</span></span><br><span class="line">                        msg = <span class="string">&quot;Falling back to reflection because class is not public&quot;</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        msg = <span class="string">&quot;Falling back to reflection because &quot;</span> + skipCandidate +</span><br><span class="line">                                <span class="string">&quot; has a non-public super class&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    messager.printMessage(Diagnostic.Kind.NOTE, msg, subscriberClass);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【3】处理类（包括父类）所有的注解方法：</span></span><br><span class="line">            List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberClass);</span><br><span class="line">            <span class="keyword">if</span> (methods != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【3.1】遍历该类的注解方法，处理方法的参数；</span></span><br><span class="line">                <span class="keyword">for</span> (ExecutableElement method : methods) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">skipReason</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//【3.2】获取注解方法的第一个参数（意味着第一个参数必须是消息对象）</span></span><br><span class="line">                    <span class="type">VariableElement</span> <span class="variable">param</span> <span class="operator">=</span> method.getParameters().get(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//【--&gt;2.2.2.2】获取被注解方法的参数类型；</span></span><br><span class="line">                    <span class="type">TypeMirror</span> <span class="variable">typeMirror</span> <span class="operator">=</span> getParamTypeMirror(param, messager);</span><br><span class="line">                    <span class="comment">//【3.3】如果参数的类型不是类/接口，那么就跳过该类；</span></span><br><span class="line">                    <span class="keyword">if</span> (!(typeMirror <span class="keyword">instanceof</span> DeclaredType) ||</span><br><span class="line">                            !(((DeclaredType) typeMirror).asElement() <span class="keyword">instanceof</span> TypeElement)) &#123;</span><br><span class="line">                        skipReason = <span class="string">&quot;event type cannot be processed&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//【3.4】如果上面满足条件，那就判断下参数是否可以访问；</span></span><br><span class="line">                    <span class="keyword">if</span> (skipReason == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">TypeElement</span> <span class="variable">eventTypeElement</span> <span class="operator">=</span> (TypeElement) ((DeclaredType) typeMirror).asElement();</span><br><span class="line">                        <span class="comment">//【--&gt;2.2.2.1】判断下注解方法所属的类是否满足条件，如果不满足，加入到 classesToSkip 跳过；</span></span><br><span class="line">                        <span class="keyword">if</span> (!isVisible(myPackage, eventTypeElement)) &#123;</span><br><span class="line">                            skipReason = <span class="string">&quot;event type is not public&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (skipReason != <span class="literal">null</span>) &#123;</span><br><span class="line">                         <span class="comment">//【3.2】将要跳过的 class 加入到 classesToSkip 集合中；</span></span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">added</span> <span class="operator">=</span> classesToSkip.add(skipCandidate);</span><br><span class="line">                        <span class="keyword">if</span> (added) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Falling back to reflection because &quot;</span> + skipReason;</span><br><span class="line">                            <span class="keyword">if</span> (!subscriberClass.equals(skipCandidate)) &#123;</span><br><span class="line">                                msg += <span class="string">&quot; (found in super class for &quot;</span> + skipCandidate + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            messager.printMessage(Diagnostic.Kind.NOTE, msg, param);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【--&gt;2.2.2.3】获取其父类对应的元素，然后 while 循环继续处理其 super class；</span></span><br><span class="line">            subscriberClass = getSuperclass(subscriberClass); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，默认我们获得的是注解方法所在的当前类，但是 while 循环还会继续处理其父类；</p><ul><li>先处理子类，再处理父类；</li><li>被注解的方法的第一个参数必须是要处理的消息；</li><li>消息类型必须是类/接口的实现；</li></ul><h4 id="2-2-2-1-isVisible"><a href="#2-2-2-1-isVisible" class="headerlink" title="2.2.2.1 isVisible"></a>2.2.2.1 isVisible</h4><p>用来判断注解方法所属的类是否满足条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isVisible</span><span class="params">(String myPackage, TypeElement typeElement)</span> &#123;</span><br><span class="line">    Set&lt;Modifier&gt; modifiers = typeElement.getModifiers();</span><br><span class="line">    <span class="type">boolean</span> visible;</span><br><span class="line">    <span class="comment">//【1】该类必须是 public 的；</span></span><br><span class="line">    <span class="keyword">if</span> (modifiers.contains(Modifier.PUBLIC)) &#123;</span><br><span class="line">        visible = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//【2】该类不能是 private/protected 的；</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (modifiers.contains(Modifier.PRIVATE) || modifiers.contains(Modifier.PROTECTED)) &#123;</span><br><span class="line">        visible = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【3】默认访问权限；</span></span><br><span class="line">        <span class="comment">//【--&gt;2.2.2.1.1】获得注解方法所属类的包元素名（包名）；</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">subscriberPackage</span> <span class="operator">=</span> getPackageElement(typeElement).getQualifiedName().toString();</span><br><span class="line">        <span class="keyword">if</span> (myPackage == <span class="literal">null</span>) &#123;</span><br><span class="line">            visible = subscriberPackage.length() == <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 正常情况进入这里：</span></span><br><span class="line">            <span class="comment">//【3】就是说注解方法所说的类必须和 eventBusIndex 指定的要动态生成的 java 类属于同一个包下；</span></span><br><span class="line">            visible = myPackage.equals(subscriberPackage); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数 myPackage</strong> 是我们 eventBusIndex 指定的要动态生成的 java 类的 class Name；</p><p><strong>参数 TypeElement typeElement</strong> 则是注解方法所在的类元素；</p><p>可以看到，注解方法所属的类必须要满足一下的条件：</p><ul><li>如果是 <strong>public</strong>，那就是可见的 visible 为 true；</li><li>如果是 <strong>private/protected</strong>，那就是不可见的；</li><li>如果是 <strong>default</strong>，那么 必须和 <strong>eventBusIndex</strong> 指定的要动态生成的 <strong>java</strong> 类属于同一个包下；</li></ul><h5 id="2-2-2-1-1-getPackageElement"><a href="#2-2-2-1-1-getPackageElement" class="headerlink" title="2.2.2.1.1 getPackageElement"></a>2.2.2.1.1 getPackageElement</h5><p>获得注解方法所属类的包元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PackageElement <span class="title function_">getPackageElement</span><span class="params">(TypeElement subscriberClass)</span> &#123;</span><br><span class="line">    <span class="type">Element</span> <span class="variable">candidate</span> <span class="operator">=</span> subscriberClass.getEnclosingElement();</span><br><span class="line">    <span class="comment">//【1】这里的 while 不断循环处理，直到 candidate 是一个包元素；</span></span><br><span class="line">    <span class="keyword">while</span> (!(candidate <span class="keyword">instanceof</span> PackageElement)) &#123;</span><br><span class="line">        candidate = candidate.getEnclosingElement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PackageElement) candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了 <strong>TypeElement. getenclosingelement()</strong> 的方法：</p><blockquote><p>返回封装此元素（非严格意义上）的最里层元素。</p><p>如果此元素的声明在词法上直接封装在另一个元素的声明中，则返回那个封装元素。<br>如果此元素是顶层类型，则返回它的包。<br>如果此元素是一个包，则返回 null。<br>如果此元素是一个类型参数，则返回 null。</p></blockquote><h4 id="2-2-2-2-getParamTypeMirror"><a href="#2-2-2-2-getParamTypeMirror" class="headerlink" title="2.2.2.2 getParamTypeMirror"></a>2.2.2.2 getParamTypeMirror</h4><p>获取注解方法的参数的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TypeMirror <span class="title function_">getParamTypeMirror</span><span class="params">(VariableElement param, Messager messager)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】获取参数的类型；</span></span><br><span class="line">    <span class="type">TypeMirror</span> <span class="variable">typeMirror</span> <span class="operator">=</span> param.asType();</span><br><span class="line">    <span class="comment">// Check for generic type</span></span><br><span class="line">    <span class="keyword">if</span> (typeMirror <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">        <span class="comment">//【1.1】判断参数类型是否有上边界，如果有的话，那就使用上边界为参数类型；</span></span><br><span class="line">        <span class="type">TypeMirror</span> <span class="variable">upperBound</span> <span class="operator">=</span> ((TypeVariable) typeMirror).getUpperBound();</span><br><span class="line">        <span class="keyword">if</span> (upperBound <span class="keyword">instanceof</span> DeclaredType) &#123; <span class="comment">// 上边界是类或接口类型；</span></span><br><span class="line">            <span class="keyword">if</span> (messager != <span class="literal">null</span>) &#123;</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">&quot;Using upper bound type &quot;</span> + upperBound +</span><br><span class="line">                        <span class="string">&quot; for generic parameter&quot;</span>, param);</span><br><span class="line">            &#125;</span><br><span class="line">            typeMirror = upperBound; <span class="comment">// 就将上边界类型作为参数类型：</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> typeMirror;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们用到了这个方法 <strong>TypeVariable.getUpperBound()</strong></p><blockquote><p>返回：此类型变量的上边界</p><p>如果此类型变量被声明为没有明确上边界，则结果为 <code>java.lang.object</code>。<br>如果此类型变量被声明为有多个上边界，则结果是一个交集类型（建模为 <code>declaredtype</code>）。<br>通过检查结果的超类型，可以发现个别边界。</p></blockquote><p>这个是什么意思呢？举个简单的栗子，下面是我们的消息类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseMessage</span> &#123;&#125; <span class="comment">// 返回上边界 BaseMessage，为了使用多态；</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span>&lt;T&gt; &#123;&#125;      <span class="comment">// 返回 Message 对应的类型；</span></span><br></pre></td></tr></table></figure><p>这样解释就简单了吧！</p><h4 id="2-2-2-3-getSuperclass"><a href="#2-2-2-3-getSuperclass" class="headerlink" title="2.2.2.3 getSuperclass"></a>2.2.2.3 getSuperclass</h4><p>获取当前类的父类元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TypeElement <span class="title function_">getSuperclass</span><span class="params">(TypeElement type)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】如果当前元素类型是类或者接口，才会获取父类；</span></span><br><span class="line">    <span class="keyword">if</span> (type.getSuperclass().getKind() == TypeKind.DECLARED) &#123;</span><br><span class="line">        <span class="comment">//【1.1】获取其直接父类；</span></span><br><span class="line">        <span class="type">TypeElement</span> <span class="variable">superclass</span> <span class="operator">=</span> (TypeElement) processingEnv.getTypeUtils().asElement(type.getSuperclass());</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> superclass.getQualifiedName().toString();</span><br><span class="line">        <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;java.&quot;</span>) || name.startsWith(<span class="string">&quot;javax.&quot;</span>) || name.startsWith(<span class="string">&quot;android.&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//【1.1.1】过滤掉 java/javax/android 系统类；</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> superclass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeKind 是枚举，保存了 Java 定义的所有的类型数据！</p><h3 id="2-2-3-createInfoIndexFile"><a href="#2-2-3-createInfoIndexFile" class="headerlink" title="2.2.3 createInfoIndexFile"></a>2.2.3 createInfoIndexFile</h3><p>动态生成 java 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createInfoIndexFile</span><span class="params">(String index)</span> &#123;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】创建 JavaFileObject 对象，用于生成 java 类；</span></span><br><span class="line">        <span class="type">JavaFileObject</span> <span class="variable">sourceFile</span> <span class="operator">=</span> processingEnv.getFiler().createSourceFile(index);</span><br><span class="line">        <span class="comment">//【2】生成 java 包名（eventBusIndex 最后一个 . 前面的字符串）和 java 类名（eventBusIndex 最后一个 . 后面的字符串）；</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">period</span> <span class="operator">=</span> index.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">myPackage</span> <span class="operator">=</span> period &gt; <span class="number">0</span> ? index.substring(<span class="number">0</span>, period) : <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clazz</span> <span class="operator">=</span> index.substring(period + <span class="number">1</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(sourceFile.openWriter());</span><br><span class="line">        <span class="keyword">if</span> (myPackage != <span class="literal">null</span>) &#123;</span><br><span class="line">            writer.write(<span class="string">&quot;package &quot;</span> + myPackage + <span class="string">&quot;;\n\n&quot;</span>); <span class="comment">// 动态 java 类的包名；</span></span><br><span class="line">        &#125;</span><br><span class="line">        writer.write(<span class="string">&quot;import org.greenrobot.eventbus.meta.SimpleSubscriberInfo;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import org.greenrobot.eventbus.meta.SubscriberMethodInfo;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import org.greenrobot.eventbus.meta.SubscriberInfo;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import org.greenrobot.eventbus.meta.SubscriberInfoIndex;\n\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import org.greenrobot.eventbus.ThreadMode;\n\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import java.util.HashMap;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;import java.util.Map;\n\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;/** This class is generated by EventBus, do not edit. */\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;public class &quot;</span> + clazz + <span class="string">&quot; implements SubscriberInfoIndex &#123;\n&quot;</span>); <span class="comment">// 动态 java 类的类名</span></span><br><span class="line">        writer.write(<span class="string">&quot;    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;\n\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;    static &#123;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;        SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();\n\n&quot;</span>);</span><br><span class="line">        <span class="comment">//【--&gt;2.2.3.1】写入注解生成的信息；</span></span><br><span class="line">        writeIndexLines(writer, myPackage);</span><br><span class="line">        writer.write(<span class="string">&quot;    &#125;\n\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;    private static void putIndex(SubscriberInfo info) &#123;\n&quot;</span>); <span class="comment">// 写入内部的 putIndex 方法；</span></span><br><span class="line">        writer.write(<span class="string">&quot;        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;    &#125;\n\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;    @Override\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;\n&quot;</span>); <span class="comment">// 写入的 getSubscriberInfo 方法；</span></span><br><span class="line">        writer.write(<span class="string">&quot;        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;        if (info != null) &#123;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;            return info;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;        &#125; else &#123;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;            return null;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;        &#125;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;    &#125;\n&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Could not write source for &quot;</span> + index, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (writer != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">//Silent</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码有些 low，竟然是硬编码写进去的；</p><p>生成了的代码会涉及到如下的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.greenrobot.eventbus.meta.SimpleSubscriberInfo;</span><br><span class="line"><span class="keyword">import</span> org.greenrobot.eventbus.meta.SubscriberMethodInfo;</span><br><span class="line"><span class="keyword">import</span> org.greenrobot.eventbus.meta.SubscriberInfo;</span><br><span class="line"><span class="keyword">import</span> org.greenrobot.eventbus.meta.SubscriberInfoIndex;</span><br><span class="line"><span class="keyword">import</span> org.greenrobot.eventbus.ThreadMode;</span><br></pre></td></tr></table></figure><p>可以看到，这几个类定义在 eventbus 模块里，简单的说下：</p><ul><li><strong>SimpleSubscriberInfo</strong>：表示一个订阅者，就是 Subscribe 注解所在的类；</li><li><strong>SubscriberMethodInfo</strong>：表示一个订阅方法，就是 Subscribe 注解的方法；</li><li><strong>SubscriberInfo</strong>：接口，SimpleSubscriberInfo 继承了 AbstractSubscriberInfo，而 AbstractSubscriberInfo 实现了  SubscriberInfo 接口，<strong>适配器模式</strong>；</li><li><strong>SubscriberInfoIndex</strong>：接口，我们动态生成的 Java 类，实现了该接口；</li><li><strong>ThreadMode</strong>：枚举类型，表示线程类型；</li></ul><p>这里我们不多关注；</p><h4 id="2-2-3-1-writeIndexLines"><a href="#2-2-3-1-writeIndexLines" class="headerlink" title="2.2.3.1 writeIndexLines"></a>2.2.3.1 writeIndexLines</h4><p>这里就是将 methodsByClass 中收集到的信息写入到动态 java 类中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeIndexLines</span><span class="params">(BufferedWriter writer, String myPackage)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//【1】遍历 methodsByClass 哈希表，跳过 classesToSkip 中的元素；</span></span><br><span class="line">    <span class="keyword">for</span> (TypeElement subscriberTypeElement : methodsByClass.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (classesToSkip.contains(subscriberTypeElement)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【--&gt;2.2.3.1.1】获得注解方法所在的类名；</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">subscriberClass</span> <span class="operator">=</span> getClassString(subscriberTypeElement, myPackage);</span><br><span class="line">        <span class="comment">//【--&gt;2.2.2.1】判断下动态 java 类所在的包是否可以访问注解所在类，可以的话，才写入！ </span></span><br><span class="line">        <span class="keyword">if</span> (isVisible(myPackage, subscriberTypeElement)) &#123;</span><br><span class="line">            writeLine(writer, <span class="number">2</span>,</span><br><span class="line">                    <span class="string">&quot;putIndex(new SimpleSubscriberInfo(&quot;</span> + subscriberClass + <span class="string">&quot;.class,&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;true,&quot;</span>, <span class="string">&quot;new SubscriberMethodInfo[] &#123;&quot;</span>); <span class="comment">// 这个我就不分析了，一行一行的写入呗；</span></span><br><span class="line">            <span class="comment">//【2】获取注解的方法；</span></span><br><span class="line">            List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberTypeElement);</span><br><span class="line">            <span class="comment">//【--&gt;2.2.3.1.2】将方法信息写入到 java 类中；</span></span><br><span class="line">            writeCreateSubscriberMethods(writer, methods, <span class="string">&quot;new SubscriberMethodInfo&quot;</span>, myPackage);</span><br><span class="line">            writer.write(<span class="string">&quot;        &#125;));\n\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writer.write(<span class="string">&quot;        // Subscriber not visible to index: &quot;</span> + subscriberClass + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数表示的是否检查父类：<strong>shouldCheckSuperclass</strong>，传入的是 true；</p><h5 id="2-2-3-1-1-getClassString"><a href="#2-2-3-1-1-getClassString" class="headerlink" title="2.2.3.1.1 getClassString"></a>2.2.3.1.1 getClassString</h5><p>获取类名；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">getClassString</span><span class="params">(TypeElement typeElement, String myPackage)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;2.2.2.1.1】获取注解所在的类的包元素；</span></span><br><span class="line">    <span class="type">PackageElement</span> <span class="variable">packageElement</span> <span class="operator">=</span> getPackageElement(typeElement);</span><br><span class="line">    <span class="comment">//【1】获取所在包名；</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">packageString</span> <span class="operator">=</span> packageElement.getQualifiedName().toString();</span><br><span class="line">    <span class="comment">//【2】获取类的全限定名；</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> typeElement.getQualifiedName().toString();</span><br><span class="line">    <span class="keyword">if</span> (packageString != <span class="literal">null</span> &amp;&amp; !packageString.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (packageString.equals(myPackage)) &#123;</span><br><span class="line">            <span class="comment">//【3】如果注解所在的类和动态生成的 java 类的包名一样；就截掉全限定名的包名部分（因为在同一个包嘛）</span></span><br><span class="line">            className = cutPackage(myPackage, className);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packageString.equals(<span class="string">&quot;java.lang&quot;</span>)) &#123;</span><br><span class="line">            className = typeElement.getSimpleName().toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> className;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用内部的 cutPackage 去截取类名！</p><p>代码简单，就 String 的基本操作。。。</p><h5 id="2-2-3-1-2-writeCreateSubscriberMethods"><a href="#2-2-3-1-2-writeCreateSubscriberMethods" class="headerlink" title="2.2.3.1.2 writeCreateSubscriberMethods"></a>2.2.3.1.2 writeCreateSubscriberMethods</h5><p>将方法信息写入到 java 类中，参数 <strong>String callPrefix</strong> 的值：”new SubscriberMethodInfo”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeCreateSubscriberMethods</span><span class="params">(BufferedWriter writer, List&lt;ExecutableElement&gt; methods,</span></span><br><span class="line"><span class="params">                                          String callPrefix, String myPackage)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//【1】遍历方法 list；</span></span><br><span class="line">    <span class="keyword">for</span> (ExecutableElement method : methods) &#123;</span><br><span class="line">        List&lt;? <span class="keyword">extends</span> <span class="title class_">VariableElement</span>&gt; parameters = method.getParameters();</span><br><span class="line">        <span class="type">TypeMirror</span> <span class="variable">paramType</span> <span class="operator">=</span> getParamTypeMirror(parameters.get(<span class="number">0</span>), <span class="literal">null</span>); <span class="comment">//【--&gt;2.2.2.2】注解方法的参数的类型;</span></span><br><span class="line">        <span class="type">TypeElement</span> <span class="variable">paramElement</span> <span class="operator">=</span> (TypeElement) processingEnv.getTypeUtils().asElement(paramType);</span><br><span class="line">        <span class="comment">//【1.1】获取方法名；</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getSimpleName().toString();</span><br><span class="line">        <span class="comment">//【--&gt;2.2.3.1.2】获取方法参数（事件）的类名；</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">eventClass</span> <span class="operator">=</span> getClassString(paramElement, myPackage) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1.3】获取 Subscribe 注解对象；</span></span><br><span class="line">        <span class="type">Subscribe</span> <span class="variable">subscribe</span> <span class="operator">=</span> method.getAnnotation(Subscribe.class);</span><br><span class="line">        List&lt;String&gt; parts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        parts.add(callPrefix + <span class="string">&quot;(\&quot;&quot;</span> + methodName + <span class="string">&quot;\&quot;,&quot;</span>); <span class="comment">//【1.4】第一个参数：methodName；</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lineEnd</span> <span class="operator">=</span> <span class="string">&quot;),&quot;</span>;</span><br><span class="line">        <span class="comment">//【1.5】处理注解的 priority、sticky、threadMode 属性；</span></span><br><span class="line">        <span class="keyword">if</span> (subscribe.priority() == <span class="number">0</span> &amp;&amp; !subscribe.sticky()) &#123; <span class="comment">// 如果优先级为 0（默认）并且不是 sticky 事件，那么会进入 if；</span></span><br><span class="line">            <span class="comment">// 如果是默认类型的线程池，只要写入事件的类名；</span></span><br><span class="line">            <span class="comment">// 不是默认线程，那么还要写入线程枚举类型；</span></span><br><span class="line">            <span class="keyword">if</span> (subscribe.threadMode() == ThreadMode.POSTING) &#123;</span><br><span class="line">                parts.add(eventClass + lineEnd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parts.add(eventClass + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                parts.add(<span class="string">&quot;ThreadMode.&quot;</span> + subscribe.threadMode().name() + lineEnd); <span class="comment">// 处理线程类型；</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果指定了优先级，或者是粘性事件，这里会写入事件的类名，线程枚举类型，优先级，粘性状态；</span></span><br><span class="line">            parts.add(eventClass + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            parts.add(<span class="string">&quot;ThreadMode.&quot;</span> + subscribe.threadMode().name() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            parts.add(subscribe.priority() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            parts.add(subscribe.sticky() + lineEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        writeLine(writer, <span class="number">3</span>, parts.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[parts.size()]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, <span class="string">&quot;Indexed @Subscribe at &quot;</span> +</span><br><span class="line">                    method.getEnclosingElement().getSimpleName() + <span class="string">&quot;.&quot;</span> + methodName +</span><br><span class="line">                    <span class="string">&quot;(&quot;</span> + paramElement.getSimpleName() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程是处理注解方法和注解参数的过程；</p><h1 id="3-动态-Java-类实例"><a href="#3-动态-Java-类实例" class="headerlink" title="3 动态 Java 类实例"></a>3 动态 Java 类实例</h1><p>我们可以看下动态生成的 Java 类实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.coolqi.top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.greenrobot.eventbus.meta.SimpleSubscriberInfo;</span><br><span class="line"><span class="keyword">import</span> org.greenrobot.eventbus.meta.SubscriberMethodInfo;</span><br><span class="line"><span class="keyword">import</span> org.greenrobot.eventbus.meta.SubscriberInfo;</span><br><span class="line"><span class="keyword">import</span> org.greenrobot.eventbus.meta.SubscriberInfoIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.greenrobot.eventbus.ThreadMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** This class is generated by EventBus, do not edit. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">moduleAppIndex</span> <span class="keyword">implements</span> <span class="title class_">SubscriberInfoIndex</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line">      </span><br><span class="line">        putIndex(<span class="keyword">new</span> <span class="title class_">SimpleSubscriberInfo</span>(com.coolqi.ui.EditPicActivity.class, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">SubscriberMethodInfo</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SubscriberMethodInfo</span>(<span class="string">&quot;onEventMainThread&quot;</span>, com.coolqi.common.beans.MessageEvent.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SubscriberMethodInfo</span>(<span class="string">&quot;onEventMainThread2&quot;</span>, com.coolqi.common.beans.MessageEvent.class,</span><br><span class="line">                    ThreadMode.ASYNC, <span class="number">1</span>, <span class="literal">true</span>),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> <span class="title class_">SimpleSubscriberInfo</span>(com.coolqi.ui.ChangeDateActivity.class, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">SubscriberMethodInfo</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SubscriberMethodInfo</span>(<span class="string">&quot;onEventMainThread&quot;</span>, com.coolqi.common.beans.MessageEvent.class),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> <span class="title class_">SimpleSubscriberInfo</span>(com.coolqi.ui.normal.ExhibitionWebFragment.class, <span class="literal">true</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SubscriberMethodInfo</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SubscriberMethodInfo</span>(<span class="string">&quot;onShowMessageChatNumberEvent&quot;</span>, com.gensee.kzkt_res.bean.MessageChatNumber.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SubscriberMethodInfo</span>(<span class="string">&quot;onEventMainThread&quot;</span>, com.coolqi.common.beans.MessageEvent.class),</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putIndex</span><span class="params">(SubscriberInfo info)</span> &#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SubscriberInfo <span class="title function_">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> &#123;</span><br><span class="line">        <span class="type">SubscriberInfo</span> <span class="variable">info</span> <span class="operator">=</span> SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面我们简单的看下涉及到的类和接口，这些类都位于 eventbus 模块中！</p><p>后面再分析的时候，我们就不再过多关注这些类了！</p><h2 id="3-1-SubscriberInfoIndex"><a href="#3-1-SubscriberInfoIndex" class="headerlink" title="3.1 SubscriberInfoIndex"></a>3.1 SubscriberInfoIndex</h2><p>接口，动态生成的类实现该接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SubscriberInfoIndex</span> &#123;</span><br><span class="line">    <span class="comment">//【1】用于获取订阅信息；</span></span><br><span class="line">    SubscriberInfo <span class="title function_">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-SubscriberInfo"><a href="#3-2-SubscriberInfo" class="headerlink" title="3.2 SubscriberInfo"></a>3.2 SubscriberInfo</h2><p>接口，订阅者类实现该接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SubscriberInfo</span> &#123;</span><br><span class="line">    Class&lt;?&gt; getSubscriberClass(); <span class="comment">// 获取订阅者对应的类；</span></span><br><span class="line"></span><br><span class="line">    SubscriberMethod[] getSubscriberMethods(); <span class="comment">// 获取订阅方法；</span></span><br><span class="line"></span><br><span class="line">    SubscriberInfo <span class="title function_">getSuperSubscriberInfo</span><span class="params">()</span>; <span class="comment">// 获取父类订阅者；</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldCheckSuperclass</span><span class="params">()</span>; <span class="comment">// 是否检查父类，动态生成时，传入的是 true；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-AbstractSubscriberInfo"><a href="#3-3-AbstractSubscriberInfo" class="headerlink" title="3.3 AbstractSubscriberInfo"></a>3.3 AbstractSubscriberInfo</h2><p>抽象类，实现了 <strong>SubscriberInfo</strong> 接口，并实现了其部分接口，<strong>适配器模式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSubscriberInfo</span> <span class="keyword">implements</span> <span class="title class_">SubscriberInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class subscriberClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">SubscriberInfo</span>&gt; superSubscriberInfoClass;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> shouldCheckSuperclass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractSubscriberInfo</span><span class="params">(Class subscriberClass, Class&lt;? extends SubscriberInfo&gt; superSubscriberInfoClass,</span></span><br><span class="line"><span class="params">                                     <span class="type">boolean</span> shouldCheckSuperclass)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subscriberClass = subscriberClass; <span class="comment">// 订阅者类；</span></span><br><span class="line">        <span class="built_in">this</span>.superSubscriberInfoClass = superSubscriberInfoClass; <span class="comment">// 订阅者的父类订阅者，processor 动态生成时传入的是 null；</span></span><br><span class="line">        <span class="built_in">this</span>.shouldCheckSuperclass = shouldCheckSuperclass; <span class="comment">//  是否检查父类，processor 动态生成时传入的是 true；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class <span class="title function_">getSubscriberClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subscriberClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SubscriberInfo <span class="title function_">getSuperSubscriberInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(superSubscriberInfoClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> superSubscriberInfoClass.newInstance(); <span class="comment">// 返回父类订阅者的实例；</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldCheckSuperclass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shouldCheckSuperclass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是创建订阅方法；</span></span><br><span class="line">    <span class="keyword">protected</span> SubscriberMethod <span class="title function_">createSubscriberMethod</span><span class="params">(String methodName, Class&lt;?&gt; eventType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createSubscriberMethod(methodName, eventType, ThreadMode.POSTING, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> SubscriberMethod <span class="title function_">createSubscriberMethod</span><span class="params">(String methodName, Class&lt;?&gt; eventType, ThreadMode threadMode)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createSubscriberMethod(methodName, eventType, threadMode, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> SubscriberMethod <span class="title function_">createSubscriberMethod</span><span class="params">(String methodName, Class&lt;?&gt; eventType, ThreadMode threadMode,</span></span><br><span class="line"><span class="params">                                                      <span class="type">int</span> priority, <span class="type">boolean</span> sticky)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 显然这里是通过反射的方式来创建！</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> subscriberClass.getDeclaredMethod(methodName, eventType);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubscriberMethod</span>(method, eventType, threadMode, priority, sticky);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Could not find subscriber method in &quot;</span> + subscriberClass +</span><br><span class="line">                    <span class="string">&quot;. Maybe a missing ProGuard rule?&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-SimpleSubscriberInfo"><a href="#3-4-SimpleSubscriberInfo" class="headerlink" title="3.4 SimpleSubscriberInfo"></a>3.4 SimpleSubscriberInfo</h2><p>订阅类，继承了 AbstractSubscriberInfo 类，<strong>适配器模式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSubscriberInfo</span> <span class="keyword">extends</span> <span class="title class_">AbstractSubscriberInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SubscriberMethodInfo[] methodInfos; <span class="comment">// 保存的是订阅方法；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleSubscriberInfo</span><span class="params">(Class subscriberClass, <span class="type">boolean</span> shouldCheckSuperclass, SubscriberMethodInfo[] methodInfos)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(subscriberClass, <span class="literal">null</span>, shouldCheckSuperclass); <span class="comment">//【--&gt;3.3】抽象类的方法；</span></span><br><span class="line">        <span class="built_in">this</span>.methodInfos = methodInfos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> SubscriberMethod[] getSubscriberMethods() &#123; <span class="comment">// 返回所有的订阅方法；</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> methodInfos.length;</span><br><span class="line">        SubscriberMethod[] methods = <span class="keyword">new</span> <span class="title class_">SubscriberMethod</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">SubscriberMethodInfo</span> <span class="variable">info</span> <span class="operator">=</span> methodInfos[i];</span><br><span class="line">            <span class="comment">//【--&gt;3.3】注意并不是直接返回，而是返回了一份拷贝，防止修改；</span></span><br><span class="line">            methods[i] = createSubscriberMethod(info.methodName, info.eventType, info.threadMode,</span><br><span class="line">                    info.priority, info.sticky);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不多说了！</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>本篇文章，分析了 eventbus 的注解是如何处理的，生成了哪些类，类的关系如何（适配器模式）；</p><p>下篇文章，分析 register 的过程；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列文章主要分析 EventBus 框架的架构和原理，，基于最新的 &lt;strong&gt;3.1.0&lt;/strong&gt; 版本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是 EventBus 开源库的地址，大家可以直接访问&lt;br&gt;&lt;a href=&quot;https://github.</summary>
      
    
    
    
    <category term="开源库源码分析" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="EventBus" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/EventBus/"/>
    
    
    <category term="EventBus" scheme="https://lishuaiqi.top/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>EventBus 第一篇 - 基本使用</title>
    <link href="https://lishuaiqi.top/2019/08/19/Eventbus-1-baseUsages/"/>
    <id>https://lishuaiqi.top/2019/08/19/Eventbus-1-baseUsages/</id>
    <published>2019-08-19T12:46:25.000Z</published>
    <updated>2022-10-24T15:10:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章主要分析 EventBus 框架的架构和原理，基于最新的 <strong>3.1.0</strong> 版本。</p><blockquote><p>这是 EventBus 开源库的地址，大家可以直接访问<br><a href="https://github.com/greenrobot/EventBus">https://github.com/greenrobot/EventBus</a></p></blockquote><p>本篇文章是 EventBus 的第一篇，主要总结下基本的使用；</p><p>Eventbus 翻译过来就是事件总线，用于简化组件和组件，线程和线程之间的消息通信，可以捆成是 Handler + Thread 的替代品。</p><h1 id="1-引入"><a href="#1-引入" class="headerlink" title="1 引入"></a>1 引入</h1><p>Eventbus 的引入没有 ARouter 那么复杂，他的核心 api 和 AnnotationProcessor 是在同一个 jar 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">&#x27;org.greenrobot:eventbus:3.0.0&#x27;</span></span><br></pre></td></tr></table></figure><p>以上就是引入的方式，很简单；</p><h1 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2 基本使用"></a>2 基本使用</h1><p>Eventbus 的使用还是很简单的。</p><ul><li>首先，<strong>我们要在组件生命周期的开始 register、生命周期的结束 unregister</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">EventBus.getDefault().unregister(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure><p>我们之后将组件 register 到 EventBus 中，该组件才能监听到事件；</p><p>当然，当组件生命周期结束后，需要 unregister！</p><ul><li>接着，<strong>我们要定义接收 Event 的方法</strong>；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEventMainThread</span><span class="params">(MessageEvent event)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 EventBus 中，处理 event 的方法需要被注解  @Subscribe 修饰，这是因为 EventBus 的机制，提供了一个 EventBusAnnotationProcessor，他负责自动处理   @Subscribe 修饰的方法，动态生成管理集合。</p><p>在事件分发的时候，会自动调用我们的方法；</p><p>对于注解 @Subscribe，我们可以设置其属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN, sticky = true, priority = 2)</span></span><br></pre></td></tr></table></figure><p>1、threadMode 用于指定线程模型（默认为 POSTING ），EventBus 提供了四种线程模型，下面会简单介绍；</p><p>2、sticky 表示方法是否开启粘性事件；</p><p>3、priority 表示多个订阅者收到事件的优先级顺序；</p><ul><li>最后，我们要<strong>发送消息</strong></li></ul><p>消息这里分为普通消息和粘性消息，和 broadcast 很类似哦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(..)</span><br><span class="line"></span><br><span class="line">EventBus.getDefault().post(...)</span><br></pre></td></tr></table></figure><p>对于普通消息和粘性消息的处理，后面再分析。</p><p>方法很简答，就不多说了～～</p><h1 id="3-线程模型"><a href="#3-线程模型" class="headerlink" title="3 线程模型"></a>3 线程模型</h1><p>EventBus 提供了四种线程模型，定义在 ThreadMode.java 中：</p><ul><li><strong>POSTING</strong></li></ul><p>这是默认的线程模型，发布事件和接收事件在同一个线程进行，不要做耗时操作，因为可能是在 UI 线程，导致 ANR；</p><ul><li><strong>MAIN</strong></li></ul><p>接收事件在 UI 线程中进行；不要做耗时操作，会导致 ANR；</p><ul><li><strong>BACKGROUND</strong></li></ul><p>如果发送事件是在 UI 线程，那么接收事件会在一个新的子线程；</p><p>如果发送事件是在子线程，那么接收事件和发送事件会在同一个子线程；</p><p>不能处理 UI 相关操作！</p><ul><li><strong>ASYNC</strong></li></ul><p>接收事件始终会在一个新的子线程中，不能处理 UI 相关操作！</p><blockquote><p>这里简单分析了下线程模型，我们后面在分析源码的时候，再来分析每种线程模型的处理方式；</p></blockquote><h1 id="4-整体架构初识"><a href="#4-整体架构初识" class="headerlink" title="4 整体架构初识"></a>4 整体架构初识</h1><p>可以看到这种订阅和接收的关系，很类似于 Rxjava 的模式，其实就是观察者模式，这里直接引用 EventBus 官方的一张图来说明下：</p><p><img src="https://coolqifiles.oss-cn-hangzhou.aliyuncs.com/uPic2/2022/10/24/23/1240.png" alt=""></p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>本篇文章就到这里了，下一篇会从 @Subscribe 注解的处理入手，看下 EventBus 是如何处理该注解的；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列文章主要分析 EventBus 框架的架构和原理，基于最新的 &lt;strong&gt;3.1.0&lt;/strong&gt; 版本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是 EventBus 开源库的地址，大家可以直接访问&lt;br&gt;&lt;a href=&quot;https://github.c</summary>
      
    
    
    
    <category term="开源库源码分析" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="EventBus" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/EventBus/"/>
    
    
    <category term="EventBus" scheme="https://lishuaiqi.top/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>JsBridge 第三篇 - Native 调用 H5 代码</title>
    <link href="https://lishuaiqi.top/2019/05/23/JsBridge3-Native--%3EH5Codes/"/>
    <id>https://lishuaiqi.top/2019/05/23/JsBridge3-Native--%3EH5Codes/</id>
    <published>2019-05-23T12:46:25.000Z</published>
    <updated>2019-07-05T21:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章主要分析 JsBridge 框架的原理，学习 H5 和原生 WebView 的交互方式，框架选自 GitHub 上的很火的 H5 + WebView 三方库：lzyzsd/JsBridge，作者是大鬼头；</p><h1 id="1-调用接口"><a href="#1-调用接口" class="headerlink" title="1 调用接口"></a>1 调用接口</h1><p>在 android 中，我们通过如下方式，使用 jsBridge 框架来和 H5 通信：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】封装 Java 层的 bean 数据；</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">Location</span> <span class="variable">location</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Location</span>();</span><br><span class="line">location.address = <span class="string">&quot;SDU&quot;</span>;</span><br><span class="line">user.location = location;</span><br><span class="line">user.name = <span class="string">&quot;大头鬼&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【2】发送数据，并注册回调函数 CallBackFunction：</span></span><br><span class="line">webView.callHandler(<span class="string">&quot;functionInJs&quot;</span>, <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(user), <span class="keyword">new</span> <span class="title class_">CallBackFunction</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCallBack</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//【3】这个是不需要回调的，直接发送数据给 H5；</span></span><br><span class="line">webView.send(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里涉及到 2 个交互接口：</p><ul><li>webView.callHandler：有回调；</li><li>webView.send：没有回调；</li></ul><p>下面我会来分析下这两个方法的调用链，这会涉及到 jsBridge 中其他的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|____Message.java</span><br><span class="line">|____WebViewJavascriptBridge.java</span><br><span class="line">|____DefaultHandler.java</span><br><span class="line">|____BridgeWebView.java</span><br><span class="line">|____BridgeWebViewClient.java</span><br><span class="line">|____CallBackFunction.java</span><br><span class="line">|____BridgeHandler.java</span><br><span class="line">|____BridgeUtil.java</span><br></pre></td></tr></table></figure><p>在分析交互流程的时候，我们会详细分析每个类的内部逻辑！</p><h1 id="2-BridgeWebView"><a href="#2-BridgeWebView" class="headerlink" title="2 BridgeWebView"></a>2 BridgeWebView</h1><p>我们从 BridgeWebView 开始，先看看内部的一些重要成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】native 的回调函数 map，key 是 id，value 是具体的回调对象；</span></span><br><span class="line">Map&lt;String, CallBackFunction&gt; responseCallbacks = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, CallBackFunction&gt;();</span><br><span class="line"><span class="comment">//【2】native 处理 js 消息的 handler map，key 是 handler name，value 是具体的 handler</span></span><br><span class="line">Map&lt;String, BridgeHandler&gt; messageHandlers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, BridgeHandler&gt;();</span><br><span class="line"><span class="comment">//【3】默认的 handler，默认是它处理 js 的消息；</span></span><br><span class="line"><span class="type">BridgeHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultHandler</span>();</span><br><span class="line"><span class="comment">//【4】native 发送给 js 的 message 列表；</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Message&gt; startupMessage = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Message&gt;();</span><br></pre></td></tr></table></figure><br>不多说了。</p><h2 id="2-1-callHandler"><a href="#2-1-callHandler" class="headerlink" title="2.1 callHandler"></a>2.1 callHandler</h2><p>我们先分析有回调的接口的交互流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】发送数据，并注册回调函数 CallBackFunction：</span></span><br><span class="line">webView.callHandler(<span class="string">&quot;functionInJs&quot;</span>, <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(user), <span class="keyword">new</span> <span class="title class_">CallBackFunction</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCallBack</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>callHandler 方法指定了 js 使用哪个 Handler 处理 native 的消息！</p><p>这里指定了 js 用于处理的 handler name 是 “functionInJs”！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callHandler</span><span class="params">(String handlerName, String data, CallBackFunction callBack)</span> &#123;</span><br><span class="line">    <span class="comment">//【*2.2】调用另外一个方法：</span></span><br><span class="line">    doSend(handlerName, data, callBack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们去看看 doSend 方法：</p><h2 id="2-2-doSend"><a href="#2-2-doSend" class="headerlink" title="2.2 doSend"></a>2.2 doSend</h2><p>继续分析 doSend 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSend</span><span class="params">(String handlerName, String data, CallBackFunction responseCallback)</span> &#123;</span><br><span class="line">   <span class="comment">//【1】创建一个消息；</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(data)) &#123;</span><br><span class="line">    <span class="comment">//【2】设置 data 数据；</span></span><br><span class="line">m.setData(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【3】如果需要回调，那么会创建回调 id（String）</span></span><br><span class="line"><span class="keyword">if</span> (responseCallback != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">callbackStr</span> <span class="operator">=</span> String.format(BridgeUtil.CALLBACK_ID_FORMAT, ++uniqueId + (BridgeUtil.UNDERLINE_STR + SystemClock.currentThreadTimeMillis()));</span><br><span class="line">responseCallbacks.put(callbackStr, responseCallback);</span><br><span class="line">m.setCallbackId(callbackStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【4】如果指定了 handler，那么设置 handlerName；</span></span><br><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(handlerName)) &#123;</span><br><span class="line">m.setHandlerName(handlerName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【*2.3】将消息送入队列；</span></span><br><span class="line">queueMessage(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到，会创建一个 Message 对象，封装要发给 js 的消息；</p><p>同时注意到，native 的回调并没有传递给 js，而是保存在了内部的一个 responseCallbacks 哈希表中；</p><p>实际传递给 js 的是 callbackId；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message.data  <span class="comment">// native 发送的数据</span></span><br><span class="line">Message.callbackId  <span class="comment">// native 回调函数的 id</span></span><br><span class="line">Message.handlerName <span class="comment">// js 处理数据的 handlerName；</span></span><br></pre></td></tr></table></figure><p>最后就是把 message 放入到 message list；</p><h2 id="2-3-queueMessage"><a href="#2-3-queueMessage" class="headerlink" title="2.3 queueMessage"></a>2.3 queueMessage</h2><p>将 message 放入到 message list；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">queueMessage</span><span class="params">(Message m)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (startupMessage != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//【1】将消息加入到 message list 中；</span></span><br><span class="line">startupMessage.add(m);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//【*2.4】特殊情况，直接发送 message！</span></span><br><span class="line">dispatchMessage(m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里默认是会将 message 添加到 startupMessage 消息列表中，然后 webview 会处理 message list！</p><p>那么在哪里会处理呢？</p><p>前面我们分析过，在网页加载好后，会出发 BridgeWebViewClient.onPageFinished 方法，就会启动 native 的消息处理循环！</p><p><strong>见 【3.1】 节</strong>；</p><h2 id="2-4-dispatchMessage"><a href="#2-4-dispatchMessage" class="headerlink" title="2.4 dispatchMessage"></a>2.4 dispatchMessage</h2><p>native 给 js 发送消息的关键点，参数 message 是一个消息对象！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(Message m)</span> &#123;</span><br><span class="line">    <span class="comment">//【*4.2】将 message 转为 json</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">messageJson</span> <span class="operator">=</span> m.toJson();</span><br><span class="line">    <span class="comment">//【1】为 message json 字符串转义特殊字符；</span></span><br><span class="line">    messageJson = messageJson.replaceAll(<span class="string">&quot;(\\\\)([^utrn])&quot;</span>, <span class="string">&quot;\\\\\\\\$1$2&quot;</span>);</span><br><span class="line">    messageJson = messageJson.replaceAll(<span class="string">&quot;(?&lt;=[^\\\\])(\&quot;)&quot;</span>, <span class="string">&quot;\\\\\&quot;&quot;</span>);</span><br><span class="line">messageJson = messageJson.replaceAll(<span class="string">&quot;(?&lt;=[^\\\\])(\&#x27;)&quot;</span>, <span class="string">&quot;\\\\\&#x27;&quot;</span>);</span><br><span class="line">messageJson = messageJson.replaceAll(<span class="string">&quot;%7B&quot;</span>, URLEncoder.encode(<span class="string">&quot;%7B&quot;</span>));</span><br><span class="line">messageJson = messageJson.replaceAll(<span class="string">&quot;%7D&quot;</span>, URLEncoder.encode(<span class="string">&quot;%7D&quot;</span>));</span><br><span class="line">messageJson = messageJson.replaceAll(<span class="string">&quot;%22&quot;</span>, URLEncoder.encode(<span class="string">&quot;%22&quot;</span>));</span><br><span class="line"><span class="comment">//【2】创建要执行的 js 代码，用于和 H5 通信；</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">javascriptCommand</span> <span class="operator">=</span> String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson);</span><br><span class="line">    <span class="comment">//【3】必须要找主线程才会将数据传递出去 --- 划重点</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123;</span><br><span class="line">        【*<span class="number">5.1</span>】执行 js 代码；</span><br><span class="line">        <span class="built_in">this</span>.loadUrl(javascriptCommand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BridgeUtil 是一个工具类，里面主要是一些通信协议码，以及一些工具方法，native 和 H5 通信的时候，本质上是执行 js 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">JS_HANDLE_MESSAGE_FROM_JAVA</span> <span class="operator">=</span> <span class="string">&quot;javascript:WebViewJavascriptBridge._handleMessageFromNative(&#x27;%s&#x27;);&quot;</span>;</span><br></pre></td></tr></table></figure><p>可以看到，执行的 js 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript:WebViewJavascriptBridge._handleMessageFromNative(JsonString of Message);</span><br></pre></td></tr></table></figure><p>我相信大家知道，这个方法将进入通信协议 js 文件了！</p><h2 id="2-5-handlerReturnData"><a href="#2-5-handlerReturnData" class="headerlink" title="2.5 handlerReturnData"></a>2.5 handlerReturnData</h2><p>拦截 url 并处理信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">handlerReturnData</span><span class="params">(String url)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">functionName</span> <span class="operator">=</span> BridgeUtil.getFunctionFromReturnUrl(url);</span><br><span class="line"><span class="type">CallBackFunction</span> <span class="variable">f</span> <span class="operator">=</span> responseCallbacks.get(functionName);</span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> BridgeUtil.getDataFromReturnUrl(url);</span><br><span class="line"><span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">f.onCallBack(data);</span><br><span class="line">responseCallbacks.remove(functionName);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-BridgeWebViewClient"><a href="#3-BridgeWebViewClient" class="headerlink" title="3 BridgeWebViewClient"></a>3 BridgeWebViewClient</h1><p>WebViewClient 是用于处理各种事件的回调。</p><h2 id="3-1-onPageFinished"><a href="#3-1-onPageFinished" class="headerlink" title="3.1 onPageFinished"></a>3.1 onPageFinished</h2><p>当 H5 页面加载完成后，会 WebViewClient 方法会处罚；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPageFinished</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onPageFinished(view, url);</span><br><span class="line">    <span class="comment">//【1】动态注入 js 协议脚本，这个我们之前有讲过；</span></span><br><span class="line">    <span class="keyword">if</span> (BridgeWebView.toLoadJs != <span class="literal">null</span>) &#123;</span><br><span class="line">        BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【*2.5】这里会遍历 BridgeWebView.startupMessage 分发 native 消息；</span></span><br><span class="line">    <span class="keyword">if</span> (webView.getStartupMessage() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Message m : webView.getStartupMessage()) &#123;</span><br><span class="line">            <span class="comment">//【*2.5】分发 native 消息；</span></span><br><span class="line">            webView.dispatchMessage(m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【*2.3】注意：这里将 BridgeWebView.startupMessage 设置为 null 了</span></span><br><span class="line">        <span class="comment">// 那么下次就不用将消息加入 list 了，而是直接 dispatch 了！</span></span><br><span class="line">        webView.setStartupMessage(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】调用其他函数处理 url！</span></span><br><span class="line">    onCustomPageFinishd(view,url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来最终调用了 webView.dispatchMessage 方法！</p><h2 id="3-2-shouldOverrideUrlLoading"><a href="#3-2-shouldOverrideUrlLoading" class="headerlink" title="3.2 shouldOverrideUrlLoading"></a>3.2 shouldOverrideUrlLoading</h2><p>我们来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】获得动态创建的 url</span></span><br><span class="line">        url = URLDecoder.decode(url, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【*3.2.2】此时是返回数据，url 携带数据；</span></span><br><span class="line">    <span class="keyword">if</span> (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123;</span><br><span class="line">        <span class="comment">//【*3.5】native 解析 js 返回的数据；</span></span><br><span class="line">        webView.handlerReturnData(url);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【*3.2.1】此时是提醒 native，js 有数据返回；</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123; </span><br><span class="line">        <span class="comment">//【*3.3】native 再次和 js 通信，获取数据；</span></span><br><span class="line">        webView.flushMessageQueue();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BridgeUtil 定义了如下的 url 前缀规则：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">YY_OVERRIDE_SCHEMA</span> <span class="operator">=</span> <span class="string">&quot;yy://&quot;</span>;</span><br><span class="line"><span class="comment">//【1】表示 js 有数据返回，提醒 native 去读取数据；</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">YY_RETURN_DATA</span> <span class="operator">=</span> YY_OVERRIDE_SCHEMA + <span class="string">&quot;return/&quot;</span>;</span><br><span class="line"><span class="comment">//【2】该 url 会携带 js 返回的数据；</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">YY_FETCH_QUEUE</span> <span class="operator">=</span> YY_RETURN_DATA + <span class="string">&quot;_fetchQueue/&quot;</span>;</span><br></pre></td></tr></table></figure></p><h2 id="3-3-flushMessageQueue"><a href="#3-3-flushMessageQueue" class="headerlink" title="3.3 flushMessageQueue"></a>3.3 flushMessageQueue</h2><p>核心方法，从 js 的队列里获取要发送给 native 的 message：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">flushMessageQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//【1】必须在主线程（loadUrl）</span></span><br><span class="line"><span class="keyword">if</span> (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123;</span><br><span class="line">    <span class="comment">//【---&gt;*3.4】执行 js 脚本</span></span><br><span class="line">loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, <span class="keyword">new</span> <span class="title class_">CallBackFunction</span>() &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//【*3.3.1】这个回调是用来分发 url 对应的数据给相应的回调！</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCallBack</span><span class="params">(String data)</span> &#123;</span><br><span class="line"><span class="comment">//【1】用于存储所有的消息；</span></span><br><span class="line">List&lt;Message&gt; list = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">list = Message.toArrayList(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (list == <span class="literal">null</span> || list.size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="comment">//【2】遍历处理下每一个 Message。</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> list.get(i);</span><br><span class="line"><span class="type">String</span> <span class="variable">responseId</span> <span class="operator">=</span> m.getResponseId();</span><br><span class="line"><span class="comment">//【3】如果 Message.responseId 不为 null，说明这是 js 反馈给 native 的回调数据。此时 responseId 表示 native 回调函数的 id！</span></span><br><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(responseId)) &#123;</span><br><span class="line">    <span class="comment">//【3.1】获得 native 在 callHandler 是设定的回调函数！</span></span><br><span class="line"><span class="type">CallBackFunction</span> <span class="variable">function</span> <span class="operator">=</span> responseCallbacks.get(responseId);</span><br><span class="line"><span class="comment">//【3.2】获得回调数据；</span></span><br><span class="line"><span class="type">String</span> <span class="variable">responseData</span> <span class="operator">=</span> m.getResponseData();</span><br><span class="line"><span class="comment">//【--&gt;*2.1】native 处理数据，这里又回到了 callHandler 哪里！</span></span><br><span class="line">function.onCallBack(responseData);</span><br><span class="line"><span class="comment">//【3.3】移除 native 注册的回调函数！</span></span><br><span class="line">responseCallbacks.remove(responseId);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//【4】这种情况是属于，js 主动向 Handler 发送消息的时候，callbackId 显然是 js 的回调函数 id；</span></span><br><span class="line"><span class="type">CallBackFunction</span> <span class="variable">responseFunction</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">callbackId</span> <span class="operator">=</span> m.getCallbackId();</span><br><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(callbackId)) &#123;</span><br><span class="line">    <span class="comment">//【4.1】有 js 回调的情况，进入这里；</span></span><br><span class="line">responseFunction = <span class="keyword">new</span> <span class="title class_">CallBackFunction</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCallBack</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    <span class="comment">//【4.1.1】可以看到，这里创建了一个 Message，作为给 js 的回调信息；</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">responseMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">responseMsg.setResponseId(callbackId);</span><br><span class="line">responseMsg.setResponseData(data);</span><br><span class="line"><span class="comment">//【--&gt;*2.4】将消息加入 list，等待处理；</span></span><br><span class="line">queueMessage(responseMsg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//【4.2】无 js 回调的情况，进入这里；</span></span><br><span class="line">responseFunction = <span class="keyword">new</span> <span class="title class_">CallBackFunction</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCallBack</span><span class="params">(String data)</span> &#123;</span><br><span class="line"><span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【4.3】js 指定了 native 处理数据的 handler！</span></span><br><span class="line">BridgeHandler handler;</span><br><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(m.getHandlerName())) &#123;</span><br><span class="line">handler = messageHandlers.get(m.getHandlerName());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">handler = defaultHandler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【4.4】处理 js 的message，并发送回调信息给 js。</span></span><br><span class="line"><span class="keyword">if</span> (handler != <span class="literal">null</span>)&#123;</span><br><span class="line">handler.handler(m.getData(), responseFunction);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面部分的代码（【4】)），是和 H5 调用 Native 代码相关的，我们不过多关注！</p><p>BridgeUtil 定义了指定 js 协议的 _fetchQueue 方法的命令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">JS_FETCH_QUEUE_FROM_JAVA</span> <span class="operator">=</span> <span class="string">&quot;javascript:WebViewJavascriptBridge._fetchQueue();&quot;</span>;</span><br></pre></td></tr></table></figure><br>下面去看一下 loadUrl：</p><h2 id="3-4-loadUrl"><a href="#3-4-loadUrl" class="headerlink" title="3.4 loadUrl"></a>3.4 loadUrl</h2><p>参数 jsUrl 是 <strong>javascript:WebViewJavascriptBridge._fetchQueue();</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadUrl</span><span class="params">(String jsUrl, CallBackFunction returnCallback)</span> &#123;</span><br><span class="line">    <span class="comment">//【*5.4】执行 jsUrl 命令；</span></span><br><span class="line"><span class="built_in">this</span>.loadUrl(jsUrl);</span><br><span class="line">    <span class="comment">//【2】同时将 CallBackFunction 放入到 responseCallbacks 中；</span></span><br><span class="line">responseCallbacks.put(BridgeUtil.parseFunctionName(jsUrl), returnCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了【*7.1】BridgeUtil.parseFunctionName 对 jsUrl 做了处理，以结果作为 key！</p><p>处理入下：</p><blockquote><p>javascript:WebViewJavascriptBridge._fetchQueue(); –&gt; _fetchQueue</p></blockquote><p>这样是有好处了，因为 returnCallback 根据协议是可以复用的，所以这里也保存在了 responseCallbacks 中！！</p><p><br></p><p>responseCallbacks 之前我们有分析过！<strong>此时 responseCallbacks 放入了 2 个 native 的回调！</strong></p><h2 id="3-5-handlerReturnData"><a href="#3-5-handlerReturnData" class="headerlink" title="3.5 handlerReturnData"></a>3.5 handlerReturnData</h2><p>改方法用于处理 js 返回给 native 的回调数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">handlerReturnData</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="comment">//【*7.2】再次解析 url，获得回调的 key：functionName</span></span><br><span class="line"><span class="type">String</span> <span class="variable">functionName</span> <span class="operator">=</span> BridgeUtil.getFunctionFromReturnUrl(url);</span><br><span class="line"><span class="comment">//【1】functionName 就是 _fetchQueue，这里我们获得了【*3.3】注册的 callback</span></span><br><span class="line"><span class="type">CallBackFunction</span> <span class="variable">f</span> <span class="operator">=</span> responseCallbacks.get(functionName);</span><br><span class="line"><span class="comment">//【*7.3」获得 js 的回调返回数据；</span></span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> BridgeUtil.getDataFromReturnUrl(url);</span><br><span class="line"><span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//【*3.3.1】执行回调，处理数据！</span></span><br><span class="line">f.onCallBack(data);</span><br><span class="line"><span class="comment">//【2】删除该 _fetchQueue 对应的回调（我觉得可以不删除的）</span></span><br><span class="line">responseCallbacks.remove(functionName);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了【*7.2】BridgeUtil.getFunctionFromReturnUrl 对 url 再次做了处理，前面在 【3.3】 flushMessageQueue，我们将另一个解析回调以 _fetchQueue 为 key，保存到了 responseCallbacks 中，这里是触发他的时候了！</p><h1 id="4-Message"><a href="#4-Message" class="headerlink" title="4 Message"></a>4 Message</h1><p>该对象用于封装 native 和 js 交互的信息：</p><h2 id="4-1-属性"><a href="#4-1-属性" class="headerlink" title="4.1 属性"></a>4.1 属性</h2><p>我们来看看他的基本属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// native --&gt; js: native 回调的 id，用于处理 js 的返回信息；</span></span><br><span class="line">   <span class="comment">// js --&gt; native: js 回调的 id，用于处理 native 的返回信息；</span></span><br><span class="line"><span class="keyword">private</span> String callbackId;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// js --&gt; native: native 回调的 id，用于处理 js 的返回信息；</span></span><br><span class="line"><span class="keyword">private</span> String responseId;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js --&gt; native: js 发送给 native 的信息：json，string；</span></span><br><span class="line"><span class="keyword">private</span> String responseData; <span class="comment">// js 的回调信息，json string；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// native --&gt; js: native 发送给 js 的信息：json，string；</span></span><br><span class="line"><span class="keyword">private</span> String data; </span><br><span class="line"></span><br><span class="line"><span class="comment">// native --&gt; js: 处理 native 信息的 js handler name；</span></span><br><span class="line"><span class="keyword">private</span> String handlerName;</span><br></pre></td></tr></table></figure><p>不多说了！</p><h2 id="4-2-toJson"><a href="#4-2-toJson" class="headerlink" title="4.2 toJson"></a>4.2 toJson</h2><p>将 Message 转为 json string！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toJson</span><span class="params">()</span> &#123;</span><br><span class="line">    JSONObject jsonObject= <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jsonObject.put(CALLBACK_ID_STR, getCallbackId()); <span class="comment">// callbackId</span></span><br><span class="line">        jsonObject.put(DATA_STR, getData()); <span class="comment">// data</span></span><br><span class="line">        jsonObject.put(HANDLER_NAME_STR, getHandlerName()); <span class="comment">// handlerName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> getResponseData();</span><br><span class="line">        <span class="comment">//【3】这个地方我有些疑问，不知道作者为啥这样写</span></span><br><span class="line">        <span class="comment">// 值永远会被第三个覆盖掉；</span></span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(data)) &#123;</span><br><span class="line">          jsonObject.put(RESPONSE_DATA_STR, data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          jsonObject.put(RESPONSE_DATA_STR, <span class="keyword">new</span> <span class="title class_">JSONTokener</span>(data).nextValue());</span><br><span class="line">        &#125;</span><br><span class="line">        jsonObject.put(RESPONSE_DATA_STR, getResponseData()); <span class="comment">// responseData</span></span><br><span class="line">        jsonObject.put(RESPONSE_ID_STR, getResponseId()); <span class="comment">// responseId</span></span><br><span class="line">        <span class="keyword">return</span> jsonObject.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的参数我就不说了，很简单！</p><h1 id="5-WebViewJavascriptBridge"><a href="#5-WebViewJavascriptBridge" class="headerlink" title="5 WebViewJavascriptBridge"></a>5 WebViewJavascriptBridge</h1><p>最后进入了通信协议 js 脚本：</p><h2 id="5-1-handleMessageFromNative"><a href="#5-1-handleMessageFromNative" class="headerlink" title="5.1 _handleMessageFromNative"></a>5.1 _handleMessageFromNative</h2><p>js 代码中会处理 native 发送的 message json：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_handleMessageFromNative</span>(<span class="params">messageJSON</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(messageJSON);</span><br><span class="line">    <span class="comment">//【1】如果 receiveMessageQueue 不为 null，那么会讲她加入到</span></span><br><span class="line">    <span class="comment">// receiveMessageQueue 队列中，它是用来保存 native 发送的消息的；</span></span><br><span class="line">    <span class="keyword">if</span> (receiveMessageQueue) &#123;</span><br><span class="line">        receiveMessageQueue.<span class="title function_">push</span>(messageJSON);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【*5.2】分发来自 native 的消息；</span></span><br><span class="line">    <span class="title function_">_dispatchMessageFromNative</span>(messageJSON);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第二篇 js 协议中有讲过：</p><p>当在动态注入 js 脚本时，会执行 init 方法，那里会将 receiveMessageQueue 置为 null，同时处理已经包含的 native 消息；</p><p>所以这里就直接 _dispatchMessageFromNative 了；</p><h2 id="5-2-dispatchMessageFromNative"><a href="#5-2-dispatchMessageFromNative" class="headerlink" title="5.2 _dispatchMessageFromNative"></a>5.2 _dispatchMessageFromNative</h2><p>js 处理 native 层的消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_dispatchMessageFromNative</span>(<span class="params">messageJSON</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//【1】获得 message json 对象；</span></span><br><span class="line">        <span class="keyword">var</span> message = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(messageJSON);</span><br><span class="line">        <span class="keyword">var</span> responseCallback;</span><br><span class="line">        <span class="keyword">if</span> (message.<span class="property">responseId</span>) &#123;</span><br><span class="line">            ... ... ...<span class="comment">// 这个地方是 js 回调的地方，我们先不看；</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【2】很显然，此时会进入这里，因为我们设置了 callbackId！</span></span><br><span class="line">            <span class="keyword">if</span> (message.<span class="property">callbackId</span>) &#123;</span><br><span class="line">                <span class="comment">//【3】获得 callbackId！</span></span><br><span class="line">                <span class="keyword">var</span> callbackResponseId = message.<span class="property">callbackId</span>;</span><br><span class="line">                <span class="comment">//【*5.2.1】创建 js 回调函数，当回调触发后，会执行 doSend 方法！</span></span><br><span class="line">                responseCallback = <span class="keyword">function</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">                    <span class="comment">//【*5.3】将结果以回调形式发送给 native！</span></span><br><span class="line">                    <span class="title function_">_doSend</span>(&#123;</span><br><span class="line">                        <span class="comment">//【4】注意这里，Message.callbackId 的值赋给了 Message.responseId</span></span><br><span class="line">                        <span class="comment">// Message.responseData 用于保存回调数据；</span></span><br><span class="line">                        <span class="attr">responseId</span>: callbackResponseId,</span><br><span class="line">                        <span class="attr">responseData</span>: responseData</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【5】选择合适的 handler 去处理 native message。</span></span><br><span class="line">            <span class="comment">// 没有指定 handler，就用默认的！</span></span><br><span class="line">            <span class="keyword">var</span> handler = <span class="title class_">WebViewJavascriptBridge</span>.<span class="property">_messageHandler</span>;</span><br><span class="line">            <span class="keyword">if</span> (message.<span class="property">handlerName</span>) &#123;</span><br><span class="line">                handler = messageHandlers[message.<span class="property">handlerName</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【*6.1】handler 其实就是一个函数，这个在通信协议 js 有分析过！</span></span><br><span class="line">                <span class="title function_">handler</span>(message.<span class="property">data</span>, responseCallback);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (exception) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">console</span> != <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebViewJavascriptBridge: WARNING: javascript handler threw.&quot;</span>, message, exception);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会选择合适的 handler，将 native message 和 js 回调函数交给 handler 处理！</p><h2 id="5-3-doSend"><a href="#5-3-doSend" class="headerlink" title="5.3 _doSend"></a>5.3 _doSend</h2><p>将结果以回调形式发送给 native！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_doSend</span>(<span class="params">message, responseCallback</span>) &#123;</span><br><span class="line">    <span class="comment">//【1】responseCallback 不为 null，说明 native 需要回调通知，这里将 responseCallback</span></span><br><span class="line">    <span class="comment">// 保存到 responseCallbacks 的意义是：可以建立双向通信！</span></span><br><span class="line">    <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">        <span class="comment">//【2】为该 responseCallback 创建 id，并将 id：responseCallback 的映射关系</span></span><br><span class="line">        <span class="comment">// 保存到 responseCallbacks 数组中！</span></span><br><span class="line">        <span class="keyword">var</span> callbackId = <span class="string">&#x27;cb_&#x27;</span> + (uniqueId++) + <span class="string">&#x27;_&#x27;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">        responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">        <span class="comment">//【3】将 id 保存到 message.callbackId 中；！</span></span><br><span class="line">        <span class="comment">// 因为此时 message 用于保存 js 发给 native 的数据，所以 message.callbackId 保存了 js 的回调函数，</span></span><br><span class="line">        <span class="comment">// 这样 native 就可以和 js 双向通信了！</span></span><br><span class="line">        message.<span class="property">callbackId</span> = callbackId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】将消息保存到 sendMessageQueue 中，然后创建 url，</span></span><br><span class="line">    <span class="comment">//【*3.2】这样 BridgeWebViewClient.shouldOverrideUrlLoading 就能拦截这个 url 了；</span></span><br><span class="line">    sendMessageQueue.<span class="title function_">push</span>(message);</span><br><span class="line">    messagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://&#x27;</span> + <span class="variable constant_">QUEUE_HAS_MESSAGE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>responseCallback 实际上是 js 处理 native 消息的回调函数，这里给 responseCallback 也分配了一个 id，并保存到 responseCallbacks 中！</p><p>目的很明显，是为了建立双向通信！</p><p><br></p><p>到这里 Message 中的数据发生了变化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message.responseId  <span class="comment">// native 的回调函数 id</span></span><br><span class="line">Message.callbackId  <span class="comment">// js 的回调函数 id</span></span><br><span class="line">Message.responseData <span class="comment">// js 发送的回调数据；</span></span><br></pre></td></tr></table></figure></p><p><br></p><p>这里创建了一个 url：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yy:<span class="comment">//__QUEUE_MESSAGE__/</span></span><br></pre></td></tr></table></figure><p>这个方法会导致 BridgeWebViewClient.shouldOverrideUrlLoading 触发！</p><h2 id="5-4-fetchQueue"><a href="#5-4-fetchQueue" class="headerlink" title="5.4 _fetchQueue"></a>5.4 _fetchQueue</h2><p>从 sendMessageQueue 队列中获取 message，发送给 native：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_fetchQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//【1】这里是统一处理要发给 native 的所有消息，将队列转为 string</span></span><br><span class="line">    <span class="keyword">var</span> messageQueueString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(sendMessageQueue);</span><br><span class="line">    sendMessageQueue = [];</span><br><span class="line">    <span class="comment">//【2】这里又再在页面生成 url，和之前的区别是包含数据，然后再次通过 shouldOverrideUrlLoading 方法拦截，</span></span><br><span class="line">    <span class="comment">// 捕获 url 中的数据；</span></span><br><span class="line">    <span class="keyword">if</span> (messageQueueString !== <span class="string">&#x27;[]&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//【*3.2.2】这一次，生成的 url 将真正带有回调数据；</span></span><br><span class="line">        bizMessagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://return/_fetchQueue/&#x27;</span> + <span class="built_in">encodeURIComponent</span>(messageQueueString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里生成了一个新的 url：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">yy</span>:<span class="comment">//://return/_fetchQueue/[&#123;&quot;responseId&quot;:&quot;xxxxxxx&quot;,&quot;responseData&quot;:&quot;xxxxxxxxxx&quot;&#125;]</span></span><br></pre></td></tr></table></figure><p>再次回到了 shouldOverrideUrlLoading：</p><h1 id="6-H5-页面初始化-js-脚本"><a href="#6-H5-页面初始化-js-脚本" class="headerlink" title="6 H5 页面初始化 js 脚本"></a>6 H5 页面初始化 js 脚本</h1><p>在 jsBridge 框架中，当 js 协议脚本被动态注入到 H5 中时，会触发 H5 页面中的初始化 js 脚本，该脚本会初始化 js 的 handler：</p><h2 id="6-1-connectWebViewJavascriptBridge"><a href="#6-1-connectWebViewJavascriptBridge" class="headerlink" title="6.1 connectWebViewJavascriptBridge"></a>6.1 connectWebViewJavascriptBridge</h2><p>可以看到，H5 页面注册的 js handler 的名字就是 “functionInJs” 这个和前面 callHandler 相符合了！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">connectWebViewJavascriptBridge</span>(<span class="keyword">function</span>(<span class="params">bridge</span>) &#123;</span><br><span class="line">    ... ... ...</span><br><span class="line">    <span class="comment">//【1】后面的 function 就是我们的 handler。</span></span><br><span class="line">    bridge.<span class="title function_">registerHandler</span>(<span class="string">&quot;functionInJs&quot;</span>, <span class="keyword">function</span>(<span class="params">data, responseCallback</span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;show&quot;</span>).<span class="property">innerHTML</span> = (<span class="string">&quot;data from Java: = &quot;</span> + data);</span><br><span class="line">        <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">            <span class="keyword">var</span> responseData = <span class="string">&quot;Javascript Says Right back aka!&quot;</span>;</span><br><span class="line">            <span class="comment">//【*5.2.1】js 处理完 message 后，回调 responseCallback 接口！</span></span><br><span class="line">            <span class="comment">// 其实就是【*5.2】创建的回调，会触发 _doSend 方法！</span></span><br><span class="line">            <span class="title function_">responseCallback</span>(responseData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个在前面的 js 通信协议中有分析过，不多说了！</p><h1 id="7-BridgeUtil"><a href="#7-BridgeUtil" class="headerlink" title="7 BridgeUtil"></a>7 BridgeUtil</h1><p>工具类，包含一些解析方法和协议头常量：</p><h2 id="7-1-parseFunctionName"><a href="#7-1-parseFunctionName" class="headerlink" title="7.1 parseFunctionName"></a>7.1 parseFunctionName</h2><p>从 url 中解析 funtion name：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url 的一个例子：javascript:WebViewJavascriptBridge._fetchQueue();</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">parseFunctionName</span><span class="params">(String jsUrl)</span>&#123;</span><br><span class="line">    <span class="comment">//【1】返回_fetchQueue</span></span><br><span class="line"><span class="keyword">return</span> jsUrl.replace(<span class="string">&quot;javascript:WebViewJavascriptBridge.&quot;</span>, <span class="string">&quot;&quot;</span>).replaceAll(<span class="string">&quot;\\(.*\\);&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是在 js 创建 url，通知 native 有回调消息后调用的！</p><h2 id="7-2-getFunctionFromReturnUrl"><a href="#7-2-getFunctionFromReturnUrl" class="headerlink" title="7.2 getFunctionFromReturnUrl"></a>7.2 getFunctionFromReturnUrl</h2><p>从 url 中解析 funtion name：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是 url 的一个例子；</span></span><br><span class="line"><span class="comment">// url = yy://return/_fetchQueue/[&#123;&quot;responseId&quot;:&quot;xxxxx&quot;,&quot;responseData&quot;:&quot;xxxxx&quot;&#125;]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFunctionFromReturnUrl</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】去掉 &quot;yy://return/&quot;;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> url.replace(YY_RETURN_DATA, EMPTY_STR);</span><br><span class="line"><span class="comment">//【2】去掉 &quot;/[&#123;&quot;responseId&quot;:&quot;xxxxx&quot;,&quot;responseData&quot;:&quot;xxxxx&quot;&#125;]&quot;</span></span><br><span class="line">String[] functionAndData = temp.split(SPLIT_MARK);</span><br><span class="line"><span class="keyword">if</span>(functionAndData.length &gt;= <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//【3】我们得到了 key，也就是 functionName；</span></span><br><span class="line"><span class="keyword">return</span> functionAndData[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是在 native 获取到 js 消息后调用的！</p><h2 id="7-3-getDataFromReturnUrl"><a href="#7-3-getDataFromReturnUrl" class="headerlink" title="7.3 getDataFromReturnUrl"></a>7.3 getDataFromReturnUrl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是 url 的一个例子；</span></span><br><span class="line"><span class="comment">// url = yy://return/_fetchQueue/[&#123;&quot;responseId&quot;:&quot;JAVA_CB_2_3957&quot;,&quot;responseData&quot;:&quot;xxxxx&quot;&#125;]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDataFromReturnUrl</span><span class="params">(String url)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(url.startsWith(YY_FETCH_QUEUE)) &#123;</span><br><span class="line"><span class="comment">//【1】返回了 [&#123;&quot;responseId&quot;:&quot;JAVA_CB_2_3957&quot;,&quot;responseData&quot;:&quot;xxxxx&quot;&#125;]</span></span><br><span class="line"><span class="keyword">return</span> url.replace(YY_FETCH_QUEUE, EMPTY_STR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// temp = _fetchQueue/[&#123;&quot;responseId&quot;:&quot;JAVA_CB_2_3957&quot;,&quot;responseData&quot;:&quot;Javascript Says Right back aka!&quot;&#125;]</span></span><br><span class="line"><span class="comment">//【2】对另外一种情况的处理</span></span><br><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> url.replace(YY_RETURN_DATA, EMPTY_STR);</span><br><span class="line">String[] functionAndData = temp.split(SPLIT_MARK);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(functionAndData.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; functionAndData.length; i++) &#123;</span><br><span class="line">sb.append(functionAndData[i]);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//【3】返回结果是一样的！</span></span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是在 native 获取到 js 消息后调用的，并且在【7.2】调用以后才调用！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列文章主要分析 JsBridge 框架的原理，学习 H5 和原生 WebView 的交互方式，框架选自 GitHub 上的很火的 H5 + WebView 三方库：lzyzsd/JsBridge，作者是大鬼头；&lt;/p&gt;
&lt;h1 id=&quot;1-调用接口&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="开源库源码分析" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="JsBridge" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JsBridge/"/>
    
    
    <category term="JsBridge" scheme="https://lishuaiqi.top/tags/JsBridge/"/>
    
  </entry>
  
  <entry>
    <title>JsBridge 第四篇 - H5 调用 Native 代码</title>
    <link href="https://lishuaiqi.top/2019/05/23/JsBridge4-H5--%3ENativeCodes/"/>
    <id>https://lishuaiqi.top/2019/05/23/JsBridge4-H5--%3ENativeCodes/</id>
    <published>2019-05-23T12:46:25.000Z</published>
    <updated>2019-07-07T00:42:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章主要分析 JsBridge 框架的原理，学习 H5 和原生 WebView 的交互方式，框架选自 GitHub 上的很火的 H5 + WebView 三方库：lzyzsd/JsBridge，作者是大鬼头；</p><h1 id="1-调用接口"><a href="#1-调用接口" class="headerlink" title="1 调用接口"></a>1 调用接口</h1><p>在 js 中，我们通过如下方式，使用 jsBridge 框架来和 Native 通信：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&quot;这是一个图片 &lt;img src=\&quot;a.png\&quot;/&gt; test\r\nhahaha&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//【1】通过 js 通信协议 send 方法；</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>.<span class="title function_">send</span>(</span><br><span class="line">    data</span><br><span class="line">    , <span class="keyword">function</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;show&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;repsonseData from java, data = &quot;</span> + responseData</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//【2】通过 js 通信协议 callHandler 方法；</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>.<span class="title function_">callHandler</span>(</span><br><span class="line">    <span class="string">&#x27;submitFromWeb&#x27;</span></span><br><span class="line">    , &#123;<span class="string">&#x27;param&#x27;</span>: <span class="string">&#x27;中文测试&#x27;</span>&#125;</span><br><span class="line">    , <span class="keyword">function</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;show&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;send get responseData from java, data = &quot;</span> + responseData</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><strong>send 方法</strong>；用客户端默认的 handler 处理；</li><li><strong>callHandler 方法</strong>：用指定的 handler 处理；</li></ul><p>下面我们来分析下 callHandler 和 send 方法！</p><h1 id="2-WebViewJavascriptBridge"><a href="#2-WebViewJavascriptBridge" class="headerlink" title="2 WebViewJavascriptBridge"></a>2 WebViewJavascriptBridge</h1><p>接下来进入了 js 通信协议文件中：</p><h2 id="2-1-send"><a href="#2-1-send" class="headerlink" title="2.1 send"></a>2.1 send</h2><p>用客户端默认的 handler 处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">send</span>(<span class="params">data, responseCallback</span>) &#123;</span><br><span class="line">    <span class="comment">//【--&gt;*2.3】调用 _doSend 方法；</span></span><br><span class="line">    <span class="title function_">_doSend</span>(&#123;</span><br><span class="line">        <span class="attr">data</span>: data</span><br><span class="line">    &#125;, responseCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-callHandler"><a href="#2-2-callHandler" class="headerlink" title="2.2 callHandler"></a>2.2 callHandler</h2><p>用指定的 handler 处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) &#123;</span><br><span class="line">    <span class="comment">//【--&gt;*2.3】调用 _doSend 方法；</span></span><br><span class="line">    <span class="title function_">_doSend</span>(&#123;</span><br><span class="line">        <span class="attr">handlerName</span>: handlerName,</span><br><span class="line">        <span class="attr">data</span>: data</span><br><span class="line">    &#125;, responseCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-doSend"><a href="#2-3-doSend" class="headerlink" title="2.3 _doSend"></a>2.3 _doSend</h2><p>最后都调用了 _doSend 的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sendMessage add message, 触发native处理 sendMessage</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_doSend</span>(<span class="params">message, responseCallback</span>) &#123;   </span><br><span class="line">    <span class="keyword">if</span> (responseCallback) &#123;  </span><br><span class="line">        <span class="comment">//【1】创建了一个 calbackId，并将 id 和 callback 的映射关系保存到 responseCallbacks 中；</span></span><br><span class="line">        <span class="comment">// 将 callbackId 保存到 message 中！</span></span><br><span class="line">        <span class="keyword">var</span> callbackId = <span class="string">&#x27;cb_&#x27;</span> + (uniqueId++) + <span class="string">&#x27;_&#x27;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">        responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">        message.<span class="property">callbackId</span> = callbackId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】将消息保存到 sendMessageQueue 中，创建动态 url，通知 native；</span></span><br><span class="line">    sendMessageQueue.<span class="title function_">push</span>(message);</span><br><span class="line">    <span class="comment">//【3】yy://__QUEUE_MESSAGE__，最终会触发如下方法</span></span><br><span class="line">    <span class="comment">//【--&gt;*3.1】BridgeWebView.flushMessageQueue</span></span><br><span class="line">    messagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://&#x27;</span> + <span class="variable constant_">QUEUE_HAS_MESSAGE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在前面分析过了，和前面的类似。</p><p>messagingIframe.src 最终会触发如下方法调用链：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BridgeWebViewClient.shouldOverrideUrlLoading ---&gt; BridgeWebView.flushMessageQueue</span><br></pre></td></tr></table></figure><h2 id="2-4-fetchQueue"><a href="#2-4-fetchQueue" class="headerlink" title="2.4 _fetchQueue"></a>2.4 _fetchQueue</h2><p>从 sendMessageQueue 队列中获取 message，发送给 native：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_fetchQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//【1】这里是统一处理要发给 native 的所有消息，将队列转为 string</span></span><br><span class="line">    <span class="keyword">var</span> messageQueueString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(sendMessageQueue);</span><br><span class="line">    sendMessageQueue = [];</span><br><span class="line">    <span class="comment">//【2】这里又再在页面生成 url，和之前的区别是包含数据，然后再次通过 shouldOverrideUrlLoading 方法拦截，</span></span><br><span class="line">    <span class="comment">// 捕获 url 中的数据；</span></span><br><span class="line">    <span class="keyword">if</span> (messageQueueString !== <span class="string">&#x27;[]&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;*3.3】这一次，生成的 url 将真正带有回调数据；</span></span><br><span class="line">        bizMessagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://return/_fetchQueue/&#x27;</span> + <span class="built_in">encodeURIComponent</span>(messageQueueString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里生成了一个新的 url：</p><blockquote><p>yy://://return/_fetchQueue/[{“responseId”:”xxxxxxx”,”responseData”:”xxxxxxxxxx”}]</p></blockquote><p>messagingIframe.src 最终会触发如下方法调用链：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BridgeWebViewClient.shouldOverrideUrlLoading ---&gt; BridgeWebView.handlerReturnData</span><br></pre></td></tr></table></figure><h2 id="2-5-handleMessageFromNative"><a href="#2-5-handleMessageFromNative" class="headerlink" title="2.5 _handleMessageFromNative"></a>2.5 _handleMessageFromNative</h2><p>js 代码中会处理 native 发送的 message json：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_handleMessageFromNative</span>(<span class="params">messageJSON</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(messageJSON);</span><br><span class="line">    <span class="comment">//【1】如果 receiveMessageQueue 不为 null，那么会讲她加入到</span></span><br><span class="line">    <span class="comment">// receiveMessageQueue 队列中，它是用来保存 native 发送的消息的；</span></span><br><span class="line">    <span class="keyword">if</span> (receiveMessageQueue) &#123;</span><br><span class="line">        receiveMessageQueue.<span class="title function_">push</span>(messageJSON);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;*2.6】分发来自 native 的消息；</span></span><br><span class="line">    <span class="title function_">_dispatchMessageFromNative</span>(messageJSON);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第二篇 js 协议中有讲过：</p><p>当在动态注入 js 脚本时，会执行 init 方法，那里会将 receiveMessageQueue 置为 null，同时处理已经包含的 native 消息；</p><p>所以这里就直接 _dispatchMessageFromNative 了；</p><h2 id="2-6-dispatchMessageFromNative"><a href="#2-6-dispatchMessageFromNative" class="headerlink" title="2.6 _dispatchMessageFromNative"></a>2.6 _dispatchMessageFromNative</h2><p>js 处理 native 层的回调消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_dispatchMessageFromNative</span>(<span class="params">messageJSON</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> message = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(messageJSON);</span><br><span class="line">        <span class="keyword">var</span> responseCallback;</span><br><span class="line">        <span class="comment">//【1】这里 js 处理消息回调，不多说了！</span></span><br><span class="line">        <span class="keyword">if</span> (message.<span class="property">responseId</span>) &#123;</span><br><span class="line">            responseCallback = responseCallbacks[message.<span class="property">responseId</span>];</span><br><span class="line">            <span class="keyword">if</span> (!responseCallback) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">responseCallback</span>(message.<span class="property">responseData</span>);</span><br><span class="line">            <span class="keyword">delete</span> responseCallbacks[message.<span class="property">responseId</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ... ... ...<span class="comment">// 这里是处理 java 回调的，之前分析过；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-BridgeWebView"><a href="#3-BridgeWebView" class="headerlink" title="3 BridgeWebView"></a>3 BridgeWebView</h1><h2 id="3-1-flushMessageQueue"><a href="#3-1-flushMessageQueue" class="headerlink" title="3.1 flushMessageQueue"></a>3.1 flushMessageQueue</h2><p>native 读取 js 的命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">flushMessageQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//【1】必须在主线程（loadUrl）</span></span><br><span class="line"><span class="keyword">if</span> (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123;</span><br><span class="line">    <span class="comment">//【---&gt;*3.2】执行 js 脚本</span></span><br><span class="line">loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, <span class="keyword">new</span> <span class="title class_">CallBackFunction</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【*3.1.1】这个回调是用来分发 url 对应的数据给相应的回调！</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCallBack</span><span class="params">(String data)</span> &#123;</span><br><span class="line"><span class="comment">//【1】用于存储所有的消息；</span></span><br><span class="line">List&lt;Message&gt; list = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">list = Message.toArrayList(data);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (list == <span class="literal">null</span> || list.size() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    <span class="comment">//【2】遍历处理下每一个 Message。</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> list.get(i);</span><br><span class="line"><span class="type">String</span> <span class="variable">responseId</span> <span class="operator">=</span> m.getResponseId();</span><br><span class="line"><span class="comment">//【3】如果 Message.responseId 不为 null，说明这是 js 反馈给 native 的回调数据。</span></span><br><span class="line"><span class="comment">// 此时 responseId 表示 native 回调函数的 id！</span></span><br><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(responseId)) &#123;</span><br><span class="line">    ... ... ... ...<span class="comment">// 这里前面有分析过；</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//【4】这里是我们要关注的地方：</span></span><br><span class="line">    <span class="comment">// 这种情况是属于 js 主动向 Handler 发送消息的时候，callbackId 显然是 js 的回调函数 id；</span></span><br><span class="line"><span class="type">CallBackFunction</span> <span class="variable">responseFunction</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">callbackId</span> <span class="operator">=</span> m.getCallbackId();</span><br><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(callbackId)) &#123;</span><br><span class="line">    <span class="comment">//【4.1】有 js 回调的情况，进入这里；</span></span><br><span class="line">responseFunction = <span class="keyword">new</span> <span class="title class_">CallBackFunction</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCallBack</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    <span class="comment">//【4.1.1】可以看到，这里创建了一个 Message，作为给 js 的回调信息；</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">responseMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">responseMsg.setResponseId(callbackId);</span><br><span class="line">responseMsg.setResponseData(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//【--&gt;*3.4】将消息加入 list，等待处理；</span></span><br><span class="line">queueMessage(responseMsg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//【4.2】无 js 回调的情况，进入这里；</span></span><br><span class="line">responseFunction = <span class="keyword">new</span> <span class="title class_">CallBackFunction</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCallBack</span><span class="params">(String data)</span> &#123;</span><br><span class="line"><span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【4.3】js 指定了 native 处理数据的 handler！</span></span><br><span class="line">BridgeHandler handler;</span><br><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(m.getHandlerName())) &#123;</span><br><span class="line">handler = messageHandlers.get(m.getHandlerName());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">handler = defaultHandler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【4.4】处理 js 的 message，并发送回调信息给 js。</span></span><br><span class="line"><span class="keyword">if</span> (handler != <span class="literal">null</span>)&#123;</span><br><span class="line">handler.handler(m.getData(), responseFunction);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看大了，给 js 反馈回调的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">responseMsg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">responseMsg.setResponseId(callbackId);</span><br><span class="line">responseMsg.setResponseData(data);</span><br></pre></td></tr></table></figure><p>js 传入的 callbackId 被设置到了 responseId 上了；</p><h2 id="3-2-loadUrl"><a href="#3-2-loadUrl" class="headerlink" title="3.2 loadUrl"></a>3.2 loadUrl</h2><p>参数 jsUrl 是 javascript:WebViewJavascriptBridge._fetchQueue();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadUrl</span><span class="params">(String jsUrl, CallBackFunction returnCallback)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;*2.4】执行 jsUrl 命令；</span></span><br><span class="line"><span class="built_in">this</span>.loadUrl(jsUrl);</span><br><span class="line">    <span class="comment">//【2】同时将 CallBackFunction 放入到 responseCallbacks 中；</span></span><br><span class="line">responseCallbacks.put(BridgeUtil.parseFunctionName(jsUrl), returnCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有分析过，对 js 命令做了处理，生成了 key：</p><blockquote><p>javascript:WebViewJavascriptBridge._fetchQueue(); –&gt; _fetchQueue</p></blockquote><p>用于保存回调；</p><h2 id="3-3-handlerReturnData"><a href="#3-3-handlerReturnData" class="headerlink" title="3.3 handlerReturnData"></a>3.3 handlerReturnData</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">handlerReturnData</span><span class="params">(String url)</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;3*7.2】再次解析 url，获得回调的 key：functionName</span></span><br><span class="line"><span class="type">String</span> <span class="variable">functionName</span> <span class="operator">=</span> BridgeUtil.getFunctionFromReturnUrl(url);</span><br><span class="line"><span class="comment">//【1】functionName 就是 _fetchQueue，这里我们获得了【*3.3】注册的 callback</span></span><br><span class="line"><span class="type">CallBackFunction</span> <span class="variable">f</span> <span class="operator">=</span> responseCallbacks.get(functionName);</span><br><span class="line"><span class="comment">//【--&gt;3*7.2】获得 js 的回调返回数据；</span></span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> BridgeUtil.getDataFromReturnUrl(url);</span><br><span class="line"><span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//【--&gt;*3.1.1】执行回调，处理数据！</span></span><br><span class="line">f.onCallBack(data);</span><br><span class="line"><span class="comment">//【2】删除该 _fetchQueue 对应的回调（我觉得可以不删除的）</span></span><br><span class="line">responseCallbacks.remove(functionName);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发前面的 _fetchQueue 对应的回调；</p><h2 id="3-4-queueMessage"><a href="#3-4-queueMessage" class="headerlink" title="3.4 queueMessage"></a>3.4 queueMessage</h2><p>加入 message list：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">queueMessage</span><span class="params">(Message m)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (startupMessage != <span class="literal">null</span>) &#123;</span><br><span class="line">startupMessage.add(m);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;*3.5】分发 message 给 js；</span></span><br><span class="line">dispatchMessage(m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-dispatchMessage"><a href="#3-5-dispatchMessage" class="headerlink" title="3.5 dispatchMessage"></a>3.5 dispatchMessage</h2><p>native 给 js 发送消息的关键点，参数 message 是一个消息对象！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(Message m)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】将 message 转为 json</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">messageJson</span> <span class="operator">=</span> m.toJson();</span><br><span class="line">    <span class="comment">//【2】为 message json 字符串转义特殊字符；</span></span><br><span class="line">    messageJson = messageJson.replaceAll(<span class="string">&quot;(\\\\)([^utrn])&quot;</span>, <span class="string">&quot;\\\\\\\\$1$2&quot;</span>);</span><br><span class="line">    messageJson = messageJson.replaceAll(<span class="string">&quot;(?&lt;=[^\\\\])(\&quot;)&quot;</span>, <span class="string">&quot;\\\\\&quot;&quot;</span>);</span><br><span class="line">messageJson = messageJson.replaceAll(<span class="string">&quot;(?&lt;=[^\\\\])(\&#x27;)&quot;</span>, <span class="string">&quot;\\\\\&#x27;&quot;</span>);</span><br><span class="line">messageJson = messageJson.replaceAll(<span class="string">&quot;%7B&quot;</span>, URLEncoder.encode(<span class="string">&quot;%7B&quot;</span>));</span><br><span class="line">messageJson = messageJson.replaceAll(<span class="string">&quot;%7D&quot;</span>, URLEncoder.encode(<span class="string">&quot;%7D&quot;</span>));</span><br><span class="line">messageJson = messageJson.replaceAll(<span class="string">&quot;%22&quot;</span>, URLEncoder.encode(<span class="string">&quot;%22&quot;</span>));</span><br><span class="line"><span class="comment">//【3】创建要执行的 js 代码，用于和 H5 通信；</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">javascriptCommand</span> <span class="operator">=</span> String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson);</span><br><span class="line">    <span class="comment">//【4】必须要找主线程才会将数据传递出去 --- 划重点</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123;</span><br><span class="line">        【--&gt;*<span class="number">2.5</span>】执行 js 代码；</span><br><span class="line">        <span class="built_in">this</span>.loadUrl(javascriptCommand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BridgeUtil 是一个工具类，里面主要是一些通信协议码，以及一些工具方法，native 和 H5 通信的时候，本质上是执行 js 代码：</p><blockquote><p>final static String JS_HANDLE_MESSAGE_FROM_JAVA =<br>“javascript:WebViewJavascriptBridge._handleMessageFromNative(‘%s’);”;</p></blockquote><p>可以看到，执行的 js 代码如下：</p><blockquote><p>javascript:WebViewJavascriptBridge._handleMessageFromNative(JsonString of Message);</p></blockquote><p>我相信大家知道，这个方法将进入通信协议 js 文件了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列文章主要分析 JsBridge 框架的原理，学习 H5 和原生 WebView 的交互方式，框架选自 GitHub 上的很火的 H5 + WebView 三方库：lzyzsd/JsBridge，作者是大鬼头；&lt;/p&gt;
&lt;h1 id=&quot;1-调用接口&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="开源库源码分析" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="JsBridge" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JsBridge/"/>
    
    
    <category term="JsBridge" scheme="https://lishuaiqi.top/tags/JsBridge/"/>
    
  </entry>
  
  <entry>
    <title>JsBridge 第二篇 - js 通信协议分析</title>
    <link href="https://lishuaiqi.top/2019/05/21/JsBridge2-jsCommunicationProtocol/"/>
    <id>https://lishuaiqi.top/2019/05/21/JsBridge2-jsCommunicationProtocol/</id>
    <published>2019-05-21T12:46:25.000Z</published>
    <updated>2019-07-03T22:46:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章主要分析 JsBridge 框架的原理，学习 H5 和原生 WebView 的交互方式，框架选自 GitHub 上的很火的 H5 + WebView 三方库：lzyzsd/JsBridge，作者是大鬼头；</p><h1 id="1-初步分析"><a href="#1-初步分析" class="headerlink" title="1 初步分析"></a>1 初步分析</h1><p>下面分析下 jsBridge 框架的通信协议，他是实际上是一个 js 文件，位于 assets 目录下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebViewJavascriptBridge.js</span><br></pre></td></tr></table></figure><p>这个 js 文件作为协议，决定了 H5 和 Native 代码通信方式和通信数据！</p><p><br> </p><p>这里就有一个问题了，他是如何被加载并生效的呢，有两种方式：</p><ul><li>第一种方式：通过 H5 直接加载；</li><li>第二种方式：通过动态注入的方式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs);</span><br></pre></td></tr></table></figure><p>我们的 jsBridge 框架也是用的第二种方式，具体的逻辑我们后面再分析；</p><h1 id="2-协议代码分析"><a href="#2-协议代码分析" class="headerlink" title="2 协议代码分析"></a>2 协议代码分析</h1><p>下面我们分析下 js 协议代码的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//【1】判断变量 WebViewJavascriptBridge 是否初始化过了；</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这里来看的话，其实他是一个 js function，当我们将 js 动态注入到 H5 中时，这么这个 function 就会执行；</p><h2 id="2-1-内部关键变量"><a href="#2-1-内部关键变量" class="headerlink" title="2.1 内部关键变量"></a>2.1 内部关键变量</h2><p>js 文件中定义了一些关键的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> messagingIframe; <span class="comment">// 这两个变量用与 android 获取 js 的数据；</span></span><br><span class="line"><span class="keyword">var</span> bizMessagingIframe;</span><br><span class="line"><span class="keyword">var</span> sendMessageQueue = [];  <span class="comment">// 发送的消息队列，H5 传递给 Native</span></span><br><span class="line"><span class="keyword">var</span> receiveMessageQueue = []; <span class="comment">// 接受的消息队列，Native 传递给 H5</span></span><br><span class="line"><span class="keyword">var</span> messageHandlers = &#123;&#125;; <span class="comment">// js 处理 native 消息的 handler 数组！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> = <span class="string">&#x27;yy&#x27;</span>; <span class="comment">// 消息的 scheme，类似与 file，content；</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">QUEUE_HAS_MESSAGE</span> = <span class="string">&#x27;__QUEUE_MESSAGE__/&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> responseCallbacks = &#123;&#125;; <span class="comment">// js 端的回调数组；</span></span><br><span class="line"><span class="keyword">var</span> uniqueId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">... ... ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个很重要，window.WebViewJavascriptBridge 是 H5 和 Native 通信的</span></span><br><span class="line"><span class="comment">// 关键点！</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">WebViewJavascriptBridge</span> = <span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span> = &#123;</span><br><span class="line">    <span class="attr">init</span>: init,</span><br><span class="line">    <span class="attr">send</span>: send,</span><br><span class="line">    <span class="attr">registerHandler</span>: registerHandler,</span><br><span class="line">    <span class="attr">callHandler</span>: callHandler,</span><br><span class="line">    <span class="attr">_fetchQueue</span>: _fetchQueue,</span><br><span class="line">    <span class="attr">_handleMessageFromNative</span>: _handleMessageFromNative</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面最关键的一个对象就是 WebViewJavascriptBridge，H5 和 Native 都会通过它。</p><p>这个 window.WebViewJavascriptBridge 内部包含了一些函数对象，这些 function 都定义在 js 内部！</p><h2 id="2-2-动态注入初始化"><a href="#2-2-动态注入初始化" class="headerlink" title="2.2 动态注入初始化"></a>2.2 动态注入初始化</h2><p>这里是很关键的地方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doc = <span class="variable language_">document</span>;</span><br><span class="line"><span class="comment">//【1】创建消息队列，一个是 index，一个是消息体；</span></span><br><span class="line"><span class="title function_">_createQueueReadyIframe</span>(doc);</span><br><span class="line"><span class="title function_">_createQueueReadyIframe4biz</span>(doc);</span><br><span class="line"><span class="comment">//【2】创建一个 event，类型为 &#x27;WebViewJavascriptBridgeReady&#x27;</span></span><br><span class="line"><span class="comment">// 然后分发 event；</span></span><br><span class="line"><span class="keyword">var</span> readyEvent = doc.<span class="title function_">createEvent</span>(<span class="string">&#x27;Events&#x27;</span>);</span><br><span class="line">readyEvent.<span class="title function_">initEvent</span>(<span class="string">&#x27;WebViewJavascriptBridgeReady&#x27;</span>);</span><br><span class="line">readyEvent.<span class="property">bridge</span> = <span class="title class_">WebViewJavascriptBridge</span>;</span><br><span class="line">doc.<span class="title function_">dispatchEvent</span>(readyEvent); <span class="comment">//【*2.2.1】关键点！！</span></span><br></pre></td></tr></table></figure><p>在动态注入的时候，会执行初始化的操作：</p><ul><li>创建了一个 event；</li><li>初始化 event，事件类型为 ‘WebViewJavascriptBridgeReady’；</li><li>readyEvent.bridge 设置为我们上面创建的 ‘WebViewJavascriptBridgeReady’ 对象；</li><li>doc.dispatchEvent 分发 event；</li></ul><p><br></p><p><strong>这个 event 是在哪里做响应</strong>的呢？</p><p>是在 H5 里面，这个 H5 在加载时候，会执行内部 js 脚本，并通过 document.addEventListener 方法设置该 event 的监听器；</p><h3 id="2-2-1-H5-加载启动-event-监听"><a href="#2-2-1-H5-加载启动-event-监听" class="headerlink" title="2.2.1 H5 加载启动 event 监听"></a>2.2.1 H5 加载启动 event 监听</h3><p>H5 的页面里面，是有下面的一段 js 脚本，在 webview.loadUrl 后会直接加载该 js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">... ... ...</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">connectWebViewJavascriptBridge</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123;</span><br><span class="line">        <span class="comment">//【2】如果 window.WebViewJavascriptBridge 已经存在</span></span><br><span class="line">        <span class="comment">// 直接执行函数闭包；</span></span><br><span class="line">        <span class="title function_">callback</span>(<span class="title class_">WebViewJavascriptBridge</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【3】否则我们就注册一个 EventListener，监听 WebViewJavascriptBridgeReady 事件；</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">            <span class="string">&#x27;WebViewJavascriptBridgeReady&#x27;</span></span><br><span class="line">            , <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">// 事件出发后，执行函数闭包；</span></span><br><span class="line">                <span class="title function_">callback</span>(<span class="title class_">WebViewJavascriptBridge</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【1】执行 connectWebViewJavascriptBridge 方法，传入了一个 js 闭包;</span></span><br><span class="line"><span class="title function_">connectWebViewJavascriptBridge</span>(<span class="keyword">function</span>(<span class="params">bridge</span>) &#123;</span><br><span class="line">     <span class="comment">//【*2.2.2】下一步初始化！</span></span><br><span class="line">     ... ... ... ...</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，window.WebViewJavascriptBridge 不存在，那么会注册一个 EventListener！</p><p>等待 event 触发后，执行 callback！</p><h3 id="2-2-2-event-出发点后下一步初始化"><a href="#2-2-2-event-出发点后下一步初始化" class="headerlink" title="2.2.2 event 出发点后下一步初始化"></a>2.2.2 event 出发点后下一步初始化</h3><p>callback 实际上就是闭包，参数 bridge 就是 js 协议中创建的 var WebViewJavascriptBridge：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【*2.3.1】执行 WebViewJavascriptBridge 对象的 init 方法，</span></span><br><span class="line"><span class="comment">// 传入一个函数闭包！</span></span><br><span class="line">bridge.<span class="title function_">init</span>(<span class="keyword">function</span>(<span class="params">message, responseCallback</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;JS got a message&#x27;</span>, message);</span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">        <span class="string">&#x27;Javascript Responds&#x27;</span>: <span class="string">&#x27;测试中文!&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;JS responding with&#x27;</span>, data);</span><br><span class="line">        <span class="comment">//【1】函数闭包出发后，会回调 responseCallback</span></span><br><span class="line">        <span class="title function_">responseCallback</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//【*2.3.1】执行 WebViewJavascriptBridge 对象的 registerHandler 方法，</span></span><br><span class="line"><span class="comment">// 传入一个函数闭包！</span></span><br><span class="line">bridge.<span class="title function_">registerHandler</span>(<span class="string">&quot;functionInJs&quot;</span>, <span class="keyword">function</span>(<span class="params">data, responseCallback</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;show&quot;</span>).<span class="property">innerHTML</span> = (<span class="string">&quot;data from Java: = &quot;</span> + data);</span><br><span class="line">    <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">        <span class="keyword">var</span> responseData = <span class="string">&quot;Javascript Says Right back aka!&quot;</span>;</span><br><span class="line">        <span class="comment">//【2】函数闭包出发后，会回调 responseCallback，通知 native；</span></span><br><span class="line">        <span class="title function_">responseCallback</span>(responseData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于 init 和 registerHandler 我们会在下面分析：</p><h2 id="2-3-核心函数"><a href="#2-3-核心函数" class="headerlink" title="2.3 核心函数"></a>2.3 核心函数</h2><p>下面来分析下关键的协议函数：</p><h3 id="2-3-1-init"><a href="#2-3-1-init" class="headerlink" title="2.3.1 init"></a>2.3.1 init</h3><p>init 方法用于设置 <strong>js 处理 native 消息的默认 handler</strong>：</p><p>同时也会<strong>分发已经被添加到 receiveMessageQueue 接受队列中的 native 的消息</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params">messageHandler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">WebViewJavascriptBridge</span>.<span class="property">_messageHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;WebViewJavascriptBridge.init called twice&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】设置 js 用于处理 native 消息的 handler</span></span><br><span class="line">    <span class="comment">// 实际上就是【*2.2.2】中的函数闭包；</span></span><br><span class="line">    <span class="title class_">WebViewJavascriptBridge</span>.<span class="property">_messageHandler</span> = messageHandler;</span><br><span class="line">    <span class="comment">//【2】分发已经被添加到 receiveMessageQueue 接受队列中的 native 的消息</span></span><br><span class="line">    <span class="keyword">var</span> receivedMessages = receiveMessageQueue;</span><br><span class="line">    receiveMessageQueue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; receivedMessages.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//【*2.3.3】分发来自 native 的消息；</span></span><br><span class="line">        <span class="title function_">_dispatchMessageFromNative</span>(receivedMessages[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数 messageHandler 就是【*2.2.2】中的函数闭包；</p><h3 id="2-3-2-registerHandler"><a href="#2-3-2-registerHandler" class="headerlink" title="2.3.2 registerHandler"></a>2.3.2 registerHandler</h3><p><strong>注册特定的消息处理 handler</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">registerHandler</span>(<span class="params">handlerName, handler</span>) &#123;</span><br><span class="line">    <span class="comment">//【1】实际上就是向数组中放值；</span></span><br><span class="line">    messageHandlers[handlerName] = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>messageHandlers 之前有说过，是 js 处理 native 消息的 handler 数组！</p><ul><li>index 是 handler 的名称，根据前面代码，名称是 “functionInJs”；</li><li>value 是一个函数闭包；</li></ul><h3 id="2-3-3-dispatchMessageFromNative"><a href="#2-3-3-dispatchMessageFromNative" class="headerlink" title="2.3.3 _dispatchMessageFromNative"></a>2.3.3 _dispatchMessageFromNative</h3><p>这个方法是 <strong>js 层</strong>调用的，<strong>分发来自 native 的消息</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_dispatchMessageFromNative</span>(<span class="params">messageJSON</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//【2】JSON 字符串转化 JSON 对象 message；</span></span><br><span class="line">        <span class="keyword">var</span> message = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(messageJSON);</span><br><span class="line">        <span class="keyword">var</span> responseCallback;</span><br><span class="line">        <span class="comment">//【2】这里我们知道 native 发送消息完成，接下来 js 会处理消息，并将结果</span></span><br><span class="line">        <span class="comment">// 通过 callback 传递给 native 层；</span></span><br><span class="line">        <span class="keyword">if</span> (message.<span class="property">responseId</span>) &#123;</span><br><span class="line">            <span class="comment">//【2.1】如果 native 指定了消息的 responseId，这种情况对应的情况是：</span></span><br><span class="line">            <span class="comment">// js 发送消息给 native，此时 native 发送回调消息给 js；</span></span><br><span class="line">            <span class="comment">// 那么我们就要在 responseCallback 数组中找到对应的 responseCallback</span></span><br><span class="line">            responseCallback = responseCallbacks[message.<span class="property">responseId</span>];</span><br><span class="line">            <span class="keyword">if</span> (!responseCallback) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【2.2】然后执行 js 的 callback；</span></span><br><span class="line">            <span class="title function_">responseCallback</span>(message.<span class="property">responseData</span>);</span><br><span class="line">            <span class="comment">//【2.3】删掉该 callback</span></span><br><span class="line">            <span class="keyword">delete</span> responseCallbacks[message.<span class="property">responseId</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【2.4】没有指定 responseId，但是指定了 callbackId，这种情况对应的是：</span></span><br><span class="line">            <span class="comment">// native 发送消息给 js，此时 js 发送回调消息给 native；</span></span><br><span class="line">            <span class="keyword">if</span> (message.<span class="property">callbackId</span>) &#123;</span><br><span class="line">                <span class="comment">//【2.4.1】获得 callbackId，并创建一个 responseCallback</span></span><br><span class="line">                <span class="comment">// 实际上就是一个函数闭包，该闭包会执行 _doSend 方法！</span></span><br><span class="line">                <span class="keyword">var</span> callbackResponseId = message.<span class="property">callbackId</span>;</span><br><span class="line">                responseCallback = <span class="keyword">function</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">                    <span class="comment">//【*2.3.4】发送回调给 native，但是此时是不触发的，出发的点在下面；</span></span><br><span class="line">                    <span class="title function_">_doSend</span>(&#123;</span><br><span class="line">                        <span class="attr">responseId</span>: callbackResponseId,</span><br><span class="line">                        <span class="attr">responseData</span>: responseData</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【2.5】找到处理 native 消息的 handler，如果没有指定 handlerName</span></span><br><span class="line">            <span class="comment">// 那么就是 init 方法注册的默认 handler；否则就是特定的 handler</span></span><br><span class="line">            <span class="comment">// 其实就是前面 &quot;functionInJs&quot; 对应的 handler；</span></span><br><span class="line">            <span class="keyword">var</span> handler = <span class="title class_">WebViewJavascriptBridge</span>.<span class="property">_messageHandler</span>;</span><br><span class="line">            <span class="keyword">if</span> (message.<span class="property">handlerName</span>) &#123;</span><br><span class="line">                handler = messageHandlers[message.<span class="property">handlerName</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【2.6】这个 handler 其实就是一个函数闭包，见【*2.2.2】，最后会回调</span></span><br><span class="line">            <span class="comment">// responseCallback 接口，就是上面的 function；</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="title function_">handler</span>(message.<span class="property">data</span>, responseCallback);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (exception) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">console</span> != <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebViewJavascriptBridge: WARNING: javascript handler threw.&quot;</span>, message, exception);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里看起来，似乎很清晰呢；</p><h3 id="2-3-4-doSend"><a href="#2-3-4-doSend" class="headerlink" title="2.3.4 _doSend"></a>2.3.4 _doSend</h3><p>这个方法是 <strong>js 层</strong>调用，用于<strong>发送消息给 native 端</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_doSend</span>(<span class="params">message, responseCallback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">        <span class="comment">//【1】计算回调 id；</span></span><br><span class="line">        <span class="keyword">var</span> callbackId = <span class="string">&#x27;cb_&#x27;</span> + (uniqueId++) + <span class="string">&#x27;_&#x27;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">        <span class="comment">//【2】以 index 为回调 id，value 为具体的回调接口的形式，保存到 responseCallbacks 数组重；</span></span><br><span class="line">        responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">        <span class="comment">//【3】message.callbackId 为计算出的回调 id；</span></span><br><span class="line">        message.<span class="property">callbackId</span> = callbackId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】将该 message 加入到 sendMessageQueue 队列中，要发送给 native；</span></span><br><span class="line">    sendMessageQueue.<span class="title function_">push</span>(message);</span><br><span class="line">    <span class="comment">//【6】这个地方会通过 messagingIframe.src 生成一个 Url，这会被 Webview.shouldOverrideUrlLoading 拦截到；</span></span><br><span class="line">    messagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://&#x27;</span> + <span class="variable constant_">QUEUE_HAS_MESSAGE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意第二个参数 responseCallback：</p><ul><li>如果 responseCallback 不为 null，说明本次消息需要回调通知；</li><li>如果 responseCallback 为 null，说明不需要回调通知；</li></ul><p>该方法创建了一个动态的 url，这会被 Webview.shouldOverrideUrlLoading 拦截到，这是该库 android 获得 js 数据的方式；</p><p>但是这里并不是真正获取数据的地方，该 url 会触发一次 Webview.shouldOverrideUrlLoading；</p><p>然后 android 又会调用 js 的 _fetchQueue 方法，这时，又会生成一个 url，这个 url 才会保存了要传递给 android 的消息；</p><p>具体可以看 2.3.8 的 _fetchQueue 方法；</p><h3 id="2-3-5-callHandler"><a href="#2-3-5-callHandler" class="headerlink" title="2.3.5 callHandler"></a>2.3.5 callHandler</h3><p>这个方法是 <strong>js 层</strong>调用的，<strong>通过这个接口来调用 native 方法</strong>：</p><ul><li><strong>handlerName</strong>：js 处理消息的 handler 名称，这个 handler 是 <strong>native 层注册到 js 的</strong>；</li><li><strong>data</strong>：native 层传递的数据；</li><li><strong>responseCallback</strong>：接受回调的接口，native 层处理完数据会回调；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) &#123;</span><br><span class="line">    <span class="comment">//【*2.3.4】调用 _doSend 方法发送消息给 js，注意这里第二个参数</span></span><br><span class="line">    <span class="comment">// 不为 null，因为 js 短需要收到回调；</span></span><br><span class="line">    <span class="title function_">_doSend</span>(&#123;</span><br><span class="line">        <span class="attr">handlerName</span>: handlerName,</span><br><span class="line">        <span class="attr">data</span>: data</span><br><span class="line">    &#125;, responseCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里第二个参数不为 null，因为 js 短需要收到回调；</p><p>该方法设置 handlerName，所以 native 会使用指定 handlerName 的 handler 去处理；</p><h3 id="2-3-6-send"><a href="#2-3-6-send" class="headerlink" title="2.3.6 send"></a>2.3.6 send</h3><p>这个方法也是 <strong>js 层</strong>调用的，<strong>通过这个接口来调用 native 方法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">send</span>(<span class="params">data, responseCallback</span>) &#123;</span><br><span class="line">    <span class="title function_">_doSend</span>(&#123;</span><br><span class="line">        <span class="attr">data</span>: data</span><br><span class="line">    &#125;, responseCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到，他并没有设置 handlerName，所以 native 会使用默认的 handler 去处理；</p><h3 id="2-3-7-handleMessageFromNative"><a href="#2-3-7-handleMessageFromNative" class="headerlink" title="2.3.7 _handleMessageFromNative"></a>2.3.7 _handleMessageFromNative</h3><p>这个方法是 <strong>native 层</strong>调用的，<strong>以 json string 的形式发送数据给 js</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_handleMessageFromNative</span>(<span class="params">messageJSON</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(messageJSON);</span><br><span class="line">    <span class="comment">//【1】如果 receiveMessageQueue 不为 null，那就直接添加到 receiveMessageQueue 队列中去；</span></span><br><span class="line">    <span class="keyword">if</span> (receiveMessageQueue) &#123;</span><br><span class="line">        receiveMessageQueue.<span class="title function_">push</span>(messageJSON);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【*2.3.3】处理 native 传递的数据；</span></span><br><span class="line">    <span class="title function_">_dispatchMessageFromNative</span>(messageJSON);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很简单，就不多说了；</p><h3 id="2-3-8-fetchQueue"><a href="#2-3-8-fetchQueue" class="headerlink" title="2.3.8 _fetchQueue"></a>2.3.8 _fetchQueue</h3><p>这个方法是 <strong>native 层</strong>调用的，<strong>用于获取 sendMessageQueue 队列中的消息</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_fetchQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//【1】这里是统一处理要发给 native 的所有消息，将队列转为 string</span></span><br><span class="line">    <span class="keyword">var</span> messageQueueString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(sendMessageQueue);</span><br><span class="line">    sendMessageQueue = [];</span><br><span class="line">    <span class="comment">//【2】这里又再在页面生成 url，和之前的区别是包含数据，然后通过 shouldOverrideUrlLoading 方法拦截，捕获 url 中的数据；</span></span><br><span class="line">    <span class="keyword">if</span> (messageQueueString !== <span class="string">&#x27;[]&#x27;</span>) &#123;</span><br><span class="line">        bizMessagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://return/_fetchQueue/&#x27;</span> + <span class="built_in">encodeURIComponent</span>(messageQueueString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很简单，不多说了，关于 H5 和 Native 通信的流程，后续再分析！</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>关于 js 通信协议的相关分析到这里就结束了。</p><p>这里我自己也有点疑惑，对于 android 获取 js 数据的方式，该库并没有使用 @JavascriptInterface 注解，通过如下方式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">WebData</span>(), <span class="string">&quot;webdata&quot;</span>);</span><br></pre></td></tr></table></figure><p>通过查阅相关资料，可能有如下的原因：</p><ul><li><strong>安全隐患</strong>：这是因为同源规则 (SOP) 不适用与该方法，加上第三方 JavaScript 库或来自一个陌生域名的 iframe 可能在 Java 层访问这些被暴露的方法。因此，攻击者可通过一个 XSS 漏洞执行原生代码或者注入病毒代码到应用程序中。</li><li><strong>兼容性</strong>：JavaScript 层中暴露的 Java 对象的所有公有方法在 Android 版本低于 JerryBean MRI(API Level 17) 以下时可访问。而在 Google API 17 （4.２）以上，暴露的函数必须通过 @JavaScriptInterface 注释来防止方法的暴露</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列文章主要分析 JsBridge 框架的原理，学习 H5 和原生 WebView 的交互方式，框架选自 GitHub 上的很火的 H5 + WebView 三方库：lzyzsd/JsBridge，作者是大鬼头；&lt;/p&gt;
&lt;h1 id=&quot;1-初步分析&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="开源库源码分析" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="JsBridge" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JsBridge/"/>
    
    
    <category term="JsBridge" scheme="https://lishuaiqi.top/tags/JsBridge/"/>
    
  </entry>
  
  <entry>
    <title>JsBridge 第一篇 - 框架整体结构和基本使用</title>
    <link href="https://lishuaiqi.top/2019/05/20/JsBridge1-frameworkStructureAndBaseUsages/"/>
    <id>https://lishuaiqi.top/2019/05/20/JsBridge1-frameworkStructureAndBaseUsages/</id>
    <published>2019-05-20T12:46:25.000Z</published>
    <updated>2019-07-03T22:41:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章主要分析 JsBridge 框架的原理，学习 H5 和原生 WebView 的交互方式，框架选自 GitHub 上的很火的 H5 + WebView 三方库：lzyzsd/JsBridge，作者是大鬼头；</p><h1 id="1-工程结构"><a href="#1-工程结构" class="headerlink" title="1 工程结构"></a>1 工程结构</h1><p>我们先来看看 lib 的主要文件结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|____src</span><br><span class="line">| |____main</span><br><span class="line">| | |____java</span><br><span class="line">| | | |____com</span><br><span class="line">| | | | |____github</span><br><span class="line">| | | | | |____lzyzsd</span><br><span class="line">| | | | | | |____jsbridge</span><br><span class="line">| | | | | | | |____Message.java</span><br><span class="line">| | | | | | | |____WebViewJavascriptBridge.java</span><br><span class="line">| | | | | | | |____DefaultHandler.java</span><br><span class="line">| | | | | | | |____BridgeWebView.java</span><br><span class="line">| | | | | | | |____BridgeWebViewClient.java</span><br><span class="line">| | | | | | | |____CallBackFunction.java</span><br><span class="line">| | | | | | | |____BridgeHandler.java</span><br><span class="line">| | | | | | | |____BridgeUtil.java</span><br><span class="line">| | |____assets</span><br><span class="line">| | | |____WebViewJavascriptBridge.js</span><br></pre></td></tr></table></figure><p>可以看到，核心的代码在 asserts 和 jsbridge 目录下。</p><ul><li>js 文件是是通信的协议，H5 会出发 js 脚本中的语句，然后把通信的数据传递给 WebView；</li><li>jsbridge 目录下的 .java 文件则是和 Native 层的逻辑相关；</li></ul><p>这里先不详细分析每个文件的具体逻辑，我们后面分析交互流程的时候会讲；</p><h1 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2 基本使用"></a>2 基本使用</h1><p>具体的使用主要分为如下几个部分，我会将 Demo 中的一些重点代码块，用注视标注出来：</p><h2 id="2-1-初始化-BridgeWebView："><a href="#2-1-初始化-BridgeWebView：" class="headerlink" title="2.1 初始化 BridgeWebView："></a>2.1 初始化 BridgeWebView：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">webView = (BridgeWebView) findViewById(R.id.webView);</span><br><span class="line">button = (Button) findViewById(R.id.button);</span><br><span class="line">button.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//【1】设置默认的消息处理回调；</span></span><br><span class="line">webView.setDefaultHandler(<span class="keyword">new</span> <span class="title class_">DefaultHandler</span>());</span><br><span class="line"><span class="comment">//【2】设置 WebChromeClient 对象，无关不分析；</span></span><br><span class="line">webView.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>() &#123;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然，这里的 WebChromeClient 其实没有太大的用处，而真正有用的是其内部的：WebViewClient 对象，这个我们后面单独去分析 BridgeWebView 的时候，就知道 WebViewClient 的具体逻辑了；</p><h2 id="2-2-注册回调-Handler-到-webview-中："><a href="#2-2-注册回调-Handler-到-webview-中：" class="headerlink" title="2.2 注册回调 Handler 到 webview 中："></a>2.2 注册回调 Handler 到 webview 中：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】加载 H5 页面；</span></span><br><span class="line">webView.loadUrl(<span class="string">&quot;file:///android_asset/demo.html&quot;</span>);</span><br><span class="line"><span class="comment">//【2】注册了一个 BridgeHandler 回调对象，用于处理 js 的消息并回调通知；</span></span><br><span class="line">webView.registerHandler(<span class="string">&quot;submitFromWeb&quot;</span>, <span class="keyword">new</span> <span class="title class_">BridgeHandler</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(String data, CallBackFunction function)</span> &#123;</span><br><span class="line">Log.i(TAG, <span class="string">&quot;handler = submitFromWeb, data from web = &quot;</span> + data);</span><br><span class="line">        function.onCallBack(<span class="string">&quot;submitFromWeb exe, response data 中文 from Java&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>BridgeHandler 是一个接口，面向接口编程，前面的 DefaultHandler 实现了这个接口！</p><p>可以看到 BridgeHandler 是用于处理 H5 发送给 Native 的消息的；</p><p>而 CallBackFunction 则是用于回调结果给 H5；</p><h2 id="2-3-Native-向-H5-发送消息，并接受回调"><a href="#2-3-Native-向-H5-发送消息，并接受回调" class="headerlink" title="2.3 Native 向 H5 发送消息，并接受回调"></a>2.3 Native 向 H5 发送消息，并接受回调</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】封装 Java 层的 bean 数据；</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">Location</span> <span class="variable">location</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Location</span>();</span><br><span class="line">location.address = <span class="string">&quot;SDU&quot;</span>;</span><br><span class="line">user.location = location;</span><br><span class="line">user.name = <span class="string">&quot;大头鬼&quot;</span>;</span><br><span class="line"><span class="comment">//【2】发送数据，并注册回调函数 CallBackFunction：</span></span><br><span class="line">webView.callHandler(<span class="string">&quot;functionInJs&quot;</span>, <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(user), <span class="keyword">new</span> <span class="title class_">CallBackFunction</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCallBack</span><span class="params">(String data)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//【3】这个是不需要回调的，直接发送数据给 H5；</span></span><br><span class="line">webView.send(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以看到，上面给出了有回调和没有回调的两种通信方式；</p><p>具体的调用逻辑，我们后面再分析！</p><h2 id="2-4-H5-向-Native-发送消息，并接受回调"><a href="#2-4-H5-向-Native-发送消息，并接受回调" class="headerlink" title="2.4 H5 向 Native 发送消息，并接受回调"></a>2.4 H5 向 Native 发送消息，并接受回调</h2><p>这个地方就比较复杂了，我们要从 H5 中看起；</p><ul><li>H5 触发 js 的函数，指定具体的 handler 处理：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testClick1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> str1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;text1&quot;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">var</span> str2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;text2&quot;</span>).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】调用本地方法，特定 handler 处理！</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>.<span class="title function_">callHandler</span>(</span><br><span class="line">        <span class="string">&#x27;submitFromWeb&#x27;</span></span><br><span class="line">        , &#123;<span class="string">&#x27;param&#x27;</span>: <span class="string">&#x27;中文测试&#x27;</span>&#125;</span><br><span class="line">        , <span class="keyword">function</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;show&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;send get responseData from java, data = &quot;</span> + responseData</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到了 ‘submitFromWeb’，这和前面的 registerHandler 相呼应了！</p><ul><li>H5 触发 js 的函数，默认 handler 处理：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> str1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;text1&quot;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">var</span> str2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;text2&quot;</span>).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】调用本地方法，默认 handler 处理！</span></span><br><span class="line">    <span class="keyword">var</span> data = &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&quot;这是一个图片 &lt;img src=\&quot;a.png\&quot;/&gt; test\r\nhahaha&quot;</span>&#125;;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>.<span class="title function_">send</span>(</span><br><span class="line">        data</span><br><span class="line">        , <span class="keyword">function</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;show&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;repsonseData from java, data = &quot;</span> + responseData</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这和前面的 DefaultHandler 相呼应了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列文章主要分析 JsBridge 框架的原理，学习 H5 和原生 WebView 的交互方式，框架选自 GitHub 上的很火的 H5 + WebView 三方库：lzyzsd/JsBridge，作者是大鬼头；&lt;/p&gt;
&lt;h1 id=&quot;1-工程结构&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="开源库源码分析" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="JsBridge" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JsBridge/"/>
    
    
    <category term="JsBridge" scheme="https://lishuaiqi.top/tags/JsBridge/"/>
    
  </entry>
  
  <entry>
    <title>ARouter 第七篇 - 路由跳转/数据传递 (arouter-api)</title>
    <link href="https://lishuaiqi.top/2019/05/09/ARouter7-navigationWithData-arouter-api/"/>
    <id>https://lishuaiqi.top/2019/05/09/ARouter7-navigationWithData-arouter-api/</id>
    <published>2019-05-09T12:46:25.000Z</published>
    <updated>2019-08-13T15:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列文章主要分析 ARouter 框架的架构和原理。</p><blockquote><p>这是阿里 ARouter 开源库的地址，大家可以直接访问<br><a href="https://github.com/alibaba/ARouter">https://github.com/alibaba/ARouter</a></p></blockquote><p>本篇博文主要分析 arouter-api 模块的路由跳转的过程，以及变量/数据的传递，这篇文章将是本系列的最后一篇（后续会抽时间写其他的）！</p><p>在阅读过程中，涉及到方法跳转的时候，注释上有 <code>--&gt;</code>的标志，这样的好处是，以类为单位，一次性分析其所有的方法：</p><h1 id="1-路由跳转"><a href="#1-路由跳转" class="headerlink" title="1 路由跳转"></a>1 路由跳转</h1><p>我们来看看</p><h2 id="1-1-跳转方式"><a href="#1-1-跳转方式" class="headerlink" title="1.1 跳转方式"></a>1.1 跳转方式</h2><p>ARouter 支持两种方式来跳转：</p><ul><li>path 跳转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">&quot;/home/main&quot;</span>)  <span class="comment">// 指定 path</span></span><br><span class="line">            .navigation();</span><br><span class="line">ARouter.getInstance().build(<span class="string">&quot;/home/main&quot;</span>, <span class="string">&quot;ap&quot;</span>).navigation(); <span class="comment">// 显示指定分组</span></span><br></pre></td></tr></table></figure><ul><li>uri 跳转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uri uri;</span><br><span class="line">ARouter.getInstance().build(uri).navigation(); <span class="comment">// 指定 uri</span></span><br></pre></td></tr></table></figure><ul><li>我们可以设置跳转请求码和跳转回调</li></ul><p>这种调用方式相当于原生的 startActivityForResult：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">&quot;/home/main&quot;</span>, <span class="string">&quot;ap&quot;</span>).navigation(<span class="built_in">this</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>同时我们也可以指定跳转回调：<strong>NavigationCallback</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">&quot;/test/activity&quot;</span>).navigation(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">NavigationCallback</span>() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFound</span><span class="params">(Postcard postcard)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLost</span><span class="params">(Postcard postcard)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onArrival</span><span class="params">(Postcard postcard)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onInterrupt</span><span class="params">(Postcard postcard)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>处理跳转的结果；</p><ul><li>我们也可以设置跳过所有的拦截器</li></ul><p>我们知道 actiivty 的跳转是收到拦截器的限制的，但是 PostCard 提供了接口，能够跳过所有的拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用绿色通道(跳过所有的拦截器)</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">&quot;/home/main&quot;</span>).greenChannel().navigation();</span><br></pre></td></tr></table></figure><p>这里的 greenChannel 方法我们前面有分析过，不多说了！</p><h3 id="1-1-1-Uri-跳转的特殊性"><a href="#1-1-1-Uri-跳转的特殊性" class="headerlink" title="1.1.1 Uri 跳转的特殊性"></a>1.1.1 Uri 跳转的特殊性</h3><p>这里要单独讲下 uri 跳转的特殊性，ARouter 通过新建一个没有 UI 的界面作为跳板来统一处理，scheme 是 arouter 的跳转请求！</p><ul><li>需要新建一个 activity 来接收 uri，没有 ui 界面，这是关键点！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchameFilterActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> getIntent().getData();</span><br><span class="line">    ARouter.getInstance().build(uri).navigation();</span><br><span class="line">    finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AndroidManifest.xml 中要指定该 activity 监听的 schame 事件是：<strong>arouter://m.aliyun.com</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.activity.SchameFilterActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Schame --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:host</span>=<span class="string">&quot;m.aliyun.com&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scheme</span>=<span class="string">&quot;arouter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.VIEW&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.BROWSABLE&quot;</span>/&gt;</span>   <span class="comment">&lt;!-- 让浏览器可以打这个 Actvity，当然要符合 host 和 scheme --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- App Links --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:autoVerify</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.VIEW&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.BROWSABLE&quot;</span>/&gt;</span>   <span class="comment">&lt;!-- 让浏览器可以打这个 Actvity，当然要符合 host 和 scheme --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:host</span>=<span class="string">&quot;m.aliyun.com&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scheme</span>=<span class="string">&quot;http&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:host</span>=<span class="string">&quot;m.aliyun.com&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scheme</span>=<span class="string">&quot;https&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相当于这个 activity 作为外界的统一入口，H5 或者 native 通过 intent 匹配，将数据传递给这个 activity，然后这个 activity 解析数据，将 uri 叫给 ARouter 最终实现跳转！</p><p>详细分析：Uri 的组成为：<strong>scheme://host:port/path?query</strong>，我们通过中转 activity 匹配 <strong>scheme://host:port</strong> 部分，截获 Uri，然后通过 getPath 就可以回去到 Path，这个 Path 需要和 @Route 的 path 匹配，这样就可以实现跳转了！</p><p>可以看出这个过程就是 <strong>intent 的匹配！</strong></p><h2 id="1-2-数据传递"><a href="#1-2-数据传递" class="headerlink" title="1.2 数据传递"></a>1.2 数据传递</h2><p>以上的两种跳转方式，都可以传递数据，我们来看下数据传递的方式：</p><ul><li>直接传递 Bundle</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bundle</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">ARouter.getInstance()</span><br><span class="line">    .build(<span class="string">&quot;/home/main&quot;</span>)</span><br><span class="line">    .with(params)</span><br><span class="line">    .navigation();</span><br></pre></td></tr></table></figure><p>注意：这个方法会覆盖掉 PostCast 内部默认创建的 Bundle；</p><ul><li>指定启动 Flag</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">    .build(<span class="string">&quot;/home/main&quot;</span>)</span><br><span class="line">    .withFlags();</span><br><span class="line">    .navigation();</span><br></pre></td></tr></table></figure><ul><li>支持传递各种基本类型数据、对象、数组、List、可序列化数据：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance()</span><br><span class="line">    .build(<span class="string">&quot;/home/main&quot;</span>).withAction(..)</span><br><span class="line">    .withBoolean(String key, <span class="type">boolean</span> value)</span><br><span class="line">    .withBundle(String key, Bundle value)</span><br><span class="line">    .withByte(String key, <span class="type">byte</span> value)</span><br><span class="line">    .withCharSequenceArrayList(String key, ArrayList&lt;CharSequence&gt; value)</span><br><span class="line">    .withParcelable(String key, Parcelable value)</span><br><span class="line">    .withSerializable(String key, Serializable value)</span><br><span class="line">    .withStringArrayList(String key, ArrayList&lt;String&gt; value)</span><br><span class="line">    .withObject(<span class="meta">@Nullable</span> String key, <span class="meta">@Nullable</span> Object value)</span><br><span class="line">    ... ... ... <span class="comment">// 接口太多了，省略下，其实这些接口对应的是 Bundle 中的方法！</span></span><br><span class="line">    .navigation();</span><br></pre></td></tr></table></figure><p>这些数据都会被加入到 PostCard 内部的默认创建的 Bundle 中，其实这些方法对应的就是 Bundle 中的方法！</p><ul><li>支持设置转场动画</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转场动画(常规方式)</span></span><br><span class="line">ARouter.getInstance()</span><br><span class="line">    .build(<span class="string">&quot;/test/activity2&quot;</span>)</span><br><span class="line">    .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom)</span><br><span class="line">    .navigation(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转场动画(API16+)</span></span><br><span class="line"><span class="type">ActivityOptionsCompat</span> <span class="variable">compat</span> <span class="operator">=</span> ActivityOptionsCompat.</span><br><span class="line">    makeScaleUpAnimation(v, v.getWidth() / <span class="number">2</span>, v.getHeight() / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ARouter.getInstance()</span><br><span class="line">    .build(<span class="string">&quot;/test/activity2&quot;</span>)</span><br><span class="line">    .withOptionsCompat(compat)</span><br><span class="line">    .navigation();</span><br></pre></td></tr></table></figure><h3 id="1-2-1-对象传递的特殊"><a href="#1-2-1-对象传递的特殊" class="headerlink" title="1.2.1 对象传递的特殊"></a>1.2.1 对象传递的特殊</h3><p>对于自定义的对象，不能确保它可序列化，所以这里通过 SerializationService 将其转为了 jsonstring：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Postcard <span class="title function_">withObject</span><span class="params">(<span class="meta">@Nullable</span> String key, <span class="meta">@Nullable</span> Object value)</span> &#123;</span><br><span class="line">    serializationService = ARouter.getInstance().navigation(SerializationService.class);</span><br><span class="line">    mBundle.putString(key, serializationService.object2Json(value));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-跳转流程"><a href="#2-跳转流程" class="headerlink" title="2 跳转流程"></a>2 跳转流程</h1><p>下面，我们重点分析路由跳转的流程，和数据传递的流程，忽略掉一些之前已经见过的流程！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().build(...); --&gt; _ARouter.getInstance().build(...);</span><br></pre></td></tr></table></figure><p>无论是 path 跳转，还是 uri 跳转，ARouter 都会调用 _ARouter 的方法！</p><h2 id="2-1-ARouter-build"><a href="#2-1-ARouter-build" class="headerlink" title="2.1 _ARouter.build"></a>2.1 _ARouter.build</h2><p>无论是 build(path)，还是  build(uri)，最终创建的 PostCard 都是一样的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Postcard <span class="title function_">build</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HandlerException</span>(Consts.TAG + <span class="string">&quot;Parameter is invalid!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">PathReplaceService</span> <span class="variable">pService</span> <span class="operator">=</span> ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != pService) &#123;</span><br><span class="line">            path = pService.forString(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(path, extractGroup(path));  <span class="comment">// 通过 path 创建！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Postcard <span class="title function_">build</span><span class="params">(Uri uri)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == uri || TextUtils.isEmpty(uri.toString())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HandlerException</span>(Consts.TAG + <span class="string">&quot;Parameter invalid!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">PathReplaceService</span> <span class="variable">pService</span> <span class="operator">=</span> ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != pService) &#123;</span><br><span class="line">            uri = pService.forUri(uri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Postcard</span>(uri.getPath(), extractGroup(uri.getPath()), uri, <span class="literal">null</span>); <span class="comment">// 通过 uri 创建！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-Postcard"><a href="#2-2-Postcard" class="headerlink" title="2.2 Postcard"></a>2.2 Postcard</h2><h3 id="2-2-1-new-Postcard"><a href="#2-2-1-new-Postcard" class="headerlink" title="2.2.1 new Postcard"></a>2.2.1 new Postcard</h3><p>创建一个新的 Postcard：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Postcard</span><span class="params">(String path, String group)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(path, group, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Postcard</span><span class="params">(String path, String group, Uri uri, Bundle bundle)</span> &#123;</span><br><span class="line">    setPath(path);</span><br><span class="line">    setGroup(group);</span><br><span class="line">    setUri(uri);</span><br><span class="line">    <span class="built_in">this</span>.mBundle = (<span class="literal">null</span> == bundle ? <span class="keyword">new</span> <span class="title class_">Bundle</span>() : bundle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，通过 Uri 创建的话，会多设置一个 Uri 的属性；</p><h3 id="2-2-2-navigation"><a href="#2-2-2-navigation" class="headerlink" title="2.2.2 navigation"></a>2.2.2 navigation</h3><p>最核心的就后面的两个方法，支持传入 requestCode 和 NavigationCallback 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">navigation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> navigation(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">navigation</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> navigation(context, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">navigation</span><span class="params">(Activity mContext, <span class="type">int</span> requestCode)</span> &#123;</span><br><span class="line">    navigation(mContext, requestCode, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">navigation</span><span class="params">(Context context, NavigationCallback callback)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ARouter.getInstance().navigation(context, <span class="built_in">this</span>, -<span class="number">1</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">navigation</span><span class="params">(Activity mContext, <span class="type">int</span> requestCode, NavigationCallback callback)</span> &#123;</span><br><span class="line">    ARouter.getInstance().navigation(mContext, <span class="built_in">this</span>, requestCode, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 ARouter.getInstance().navigation，我们知道最后会调用 _ARouter.getInstance().navigation</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().navigation(...) --&gt; _ARouter.getInstance().navigation(...);</span><br></pre></td></tr></table></figure><h2 id="2-3-ARouter-navigation"><a href="#2-3-ARouter-navigation" class="headerlink" title="2.3 _ARouter.navigation"></a>2.3 _ARouter.navigation</h2><p>这里我们可以看到回调的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="type">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】这里的获取方式是一样的；</span></span><br><span class="line">    <span class="type">PretreatmentService</span> <span class="variable">pretreatmentService</span> <span class="operator">=</span> ARouter.getInstance().navigation(PretreatmentService.class);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != pretreatmentService &amp;&amp; !pretreatmentService.onPretreatment(context, postcard)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.3.1】完善跳转信息；</span></span><br><span class="line">        LogisticsCenter.completion(postcard);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">        logger.warning(Consts.TAG, ex.getMessage());</span><br><span class="line">        <span class="keyword">if</span> (debuggable()) &#123;</span><br><span class="line">            runInMainThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    Toast.makeText(mContext, <span class="string">&quot;There&#x27;s no route matched!\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot; Path = [&quot;</span> + postcard.getPath() + <span class="string">&quot;]\n&quot;</span> +</span><br><span class="line">                            <span class="string">&quot; Group = [&quot;</span> + postcard.getGroup() + <span class="string">&quot;]&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != callback) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;2.4.2】完善跳转信息失败后会调用，通过 NavigationCallback 通知；</span></span><br><span class="line">            callback.onLost(postcard);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【2】这里的获取方式是一样的；</span></span><br><span class="line">            <span class="type">DegradeService</span> <span class="variable">degradeService</span> <span class="operator">=</span> ARouter.getInstance().navigation(DegradeService.class);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != degradeService) &#123;</span><br><span class="line">                degradeService.onLost(context, postcard);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != callback) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.4.1】完善跳转信息成功后会调用，通过 NavigationCallback 通知；</span></span><br><span class="line">        callback.onFound(postcard);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】对于 Service/Fragment 是会跳过拦截器的，对于 activity 默认是不会跳过的，当然了可动态设置；</span></span><br><span class="line">    <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;</span><br><span class="line">        interceptorService.doInterceptions(postcard, <span class="keyword">new</span> <span class="title class_">InterceptorCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onContinue</span><span class="params">(Postcard postcard)</span> &#123;</span><br><span class="line">                <span class="comment">//【--&gt;2.3.2】最终的处理；</span></span><br><span class="line">                _navigation(context, postcard, requestCode, callback);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onInterrupt</span><span class="params">(Throwable exception)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != callback) &#123;</span><br><span class="line">                    <span class="comment">//【--&gt;2.4.4】拦截器对跳转进行了拦截后会调用，通过 NavigationCallback 通知；</span></span><br><span class="line">                    callback.onInterrupt(postcard);</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(Consts.TAG, <span class="string">&quot;Navigation failed, termination by interceptor : &quot;</span> + exception.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.3.2】最终的处理；</span></span><br><span class="line">        <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-1-LogisticsCenter-completion"><a href="#2-3-1-LogisticsCenter-completion" class="headerlink" title="2.3.1 LogisticsCenter.completion"></a>2.3.1 LogisticsCenter.completion</h3><p>完善登陆信息，这里前面有说过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">completion</span><span class="params">(Postcard postcard)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == postcard) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoRouteFoundException</span>(TAG + <span class="string">&quot;No postcard!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】从 Warehouse.routes 中获取 path 对应的 RouteMeta 缓存数据；</span></span><br><span class="line">    <span class="type">RouteMeta</span> <span class="variable">routeMeta</span> <span class="operator">=</span> Warehouse.routes.get(postcard.getPath());</span><br><span class="line">    <span class="comment">//【2】如果找不到，那么就从 compiler 生成的数据中查找！</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == routeMeta) &#123; </span><br><span class="line">        <span class="comment">//【2.1】从 Warehouse.routes 中获取 group 对应的 group 类文件；</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">IRouteGroup</span>&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == groupMeta) &#123; <span class="comment">//【2.1.1】找不到抛出异常；</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoRouteFoundException</span>(TAG + <span class="string">&quot;There is no route match the path [&quot;</span> + postcard.getPath() + <span class="string">&quot;], in group [&quot;</span> + postcard.getGroup() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                    logger.debug(TAG, String.format(Locale.getDefault(), <span class="string">&quot;The group [%s] starts loading, trigger by [%s]&quot;</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【2.1.2】创建 groupMeta 对应的实例；</span></span><br><span class="line">                <span class="type">IRouteGroup</span> <span class="variable">iGroupInstance</span> <span class="operator">=</span> groupMeta.getConstructor().newInstance();</span><br><span class="line">                <span class="comment">//【2.1.3】调用其 loadInto 将 group 对应的信息加入到缓存 Warehouse.routes 中！</span></span><br><span class="line">                iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">                <span class="comment">//【2.1.4】然后从 Warehouse.groupsIndex 删除这个组对应的信息；</span></span><br><span class="line">                Warehouse.groupsIndex.remove(postcard.getGroup());</span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                    logger.debug(TAG, String.format(Locale.getDefault(), <span class="string">&quot;The group [%s] has already been loaded, trigger by [%s]&quot;</span>,</span><br><span class="line">                                                    postcard.getGroup(), postcard.getPath()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HandlerException</span>(TAG + <span class="string">&quot;Fatal exception when loading group meta. [&quot;</span> + e.getMessage() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【--&gt;2.3.1】重新加载；</span></span><br><span class="line">            completion(postcard);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.3.1.1】这里是通过 RouteMeta 来设置 Postcard 对象，我们先不看；</span></span><br><span class="line">        postcard.setDestination(routeMeta.getDestination());</span><br><span class="line">        postcard.setType(routeMeta.getType()); </span><br><span class="line">        postcard.setPriority(routeMeta.getPriority());</span><br><span class="line">        postcard.setExtra(routeMeta.getExtra());</span><br><span class="line">        <span class="type">Uri</span> <span class="variable">rawUri</span> <span class="operator">=</span> postcard.getUri();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != rawUri) &#123; </span><br><span class="line">            Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</span><br><span class="line">            Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType(); </span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</span><br><span class="line">                    setValue(postcard,</span><br><span class="line">                            params.getValue(),</span><br><span class="line">                            params.getKey(),</span><br><span class="line">                            resultMap.get(params.getKey()));</span><br><span class="line">                &#125;</span><br><span class="line">                postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;&#125;));</span><br><span class="line">            &#125;</span><br><span class="line">            postcard.withString(ARouter.RAW_URI, rawUri.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【4】这里是关键点，判断类型，可以看到 activity 这里是不处理的，主要是 IProvider 类型；</span></span><br><span class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER: </span><br><span class="line">                <span class="comment">//【4.1】我们要获取的 Serivce，类型就是 PROVIDER，routeMeta.getDestination 返回的是要访问的目标类：service.class;</span></span><br><span class="line">                Class&lt;? <span class="keyword">extends</span> <span class="title class_">IProvider</span>&gt; providerMeta = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">IProvider</span>&gt;) routeMeta.getDestination();</span><br><span class="line">                <span class="comment">//【4.2】然后优先从 Warehouse.providers 缓存中获取；</span></span><br><span class="line">                <span class="type">IProvider</span> <span class="variable">instance</span> <span class="operator">=</span> Warehouse.providers.get(providerMeta);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    IProvider provider;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//【4.3】创建 providerMeta 对应的实例，就是 Service 实例；</span></span><br><span class="line">                        provider = providerMeta.getConstructor().newInstance();</span><br><span class="line">                        <span class="comment">//【4.3.1】执行 init 方法；</span></span><br><span class="line">                        provider.init(mContext);</span><br><span class="line">                        <span class="comment">//【4.3.2】然后将加入到 Warehouse.providers 中去；</span></span><br><span class="line">                        Warehouse.providers.put(providerMeta, provider);</span><br><span class="line">                        instance = provider;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HandlerException</span>(<span class="string">&quot;Init provider failed! &quot;</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【5】将 instance 保存到 postcard.provider 中去，因为跳转目标是 IProvider 的子类；</span></span><br><span class="line">                postcard.setProvider(instance);</span><br><span class="line">                postcard.greenChannel();  <span class="comment">//【6】跳过所有的拦截器！</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                postcard.greenChannel(); <span class="comment">// 跳过所有的拦截器！</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是</p><h4 id="2-3-1-1-数据传递-important"><a href="#2-3-1-1-数据传递-important" class="headerlink" title="2.3.1.1  数据传递 - important"></a>2.3.1.1  数据传递 - important</h4><p>这里我们要重点看下 PostCard 中的数据是如何处理的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">postcard.setDestination(routeMeta.getDestination());</span><br><span class="line">postcard.setType(routeMeta.getType()); </span><br><span class="line">postcard.setPriority(routeMeta.getPriority());</span><br><span class="line">postcard.setExtra(routeMeta.getExtra());</span><br><span class="line"></span><br><span class="line"><span class="comment">//【1】注意这里是处理 uri 的数据</span></span><br><span class="line"><span class="type">Uri</span> <span class="variable">rawUri</span> <span class="operator">=</span> postcard.getUri();</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != rawUri) &#123; </span><br><span class="line">  <span class="comment">//【--&gt;2.3.1.2】获得 uri 的数据；</span></span><br><span class="line">  Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</span><br><span class="line">  <span class="comment">//【2】RouteMeta 的 paramsType 保存了被 @AutoWired 注解的参数和类型的枚举序号的映射关系；</span></span><br><span class="line">  Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType(); </span><br><span class="line">  <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</span><br><span class="line">      <span class="comment">//【--&gt;2.3.1.3】将传递的数据设置到 Postcard 中，调用 Postcard.withXXX 方法；</span></span><br><span class="line">      setValue(postcard,</span><br><span class="line">               params.getValue(), <span class="comment">// 变量类型的枚举序号；</span></span><br><span class="line">               params.getKey(), <span class="comment">// 变量名/注解name值</span></span><br><span class="line">               resultMap.get(params.getKey())); <span class="comment">// uri 写到的变量的值；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】将被 @AutoWired 注解的变量的变量名/注解name值以 String[] 形式保存到 PostCard.Bundle 中；</span></span><br><span class="line">    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;&#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//【4】将 uri 保存到 PostCard.Bundle 中，</span></span><br><span class="line">  postcard.withString(ARouter.RAW_URI, rawUri.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的两个常量的如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RAW_URI</span> <span class="operator">=</span> <span class="string">&quot;NTeRQWvye18AkPd6G&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AUTO_INJECT</span> <span class="operator">=</span> <span class="string">&quot;wmHzgD4lOj5o4241&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="2-3-1-2-TextUtils-splitQueryParameters"><a href="#2-3-1-2-TextUtils-splitQueryParameters" class="headerlink" title="2.3.1.2 TextUtils.splitQueryParameters"></a>2.3.1.2 TextUtils.splitQueryParameters</h4><p>将 uri 后缀保存的 key-value 的键值对转为 Map&lt;String, String&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title function_">splitQueryParameters</span><span class="params">(Uri rawUri)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> rawUri.getEncodedQuery();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (query == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; paramMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> query.indexOf(<span class="string">&#x27;&amp;&#x27;</span>, start);</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> (next == -<span class="number">1</span>) ? query.length() : next;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">separator</span> <span class="operator">=</span> query.indexOf(<span class="string">&#x27;=&#x27;</span>, start);</span><br><span class="line">        <span class="keyword">if</span> (separator &gt; end || separator == -<span class="number">1</span>) &#123;</span><br><span class="line">            separator = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> query.substring(start, separator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!android.text.TextUtils.isEmpty(name)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (separator == end ? <span class="string">&quot;&quot;</span> : query.substring(separator + <span class="number">1</span>, end));</span><br><span class="line">            paramMap.put(Uri.decode(name), Uri.decode(value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move start to end of name.</span></span><br><span class="line">        start = end + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (start &lt; query.length());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableMap(paramMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-1-3-LogisticsCenter-setValue"><a href="#2-3-1-3-LogisticsCenter-setValue" class="headerlink" title="2.3.1.3 LogisticsCenter.setValue"></a>2.3.1.3 LogisticsCenter.setValue</h4><p>将传递的数据设置进入 Postcard 中！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Postcard postcard, Integer typeDef, String key, String value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(key) || TextUtils.isEmpty(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != typeDef) &#123;</span><br><span class="line">            <span class="comment">//【1】根据类型的枚举序号，匹配对应的 withXXX 方法，将值设置到内部的 Bundle 中！</span></span><br><span class="line">            <span class="keyword">if</span> (typeDef == TypeKind.BOOLEAN.ordinal()) &#123;</span><br><span class="line">                postcard.withBoolean(key, Boolean.parseBoolean(value));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef == TypeKind.BYTE.ordinal()) &#123;</span><br><span class="line">                postcard.withByte(key, Byte.valueOf(value));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef == TypeKind.SHORT.ordinal()) &#123;</span><br><span class="line">                postcard.withShort(key, Short.valueOf(value));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef == TypeKind.INT.ordinal()) &#123;</span><br><span class="line">                postcard.withInt(key, Integer.valueOf(value));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef == TypeKind.LONG.ordinal()) &#123;</span><br><span class="line">                postcard.withLong(key, Long.valueOf(value));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef == TypeKind.FLOAT.ordinal()) &#123;</span><br><span class="line">                postcard.withFloat(key, Float.valueOf(value));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef == TypeKind.DOUBLE.ordinal()) &#123;</span><br><span class="line">                postcard.withDouble(key, Double.valueOf(value));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef == TypeKind.STRING.ordinal()) &#123;</span><br><span class="line">                postcard.withString(key, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef == TypeKind.PARCELABLE.ordinal()) &#123;</span><br><span class="line">                <span class="comment">// TODO : How to description parcelable value with string?</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeDef == TypeKind.OBJECT.ordinal()) &#123;</span><br><span class="line">                postcard.withString(key, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// Compatible compiler sdk 1.0.3, in that version, the string type = 18</span></span><br><span class="line">                postcard.withString(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            postcard.withString(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        logger.warning(Consts.TAG, <span class="string">&quot;LogisticsCenter setValue failed! &quot;</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，不多说了！</p><h3 id="2-3-2-ARouter-navigation"><a href="#2-3-2-ARouter-navigation" class="headerlink" title="2.3.2 _ARouter._navigation"></a>2.3.2 _ARouter._navigation</h3><p>可以看到，启动过的过程就是将 Postcard 中的数据设置到 intent 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">_navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="type">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">currentContext</span> <span class="operator">=</span> <span class="literal">null</span> == context ? mContext : context;</span><br><span class="line">    <span class="comment">//【1】根据跳转类型处理不同的目标；</span></span><br><span class="line">    <span class="keyword">switch</span> (postcard.getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ACTIVITY:</span><br><span class="line">            <span class="comment">//【1.1】创建 activity；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(currentContext, postcard.getDestination());</span><br><span class="line">            intent.putExtras(postcard.getExtras());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【1.2】设置目标启动的 flags</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> postcard.getFlags();</span><br><span class="line">            <span class="keyword">if</span> (-<span class="number">1</span> != flags) &#123;</span><br><span class="line">                intent.setFlags(flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(currentContext <span class="keyword">instanceof</span> Activity)) &#123;    <span class="comment">// Non activity, need less one flag.</span></span><br><span class="line">                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【1.3】设置 action！</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> postcard.getAction();</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(action)) &#123;</span><br><span class="line">                intent.setAction(action);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【--&gt;2.3.2.1】执行启动；</span></span><br><span class="line">            runInMainThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    startActivity(requestCode, currentContext, intent, postcard, callback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PROVIDER:</span><br><span class="line">            <span class="keyword">return</span> postcard.getProvider(); <span class="comment">// 这个是针对 Provider 的；</span></span><br><span class="line">        <span class="keyword">case</span> BOARDCAST:</span><br><span class="line">        <span class="keyword">case</span> CONTENT_PROVIDER:</span><br><span class="line">        <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">            <span class="comment">//【1.4】针对于 brocastreceiver，contenprovider，fragment，会拿到其实例！</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">fragmentMeta</span> <span class="operator">=</span> postcard.getDestination();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> fragmentMeta.getConstructor().newInstance();</span><br><span class="line">                <span class="comment">//【1.4.1】针对于 fragment，还会设置 Arguments；</span></span><br><span class="line">                <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> Fragment) &#123;</span><br><span class="line">                    ((Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> android.support.v4.app.Fragment) &#123;</span><br><span class="line">                    ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                logger.error(Consts.TAG, <span class="string">&quot;Fetch fragment instance error, &quot;</span> + TextUtils.formatStackTrace(ex.getStackTrace()));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> METHOD: <span class="comment">// 其他情况没有；</span></span><br><span class="line">        <span class="keyword">case</span> SERVICE:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对于 brocastreceiver，contenprovider，fragment，会拿到其实例，针对于 fragment，还会设置 Arguments！</p><h4 id="2-3-2-1-ARouter-startActivity"><a href="#2-3-2-1-ARouter-startActivity" class="headerlink" title="2.3.2.1 _ARouter.startActivity"></a>2.3.2.1 _ARouter.startActivity</h4><p>这就是最后启动过程了，其实很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startActivity</span><span class="params">(<span class="type">int</span> requestCode, Context currentContext, Intent intent, Postcard postcard, NavigationCallback callback)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】这里根据 requestCode 有不同的调用方式；</span></span><br><span class="line">    <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;  <span class="comment">// Need start for result</span></span><br><span class="line">        <span class="keyword">if</span> (currentContext <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warning(Consts.TAG, <span class="string">&quot;Must use [navigation(activity, ...)] to support [startActivityForResult]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((-<span class="number">1</span> != postcard.getEnterAnim() &amp;&amp; -<span class="number">1</span> != postcard.getExitAnim()) &amp;&amp; currentContext <span class="keyword">instanceof</span> Activity) &#123;    <span class="comment">// Old version.</span></span><br><span class="line">        ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != callback) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.4.3】启动完成，回调 NavigationCallback</span></span><br><span class="line">        callback.onArrival(postcard);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不多说了！</p><p>这里的 postcard.getOptionsBundle() 会返回一个 Bundle 是用来保存额外的启动参数，比如动画等等；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> Bundle optionsCompat;     </span><br><span class="line"><span class="keyword">public</span> Bundle <span class="title function_">getOptionsBundle</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> optionsCompat;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-跳转回调"><a href="#2-4-跳转回调" class="headerlink" title="2.4 跳转回调"></a>2.4 跳转回调</h2><p>我们看看 NavigationCallback 的相关接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NavigationCallback</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;2.4.1】完善跳转信息成功后会调用；</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFound</span><span class="params">(Postcard postcard)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【--&gt;2.4.2】完善跳转信息失败后会调用；</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onLost</span><span class="params">(Postcard postcard)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【--&gt;2.4.3】跳转成功后会回调；</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onArrival</span><span class="params">(Postcard postcard)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【--&gt;2.4.4】拦截器对跳转进行了拦截后会调用；</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onInterrupt</span><span class="params">(Postcard postcard)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>到这里 ARouter 分析就暂告一段落了；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列文章主要分析 ARouter 框架的架构和原理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是阿里 ARouter 开源库的地址，大家可以直接访问&lt;br&gt;&lt;a href=&quot;https://github.com/alibaba/ARouter&quot;&gt;https://gith</summary>
      
    
    
    
    <category term="开源库源码分析" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="ARouter" scheme="https://lishuaiqi.top/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ARouter/"/>
    
    
    <category term="ARouter" scheme="https://lishuaiqi.top/tags/ARouter/"/>
    
  </entry>
  
</feed>
