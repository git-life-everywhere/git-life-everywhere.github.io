<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Choreographer 第一篇 Choreographer  原理分析"><meta name="keywords" content="Choreographer"><meta name="author" content="Li Shuaiqi"><meta name="copyright" content="Li Shuaiqi"><title>Choreographer 第一篇 Choreographer  原理分析 | Li Shuaiqi's Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="Li Shuaiqi's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%9B%9E%E9%A1%BE"><span class="toc-text">1 回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-scheduleTraversals-%E6%A0%B8%E5%BF%83"><span class="toc-text">1.1 scheduleTraversals - 核心</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF-Choreographer"><span class="toc-text">2 什么是 Choreographer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Choreographer"><span class="toc-text">3 Choreographer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-getInstance"><span class="toc-text">3.1 getInstance()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-new-Choreographer"><span class="toc-text">3.2 new Choreographer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-postCallback-Delayed-DelayedInternal"><span class="toc-text">3.3 postCallback[Delayed][DelayedInternal]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-CallbackQueues"><span class="toc-text">3.3.1 CallbackQueues</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-1-extractDueCallbacksLocked"><span class="toc-text">3.3.1.1 extractDueCallbacksLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-2-addCallbackLocked"><span class="toc-text">3.3.1.2 addCallbackLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-3-hasDueCallbacksLocked"><span class="toc-text">3.3.2.3 hasDueCallbacksLocked</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-CallbackRecord"><span class="toc-text">3.3.2 CallbackRecord</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-scheduleFrameLocked"><span class="toc-text">3.4 scheduleFrameLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-scheduleVsyncLocked"><span class="toc-text">3.4.1 scheduleVsyncLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-FrameDisplayEventReceiver"><span class="toc-text">4  FrameDisplayEventReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-new-FrameDisplayEventReceiver"><span class="toc-text">4.1 new FrameDisplayEventReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-nativeInit"><span class="toc-text">4.1.1 nativeInit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-scheduleVsync"><span class="toc-text">4.2 scheduleVsync</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-nativeScheduleVsync"><span class="toc-text">4.2.1 nativeScheduleVsync</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-dispatchVsync"><span class="toc-text">4.3 dispatchVsync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-onVsync"><span class="toc-text">4.4 onVsync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-run"><span class="toc-text">4.5 run</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-NativeDisplayEventReceiver-%E6%A0%B8%E5%BF%83"><span class="toc-text">5 NativeDisplayEventReceiver - 核心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-create-NativeDisplayEventReceiver"><span class="toc-text">5.1 create NativeDisplayEventReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-create-DisplayEventDispatcher-%E7%88%B6%E7%B1%BB"><span class="toc-text">5.1.1 create DisplayEventDispatcher - 父类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-initialize"><span class="toc-text">5.2 initialize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-scheduleVsync"><span class="toc-text">5.3 scheduleVsync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-handleEvent"><span class="toc-text">5.4 handleEvent</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-processPendingEvents"><span class="toc-text">5.4.1 processPendingEvents</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-dispatchVsync"><span class="toc-text">5.5 dispatchVsync</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-6-DisplayEventReceiver-%E6%A0%B8%E5%BF%83"><span class="toc-text">[5..6] DisplayEventReceiver - 核心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-1-create-DisplayEventReceiver"><span class="toc-text">[5..6].1 create DisplayEventReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extend-createDisplayEventConnection"><span class="toc-text">extend - createDisplayEventConnection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-2-initCheck"><span class="toc-text">[5..6].2 initCheck</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-3-getFd"><span class="toc-text">[5..6].3 getFd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-4-requestNextVsync"><span class="toc-text">[5..6].4 requestNextVsync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-5-getEvents"><span class="toc-text">[5..6].5 getEvents</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-FrameHandler"><span class="toc-text">6 FrameHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-new-FrameHandler"><span class="toc-text">6.1 new FrameHandler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Choreographer-back"><span class="toc-text">7 Choreographer - back</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-doScheduleVsync"><span class="toc-text">7.1 doScheduleVsync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-doFrame"><span class="toc-text">7.2 doFrame</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-doCallbacks"><span class="toc-text">7.3 doCallbacks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-doScheduleCallback"><span class="toc-text">7.4 doScheduleCallback</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-FrameInfo"><span class="toc-text">8 FrameInfo</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-new-FrameInfo"><span class="toc-text">8.1 new FrameInfo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-setVsync"><span class="toc-text">8.2 setVsync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-markInputHandlingStart-Animations-PerformTraversals"><span class="toc-text">8.3 markInputHandlingStart (Animations&#x2F;PerformTraversals)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%80%BB%E7%BB%93"><span class="toc-text">9 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%9B%BE%E7%A4%BA"><span class="toc-text">9.1 图示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-EventThread-%E7%BA%BF%E7%A8%8B"><span class="toc-text">9.2 EventThread 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-threadLoop"><span class="toc-text">9.2.1  threadLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-1-Connection-postEvent"><span class="toc-text">9.2.1.1  Connection::postEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-1-DisplayEventReceiver-sendEvents"><span class="toc-text">9.2.1.1  DisplayEventReceiver::sendEvents</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-waitForEvent"><span class="toc-text">9.2.2 waitForEvent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-BitTube"><span class="toc-text">9.3 BitTube</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Li Shuaiqi</div><div class="author-info__description text-center">“Hi，我是李帅奇，Android 开发工程师，熬夜星人。”</div><div class="follow-button"><a href="https://lishuaiqi.top">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">90</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">23</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">30</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Li Shuaiqi's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Choreographer 第一篇 Choreographer  原理分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/View-%E8%A7%86%E5%9B%BE/">View 视图</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/View-%E8%A7%86%E5%9B%BE/Choreographer-%E7%BC%96%E8%88%9E%E8%80%85/">Choreographer 编舞者</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">8.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 41 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本篇文章基于 Android N（7.1.1）主要分析下 Choreographer 的原理，以对 Android 系统有更好的理解。</p>
<h1 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h1><h2 id="1-1-scheduleTraversals-核心"><a href="#1-1-scheduleTraversals-核心" class="headerlink" title="1.1 scheduleTraversals - 核心"></a>1.1 scheduleTraversals - 核心</h2><p>触发视图遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        <span class="comment">//【1】表示是否已经发起重绘，这是要设置为 true；</span></span><br><span class="line">        mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//【1】在主线程的消息队列中放一个障栅；</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//【--&gt;10.5】设置一个回调到编舞者 Choreographer 中，在下一次的绘制触发时，执行 mTraversalRunnable</span></span><br><span class="line">        <span class="comment">// mTraversalRunnable 是一个 runnbale 实例；</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面分析 View 的绘制的时候，有讲到，Choreographer 会请求 Vsync 信号，然后在 Vsync 信号触发后，执行布局和绘制任务！</p>
<p>这一篇，我们来分析下 Choreographer！</p>
<h1 id="2-什么是-Choreographer"><a href="#2-什么是-Choreographer" class="headerlink" title="2 什么是 Choreographer"></a>2 什么是 Choreographer</h1><p>（这一部分来自 <strong>SDK</strong> 的翻译，其实 SDK 的注释已经将 Choreographer 的作用讲的很清楚了）</p>
<p>编舞者，作用是协调动画，输入和绘图的时间；</p>
<p>编舞者会从显示子系统接收定时脉冲（也就是垂直同步 Vsync 信号），然后触发指定的工作，结果会作为渲染下一个显示帧的一部分；</p>
<p>应用一般使用动画框架或视图层次结构中的更高级别的抽象间接地和编舞者交互。</p>
<p>下面是一些可以使用的高级 API，用于和 Choreographer  间接通信：</p>
<ul>
<li><p><strong>ValueAnimator.start</strong>：用于使用与显示框架渲染同步的要在常规时间进行处理的动画</p>
</li>
<li><p><strong>View.postOnAnimation</strong>：传入一个 Runnable，在下一个显示帧的开头被调用一次；</p>
</li>
<li><strong>View.postOnAnimationDelayed</strong>：传入一个 Runnable，在下一个显示帧的开头延迟指定时间被调用一次；</li>
<li><strong>View.postInvalidateOnAnimation</strong>：在下一个显示帧开始时触发 <strong>View.invalidate</strong> 一次；</li>
</ul>
<p>为确保 <strong>View</strong> 的内容平滑滚动并与显示框架渲染同步绘制，请不要执行任何操作。系统会自动处理，<strong>View.onDraw</strong> 将在适当的时候被调用。</p>
<p>但是，在某些情况下，您可能希望直接在应用程序中使用编舞者的功能。譬如说：</p>
<ul>
<li><strong>Choreographer.postFrameCallback</strong>：如果应用使用 GL，或完全不使用动画框架或视图层次结构在其他线程中进行渲染，并且你想确保它与显示适当同步。</li>
</ul>
<p>每个  <strong>Looper 线程</strong> 都有自己的编舞者。其他线程可以发布回调以在编舞者上运行，但是它们将持有编舞者所属的 <strong>Looper</strong>。</p>
<h1 id="3-Choreographer"><a href="#3-Choreographer" class="headerlink" title="3 Choreographer"></a>3 Choreographer</h1><p>我们来开始分析 Choreographer 的代码：</p>
<h2 id="3-1-getInstance"><a href="#3-1-getInstance" class="headerlink" title="3.1 getInstance()"></a>3.1 getInstance()</h2><p>编舞者是线程单例模式，每一个线程都会有一个：<strong>ThreadLocal</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Choreographer</span> &#123;</span><br><span class="line">   <span class="comment">//【1】通过 ThreadLocal 实现线程单例模式；</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Choreographer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Choreographer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//【2】获取当前线程的 looper 对象；</span></span><br><span class="line">            <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> Looper.myLooper();</span><br><span class="line">            <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The current thread must have a looper!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【--&gt;3.2】创建 Choreographer 对象；</span></span><br><span class="line">            <span class="type">Choreographer</span> <span class="variable">choreographer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>(looper, VSYNC_SOURCE_APP);</span><br><span class="line">            <span class="keyword">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class="line">                <span class="comment">//【3】如果 looper 是 ui thread 的，会保存到内部的 mMainInstance；</span></span><br><span class="line">                mMainInstance = choreographer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> choreographer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Choreographer <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadInstance.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-new-Choreographer"><a href="#3-2-new-Choreographer" class="headerlink" title="3.2 new Choreographer"></a>3.2 new Choreographer</h2><p>创建 Choreographer:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Choreographer</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】线程的 looper 实例；</span></span><br><span class="line">    mLooper = looper;</span><br><span class="line">    <span class="comment">//【--&gt;6.1】创建 FrameHandler 对象，用于处理消息；</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="title class_">FrameHandler</span>(looper);</span><br><span class="line">    <span class="comment">//【2】创建 VSYNC 的信号接受对象；</span></span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//【3】初始化上一个 frame 渲染的时间点</span></span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line">    <span class="comment">//【4】计算帧率，也就是一帧所需的渲染时间，getRefreshRate 是刷新率，一般是 60；</span></span><br><span class="line">    mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line">    <span class="comment">//【5】创建消息处理队列</span></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// b/68769804: For low FPS experiments.</span></span><br><span class="line">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>USE_VSYNC 的值来自下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】判断系统是否打开了 vsync，读取 &quot;debug.choreographer.vsync&quot; 属性；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">USE_VSYNC</span> <span class="operator">=</span> SystemProperties.getBoolean(</span><br><span class="line">                   <span class="string">&quot;debug.choreographer.vsync&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>如果开启了 Vsync，就会创建一个 FrameDisplayEventReceiver 实例，用于请求并接收 Vsync 事件：</p>
<p>Choreographer 创建了一个大小为 3 的 CallbackQueue 数组，用于保存不同类型的 Callback；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_COMMIT</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_LAST</span> <span class="operator">=</span> CALLBACK_COMMIT;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-postCallback-Delayed-DelayedInternal"><a href="#3-3-postCallback-Delayed-DelayedInternal" class="headerlink" title="3.3 postCallback[Delayed][DelayedInternal]"></a>3.3 postCallback[Delayed][DelayedInternal]</h2><p>callbackType 表示回调的类型！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postCallback</span><span class="params">(<span class="type">int</span> callbackType, Runnable action, Object token)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】继续调用；</span></span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 postCallbackDelayed 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayed</span><span class="params">(<span class="type">int</span> callbackType,</span></span><br><span class="line"><span class="params">                                Runnable action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    ... ... ...<span class="comment">// 省略对 action 和 callbackType 的判断；</span></span><br><span class="line"></span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 postCallbackDelayedInternal 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayedInternal</span><span class="params">(<span class="type">int</span> callbackType,</span></span><br><span class="line"><span class="params">                                         Object action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;PostCallback: type=&quot;</span> + callbackType</span><br><span class="line">              + <span class="string">&quot;, action=&quot;</span> + action + <span class="string">&quot;, token=&quot;</span> + token</span><br><span class="line">              + <span class="string">&quot;, delayMillis=&quot;</span> + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dueTime</span> <span class="operator">=</span> now + delayMillis; <span class="comment">// delayMillis 是我们设置的延迟，这里为 0；</span></span><br><span class="line">        <span class="comment">//【1】可以看到其将 action 根据 callbackType 放入了 mCallbackQueues 数组中；</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;3.4】延迟时间到了，请求一个 Vsync 信号；</span></span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【--&gt;6.X】时间没到，那就创建一个 MSG_DO_SCHEDULE_CALLBACK 的异步消息，</span></span><br><span class="line">            <span class="comment">// 用于异步执行 action 任务，延迟 dueTime 发送给 FrameHandler 处理；</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>); <span class="comment">// 注意：这是异步的！</span></span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-1-CallbackQueues"><a href="#3-3-1-CallbackQueues" class="headerlink" title="3.3.1 CallbackQueues"></a>3.3.1 CallbackQueues</h3><p>CallbackQueues 是一个用于链表实现的队列，用于保存每种类型的回调链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CallbackQueue</span> &#123;</span><br><span class="line">     <span class="comment">//【--&gt;3.3.2】回调链表的 head；</span></span><br><span class="line">     <span class="keyword">private</span> CallbackRecord mHead;</span><br><span class="line">		... ... ...<span class="comment">// 省略掉操作链表的方法；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CallbackQueue 数组由三种类型不同 CallbackQueue，每个都有一个 CallbackRecord 链表，链表按照任务触发时间由小到大排列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_INPUT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_ANIMATION</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CALLBACK_TRAVERSAL</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>内部的 CallbackRecord 以链表组织，以执行时间</p>
<h4 id="3-3-1-1-extractDueCallbacksLocked"><a href="#3-3-1-1-extractDueCallbacksLocked" class="headerlink" title="3.3.1.1 extractDueCallbacksLocked"></a>3.3.1.1 extractDueCallbacksLocked</h4><p>返回要执行的 CallbackRecord 子链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CallbackRecord <span class="title function_">extractDueCallbacksLocked</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="type">CallbackRecord</span> <span class="variable">callbacks</span> <span class="operator">=</span> mHead;</span><br><span class="line">    <span class="keyword">if</span> (callbacks == <span class="literal">null</span> || callbacks.dueTime &gt; now) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】last/next 指针；用于断开链表；</span></span><br><span class="line">    <span class="type">CallbackRecord</span> <span class="variable">last</span> <span class="operator">=</span> callbacks;</span><br><span class="line">    <span class="type">CallbackRecord</span> <span class="variable">next</span> <span class="operator">=</span> last.next;</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【2】找到执行时间晚于 now 的了，断开；</span></span><br><span class="line">        <span class="keyword">if</span> (next.dueTime &gt; now) &#123;</span><br><span class="line">            last.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    mHead = next;</span><br><span class="line">    <span class="comment">//【3】返回执行时间早于 now 的子链表；</span></span><br><span class="line">    <span class="keyword">return</span> callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-2-addCallbackLocked"><a href="#3-3-1-2-addCallbackLocked" class="headerlink" title="3.3.1.2 addCallbackLocked"></a>3.3.1.2 addCallbackLocked</h4><p>添加一个 CallbackRecord 到链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCallbackLocked</span><span class="params">(<span class="type">long</span> dueTime, Object action, Object token)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】返回一个可复用的 CallbackRecord 实例；</span></span><br><span class="line">    <span class="comment">// obtainCallbackLocked 方法会返回这个复用的实例，代码简单就不多数了；</span></span><br><span class="line">    <span class="type">CallbackRecord</span> <span class="variable">callback</span> <span class="operator">=</span> obtainCallbackLocked(dueTime, action, token);</span><br><span class="line">    <span class="type">CallbackRecord</span> <span class="variable">entry</span> <span class="operator">=</span> mHead;</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">        mHead = callback;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】判断下 head；</span></span><br><span class="line">    <span class="keyword">if</span> (dueTime &lt; entry.dueTime) &#123;</span><br><span class="line">        callback.next = entry;</span><br><span class="line">        mHead = callback;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】遍历链表，找到合适的地方插入；</span></span><br><span class="line">    <span class="keyword">while</span> (entry.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt; entry.next.dueTime) &#123;</span><br><span class="line">            callback.next = entry.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        entry = entry.next;</span><br><span class="line">    &#125;</span><br><span class="line">    entry.next = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编舞者内部有一个 mCallbackPool 实例，表示一个可复用的 CallbackRecord 对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CallbackRecord mCallbackPool;</span><br></pre></td></tr></table></figure>
<p><strong>obtainCallbackLocked</strong> 方法会返回这个复用的实例：</p>
<ul>
<li>如果 mCallbackPool 不为 null，就设置值，返回；</li>
<li>如果 mCallbackPool 为 null，初始化新的，再设置值，返回；</li>
</ul>
<h4 id="3-3-2-3-hasDueCallbacksLocked"><a href="#3-3-2-3-hasDueCallbacksLocked" class="headerlink" title="3.3.2.3 hasDueCallbacksLocked"></a>3.3.2.3 hasDueCallbacksLocked</h4><p>判断是否有已经触发的回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasDueCallbacksLocked</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】就是比较下时间；</span></span><br><span class="line">    <span class="keyword">return</span> mHead != <span class="literal">null</span> &amp;&amp; mHead.dueTime &lt;= now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-CallbackRecord"><a href="#3-3-2-CallbackRecord" class="headerlink" title="3.3.2 CallbackRecord"></a>3.3.2 CallbackRecord</h3><p>每一个回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CallbackRecord</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> CallbackRecord next; <span class="comment">// 指向下一个对象；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> dueTime;</span><br><span class="line">    <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></span><br><span class="line">    <span class="keyword">public</span> Object token;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ((Runnable)action).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 token 不同，执行不同的处理：</p>
<ul>
<li><strong>FrameCallback</strong> 的 token 是 FRAME_CALLBACK_TOKEN</li>
<li><strong>Runnable</strong> 的 token 为 null；</li>
</ul>
<h2 id="3-4-scheduleFrameLocked"><a href="#3-4-scheduleFrameLocked" class="headerlink" title="3.4 scheduleFrameLocked"></a>3.4 scheduleFrameLocked</h2><p>请求一个 Vsync 信号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleFrameLocked</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        <span class="comment">//【1】设置 mFrameScheduled 为 true；</span></span><br><span class="line">        mFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123; </span><br><span class="line">            <span class="comment">//【1】如果开启了 Vsync（默认开启）</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If running on the Looper thread, then schedule the vsync immediately,</span></span><br><span class="line">            <span class="comment">// otherwise post a message to schedule the vsync from the UI thread</span></span><br><span class="line">            <span class="comment">// as soon as possible.</span></span><br><span class="line">            <span class="comment">// 这里会判断下 ？Looper.myLooper() == mLooper，如果一样;</span></span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                <span class="comment">//【--&gt;3.4.1】立刻请求 Vsync 信号；</span></span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【--&gt;6.1】发送一个 异步 msg[MSG_DO_SCHEDULE_VSYNC] 给 Framehandler;</span></span><br><span class="line">	<span class="comment">// 这个异步消息会在 message queue 的队头；</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【2】没有开启了 Vsync，那么这里会手动计算一个 delay 时间；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">nextFrameTime</span> <span class="operator">=</span> Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【--&gt;6.X】发送一个 异步 msg[MSG_DO_FRAME] 给 Framehander；</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-1-scheduleVsyncLocked"><a href="#3-4-1-scheduleVsyncLocked" class="headerlink" title="3.4.1 scheduleVsyncLocked"></a>3.4.1 scheduleVsyncLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleVsyncLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//【--&gt;4.2】通过 FrameDisplayEventReceiver 请求 vSync 信号；</span></span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-FrameDisplayEventReceiver"><a href="#4-FrameDisplayEventReceiver" class="headerlink" title="4  FrameDisplayEventReceiver"></a>4  FrameDisplayEventReceiver</h1><p>FrameDisplayEventReceiver 用于请求和接受 vsync 信号：</p>
<h2 id="4-1-new-FrameDisplayEventReceiver"><a href="#4-1-new-FrameDisplayEventReceiver" class="headerlink" title="4.1 new FrameDisplayEventReceiver"></a>4.1 new FrameDisplayEventReceiver</h2><p>FrameDisplayEventReceiver 继承了 <strong>DisplayEventReceiver</strong>，同时注意，也是<strong>实现了 Runnable</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title class_">DisplayEventReceiver</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> mHavePendingVsync;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">long</span> mTimestampNanos;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> mFrame;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(looper, vsyncSource);</span><br><span class="line">   &#125;</span><br><span class="line">   ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看其父类 <strong>DisplayEventReceiver</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;looper must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】获取到当前 looper 的 MessageQueue；</span></span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    <span class="comment">//【--&gt;4.1.1】创建 NativeDisplayEventReceiver；</span></span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class="built_in">this</span>), mMessageQueue,</span><br><span class="line">                              vsyncSource);</span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">&quot;dispose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>NativeDisplayEventReceiver</strong> 中会获取 Java MessageQueue 对应的 NativeMessageQueue，这个和前面的 input 很类似了；</p>
<p>这里的 nativeInit 方法位于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp</span><br></pre></td></tr></table></figure>
<h3 id="4-1-1-nativeInit"><a href="#4-1-1-nativeInit" class="headerlink" title="4.1.1 nativeInit"></a>4.1.1 nativeInit</h3><p>用于初始化 NativeDisplayEventReceiver</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> jlong <span class="title function_">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverObj,</span></span><br><span class="line"><span class="params">        jobject messageQueueObj)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】获取 NativeMessageQueue 实例；</span></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == NULL) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">&quot;MessageQueue is not initialized.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【--&gt;5.1】创建 NativeDisplayEventReceiver 实例；</span></span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="keyword">new</span> <span class="title class_">NativeDisplayEventReceiver</span>(env,</span><br><span class="line">            receiverObj, messageQueue);</span><br><span class="line">    <span class="comment">//【--&gt;5.2】初始化 receiver；</span></span><br><span class="line">    <span class="type">status_t</span> <span class="variable">status</span> <span class="operator">=</span> receiver-&gt;initialize();</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.appendFormat(<span class="string">&quot;Failed to initialize display event receiver.  status=%d&quot;</span>, status);</span><br><span class="line">        jniThrowRuntimeException(env, message.string());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】增加强引用计数；</span></span><br><span class="line">    receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(receiver.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-scheduleVsync"><a href="#4-2-scheduleVsync" class="headerlink" title="4.2 scheduleVsync"></a>4.2 scheduleVsync</h2><p>请求一个 Vsync 信号，父类方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleVsync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class="line">                + <span class="string">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;4.2.1】进入 native 层；</span></span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 nativeScheduleVsync 方法位于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp</span><br></pre></td></tr></table></figure>
<h3 id="4-2-1-nativeScheduleVsync"><a href="#4-2-1-nativeScheduleVsync" class="headerlink" title="4.2.1 nativeScheduleVsync"></a>4.2.1 nativeScheduleVsync</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">nativeScheduleVsync</span><span class="params">(JNIEnv* env, jclass clazz, jlong receiverPtr)</span> </span>&#123;</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver =</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);</span><br><span class="line">    <span class="comment">//【--&gt;5.3】进入 native 的 DisplayEventReceiver 请求 Vsync 信号；</span></span><br><span class="line">    <span class="type">status_t</span> status = receiver-&gt;<span class="built_in">scheduleVsync</span>();</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.<span class="built_in">appendFormat</span>(<span class="string">&quot;Failed to schedule next vertical sync pulse.  status=%d&quot;</span>, status);</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, message.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-dispatchVsync"><a href="#4-3-dispatchVsync" class="headerlink" title="4.3 dispatchVsync"></a>4.3 dispatchVsync</h2><p>这个方法是在父类里面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line">@<span class="built_in">SuppressWarnings</span>(<span class="string">&quot;unused&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">dispatchVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">int</span> builtInDisplayId, <span class="type">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【--&gt;4.4】处理 Vsync 信号</span></span><br><span class="line">	<span class="built_in">onVsync</span>(timestampNanos, builtInDisplayId, frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-onVsync"><a href="#4-4-onVsync" class="headerlink" title="4.4 onVsync"></a>4.4 onVsync</h2><p>处理 Vsync 信号；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">int</span> builtInDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    <span class="comment">//【1】忽略来自第二显示屏的 Vsync 信号；</span></span><br><span class="line">    <span class="keyword">if</span> (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Received vsync from secondary display, but we don&#x27;t support &quot;</span></span><br><span class="line">              + <span class="string">&quot;this case yet.  Choreographer needs a way to explicitly request &quot;</span></span><br><span class="line">              + <span class="string">&quot;vsync for a specific display to ensure it doesn&#x27;t lose track &quot;</span></span><br><span class="line">              + <span class="string">&quot;of its scheduled vsync.&quot;</span>);</span><br><span class="line">        <span class="comment">//【--&gt;5.3】请求下一个 Vsync；</span></span><br><span class="line">        scheduleVsync();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post the vsync event to the Handler.</span></span><br><span class="line">    <span class="comment">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class="line">    <span class="comment">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class="line">    <span class="comment">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class="line">    <span class="comment">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class="line">    <span class="comment">//【1】调整 Vsync 时间；</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">              + <span class="string">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class="line">              + <span class="string">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class="line">        timestampNanos = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】设置 mHavePendingVsync 为 ture，表示正在有一个处理中的 Vsync 信号；</span></span><br><span class="line">    <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class="line">              + <span class="string">&quot;one at a time.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;6.X】发送一个消息给 FrameHandler，该消息的 callback 为当前对象 FrameDisplayEventReceiver；</span></span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);</span><br><span class="line">    msg.setAsynchronous(<span class="literal">true</span>); <span class="comment">// 注意：这是异步消息；</span></span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得为什么是异步消息吗？</p>
<p>这是因为，Vsync 信号是优先级很高的信号，所以，要优先处理他，这里将其设置成异步的。</p>
<p>好处是可以通过设置障栅，阻塞同步，优先处理异步消息，这个在 view draw 中有使用到；</p>
<p><strong>重点：</strong></p>
<ul>
<li>当 Vsync 请求到后，这里会把 <strong>FrameDisplayEventReceiver</strong> 最为 callback，通过 msg 发送给 Handler；</li>
</ul>
<h2 id="4-5-run"><a href="#4-5-run" class="headerlink" title="4.5 run"></a>4.5 run</h2><p>执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">	mHavePendingVsync = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//【--&gt;7.2】处理这一帧！</span></span><br><span class="line">	doFrame(mTimestampNanos, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-NativeDisplayEventReceiver-核心"><a href="#5-NativeDisplayEventReceiver-核心" class="headerlink" title="5 NativeDisplayEventReceiver - 核心"></a>5 NativeDisplayEventReceiver - 核心</h1><p>我们去看看 native 的逻辑：</p>
<h2 id="5-1-create-NativeDisplayEventReceiver"><a href="#5-1-create-NativeDisplayEventReceiver" class="headerlink" title="5.1 create NativeDisplayEventReceiver"></a>5.1 create NativeDisplayEventReceiver</h2><p>NativeDisplayEventReceiver 继承 DisplayEventDispatcher：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android_runtime/AndroidRuntime.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;androidfw/DisplayEventDispatcher.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utils/Looper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utils/threads.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gui/DisplayEventReceiver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;android_os_MessageQueue.h&quot;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NativeDisplayEventReceiver</span> : <span class="keyword">public</span> DisplayEventDispatcher &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NativeDisplayEventReceiver</span>(JNIEnv* env,</span><br><span class="line">            jobject receiverWeak, <span class="type">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    jobject mReceiverWeakGlobal; <span class="comment">// 全局引用，指向 java 层的 FrameDisplayEventReceiver 实例；</span></span><br><span class="line">    sp&lt;MessageQueue&gt; mMessageQueue; <span class="comment">// NativeMessageQueue 实例；</span></span><br><span class="line">    DisplayEventReceiver mReceiver; <span class="comment">// DisplayEventReceiver 实例 frameworks/nivate/libs/gui/DisplayEventReceiver.cpp</span></span><br><span class="line">    <span class="type">bool</span> mWaitingForVsync; <span class="comment">// 表示是否正在等待 Vsync，初始化为 false；</span></span><br><span class="line">    </span><br><span class="line">NativeDisplayEventReceiver::<span class="built_in">NativeDisplayEventReceiver</span>(JNIEnv* env,</span><br><span class="line">        jobject receiverWeak, <span class="type">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue) :</span><br><span class="line">        <span class="built_in">DisplayEventDispatcher</span>(messageQueue-&gt;<span class="built_in">getLooper</span>()), <span class="comment">// 调用父类的构造器，传入 nativeMessageQueue 的 looper 对象；</span></span><br><span class="line">        <span class="built_in">mReceiverWeakGlobal</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(receiverWeak)),</span><br><span class="line">        <span class="built_in">mMessageQueue</span>(messageQueue), <span class="built_in">mWaitingForVsync</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Initializing display event receiver.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去看看父类的构造器：</p>
<h3 id="5-1-1-create-DisplayEventDispatcher-父类"><a href="#5-1-1-create-DisplayEventDispatcher-父类" class="headerlink" title="5.1.1 create DisplayEventDispatcher - 父类"></a>5.1.1 create DisplayEventDispatcher - 父类</h3><p>参数 const sp<Looper>&amp; looper 是 NativeMessageQueue 对应的 Looper；</Looper></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DisplayEventDispatcher</span> : <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DisplayEventDispatcher</span>(<span class="type">const</span> sp&lt;Looper&gt;&amp; looper);</span><br><span class="line"></span><br><span class="line">... ... ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sp&lt;Looper&gt; mLooper; <span class="comment">// NativeMessageQueue 对应的 Looper 实例；</span></span><br><span class="line">    DisplayEventReceiver mReceiver;</span><br><span class="line">    <span class="type">bool</span> mWaitingForVsync;</span><br><span class="line">    </span><br><span class="line">DisplayEventDispatcher::<span class="built_in">DisplayEventDispatcher</span>(<span class="type">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        <span class="built_in">mLooper</span>(looper), <span class="built_in">mWaitingForVsync</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;dispatcher %p ~ Initializing display event dispatcher.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-initialize"><a href="#5-2-initialize" class="headerlink" title="5.2 initialize"></a>5.2 initialize</h2><p>初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">DisplayEventDispatcher::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【--&gt;5..6.1】检查这里的 DisplayEventReceiver 是否被创建</span></span><br><span class="line">    <span class="type">status_t</span> result = mReceiver.<span class="built_in">initCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Failed to initialize display event receiver, status=%d&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】使用 NativeMessageQueue 的 Looper 对象监听 </span></span><br><span class="line">    <span class="comment">//【--&gt;5..6.3】mReceiver.getFd 返回的文件句柄，这是 fd 是 bittube 的文件句柄。</span></span><br><span class="line">    <span class="comment">// 同时将自己作为回调！</span></span><br><span class="line">    <span class="type">int</span> rc = mLooper-&gt;<span class="built_in">addFd</span>(mReceiver.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">            <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-scheduleVsync"><a href="#5-3-scheduleVsync" class="headerlink" title="5.3 scheduleVsync"></a>5.3 scheduleVsync</h2><p>请求 Vsync 信号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">DisplayEventDispatcher::scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWaitingForVsync) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;dispatcher %p ~ Scheduling vsync.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Drain all pending events.</span></span><br><span class="line">        <span class="type">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">        <span class="type">int32_t</span> vsyncDisplayId;</span><br><span class="line">        <span class="type">uint32_t</span> vsyncCount;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">processPendingEvents</span>(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;dispatcher %p ~ last event processed while scheduling was for %&quot;</span> PRId64 <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="keyword">this</span>, <span class="built_in">ns2ms</span>(<span class="built_in">static_cast</span>&lt;<span class="type">nsecs_t</span>&gt;(vsyncTimestamp)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【--&gt;5..6.4】请求下一次 Vsync 信息!</span></span><br><span class="line">        <span class="type">status_t</span> status = mReceiver.<span class="built_in">requestNextVsync</span>();</span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Failed to request next vsync, status=%d&quot;</span>, status);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWaitingForVsync = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-handleEvent"><a href="#5-4-handleEvent" class="headerlink" title="5.4 handleEvent"></a>5.4 handleEvent</h2><p>前面我们看到，native Looper 监听指定的 fd，当 fd 有事件写入后，handleEvent 就会触发：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisplayEventDispatcher::handleEvent</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> events, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; (Looper::EVENT_ERROR | Looper::EVENT_HANGUP)) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Display event receiver pipe was closed or an error occurred.  &quot;</span></span><br><span class="line">                <span class="string">&quot;events=0x%x&quot;</span>, events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// remove the callback</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(events &amp; Looper::EVENT_INPUT)) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Received spurious callback for unhandled poll event.  &quot;</span></span><br><span class="line">                <span class="string">&quot;events=0x%x&quot;</span>, events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">    <span class="type">int32_t</span> vsyncDisplayId;</span><br><span class="line">    <span class="type">uint32_t</span> vsyncCount;</span><br><span class="line">    <span class="comment">//【--&gt;5.4.1】获取最后一次的 Vsync。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">processPendingEvents</span>(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;dispatcher %p ~ Vsync pulse: timestamp=%&quot;</span> PRId64 <span class="string">&quot;, id=%d, count=%d&quot;</span>,</span><br><span class="line">                <span class="keyword">this</span>, <span class="built_in">ns2ms</span>(vsyncTimestamp), vsyncDisplayId, vsyncCount);</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//【--&gt;5.5】分发最后一次的 Vsync。</span></span><br><span class="line">        <span class="built_in">dispatchVsync</span>(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-1-processPendingEvents"><a href="#5-4-1-processPendingEvents" class="headerlink" title="5.4.1 processPendingEvents"></a>5.4.1 processPendingEvents</h3><p>前面我们看到，Native Looper 监听指定的 fd，当 fd 由事件写入后，handleEvent 就会触发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">bool DisplayEventDispatcher::processPendingEvents(</span><br><span class="line">        nsecs_t* outTimestamp, int32_t* outId, uint32_t* outCount) &#123;</span><br><span class="line">    <span class="type">bool</span> <span class="variable">gotVsync</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    ssize_t n;</span><br><span class="line">    <span class="comment">//【--&gt;[5..6.5]】通过 mReceiver.getEvents 获取 event，保存到 buf 中；</span></span><br><span class="line">    <span class="comment">// mReceiver 就是 DisplayEventReceiver 对象；</span></span><br><span class="line">    <span class="keyword">while</span> ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;dispatcher %p ~ Read %d events.&quot;</span>, <span class="built_in">this</span>, <span class="type">int</span>(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ssize_t</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            const DisplayEventReceiver::Event&amp; ev = buf[i];</span><br><span class="line">            <span class="comment">//【2】判断 event 的 type；</span></span><br><span class="line">            <span class="keyword">switch</span> (ev.header.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                <span class="comment">//【3】最新的 Vsync 将会覆盖之前的消息，也就是说我们获取的是最近的那个；</span></span><br><span class="line">                <span class="comment">// 并设置 gotVsync 为 true！</span></span><br><span class="line">                gotVsync = <span class="literal">true</span>;</span><br><span class="line">                *outTimestamp = ev.header.timestamp;</span><br><span class="line">                *outId = ev.header.id;</span><br><span class="line">                *outCount = ev.vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                ALOGW(<span class="string">&quot;dispatcher %p ~ ignoring unknown event type %#x&quot;</span>, <span class="built_in">this</span>, ev.header.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Failed to get events from display event dispatcher, status=%d&quot;</span>, status_t(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotVsync; <span class="comment">// 返回 gotVsync；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-5-dispatchVsync"><a href="#5-5-dispatchVsync" class="headerlink" title="5.5 dispatchVsync"></a>5.5 dispatchVsync</h2><p>分发 Vsync 信号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeDisplayEventReceiver::dispatchVsync</span><span class="params">(<span class="type">nsecs_t</span> timestamp, <span class="type">int32_t</span> id, <span class="type">uint32_t</span> count)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = AndroidRuntime::<span class="built_in">getJNIEnv</span>();</span><br><span class="line">    <span class="comment">//【1】这个就是 java 层的 FrameDisplayEventReceiver 实例；</span></span><br><span class="line">    <span class="function">ScopedLocalRef&lt;jobject&gt; <span class="title">receiverObj</span><span class="params">(env, jniGetReferent(env, mReceiverWeakGlobal))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (receiverObj.<span class="built_in">get</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Invoking vsync handler.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//【--&gt;4.3】调用 FrameDisplayEventReceiver 的 dispatchVsync 方法；</span></span><br><span class="line">        env-&gt;<span class="built_in">CallVoidMethod</span>(receiverObj.<span class="built_in">get</span>(),</span><br><span class="line">                gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count);</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Returned from vsync handler.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue-&gt;<span class="built_in">raiseAndClearException</span>(env, <span class="string">&quot;dispatchVsync&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-6-DisplayEventReceiver-核心"><a href="#5-6-DisplayEventReceiver-核心" class="headerlink" title="[5..6] DisplayEventReceiver - 核心"></a>[5..6] DisplayEventReceiver - 核心</h1><p>在 NativeDisplayEventReceiver 中会创建 DisplayEventReceiver 对象；</p>
<p>但是很奇怪，我在 N 的代码里面没有找到 create DisplayEventReceiver 的地方，倒是 O 的代码里面有：</p>
<p>但是这里依然要看下创建的过程；</p>
<h2 id="5-6-1-create-DisplayEventReceiver"><a href="#5-6-1-create-DisplayEventReceiver" class="headerlink" title="[5..6].1 create DisplayEventReceiver"></a>[5..6].1 create DisplayEventReceiver</h2><p>这里创建了 DisplayEventReceiver 实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventReceiver::<span class="built_in">DisplayEventReceiver</span>() &#123;</span><br><span class="line">    <span class="comment">//【1】获取 SurfaceFlinger 的代理对象 BpSurfaceComposer</span></span><br><span class="line">    <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//【2】创建了 EventConnection，同时初始化 DataChannel 实例，他是 BitTube 类型的，支持跨进程；</span></span><br><span class="line">        <span class="comment">// 这里会通过 IPC 进入 SF；</span></span><br><span class="line">        mEventConnection = sf-&gt;<span class="built_in">createDisplayEventConnection</span>();</span><br><span class="line">        <span class="keyword">if</span> (mEventConnection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mDataChannel = mEventConnection-&gt;<span class="built_in">getDataChannel</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看下，这两个变量的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/native/include/gui/DisplayEventReceiver.h</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sp&lt;IDisplayEventConnection&gt; mEventConnection;</span><br><span class="line">    sp&lt;BitTube&gt; mDataChannel; <span class="comment">// 很重要，Vsync 信号最后就是通过 BitTube 传递上来的；</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里进行了 IPC 通信：/<a href="http://androidxref.com/7.1.1_r6/xref/frameworks/">frameworks</a>/<a href="http://androidxref.com/7.1.1_r6/xref/frameworks/native/">native</a>/<a href="http://androidxref.com/7.1.1_r6/xref/frameworks/native/libs/">libs</a>/<a href="http://androidxref.com/7.1.1_r6/xref/frameworks/native/libs/gui/">gui</a>/<a href="http://androidxref.com/7.1.1_r6/xref/frameworks/native/libs/gui/ISurfaceComposer.cpp">ISurfaceComposer.cpp</a>，进入 SurfaceFlinger 进程：</p>
<h3 id="extend-createDisplayEventConnection"><a href="#extend-createDisplayEventConnection" class="headerlink" title="extend - createDisplayEventConnection"></a>extend - createDisplayEventConnection</h3><p>跨进程 binder 调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> sp&lt;IDisplayEventConnection&gt; <span class="title">createDisplayEventConnection</span><span class="params">(VsyncSource vsyncSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    sp&lt;IDisplayEventConnection&gt; result;</span><br><span class="line">    <span class="type">int</span> err = data.<span class="built_in">writeInterfaceToken</span>(</span><br><span class="line">            ISurfaceComposer::<span class="built_in">getInterfaceDescriptor</span>());</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    data.<span class="built_in">writeInt32</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(vsyncSource));</span><br><span class="line">    err = <span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            BnSurfaceComposer::CREATE_DISPLAY_EVENT_CONNECTION,</span><br><span class="line">            data, &amp;reply);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;ISurfaceComposer::createDisplayEventConnection: error performing &quot;</span></span><br><span class="line">                <span class="string">&quot;transaction: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), -err);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">interface_cast</span>&lt;IDisplayEventConnection&gt;(reply.<span class="built_in">readStrongBinder</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在  SF 中是通过 EventThread 线程创建的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IDisplayEventConnection&gt; <span class="title">SurfaceFlinger::createDisplayEventConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 进入 EventThread 方法：</span></span><br><span class="line">   <span class="keyword">return</span> mEventThread-&gt;<span class="built_in">createEventConnection</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EventThread 是一个 native 层的线程：/<a href="http://androidxref.com/7.1.1_r6/xref/frameworks/">frameworks</a>/<a href="http://androidxref.com/7.1.1_r6/xref/frameworks/native/">native</a>/<a href="http://androidxref.com/7.1.1_r6/xref/frameworks/native/services/">services</a>/<a href="http://androidxref.com/7.1.1_r6/xref/frameworks/native/services/surfaceflinger/">surfaceflinger</a>/<a href="http://androidxref.com/7.1.1_r6/xref/frameworks/native/services/surfaceflinger/EventThread.cpp">EventThread.cpp</a></p>
<p>他的作用是接收 VSync 信号，并分发 VSync 信号给 Connection 对应的监听者；</p>
<p>VSync 类似于心跳，不断地会通知到 Surfaceflinger 中的 EventThread 线程，由后者再分发给感兴趣的注册者。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;EventThread::Connection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Connection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建 Connection 的方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建了一个 Connection 对象；</span></span><br><span class="line">EventThread::Connection::<span class="built_in">Connection</span>(</span><br><span class="line">        <span class="type">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span><br><span class="line">    : <span class="built_in">count</span>(<span class="number">-1</span>), <span class="built_in">mEventThread</span>(eventThread), <span class="built_in">mChannel</span>(<span class="keyword">new</span> <span class="built_in">BitTube</span>()) <span class="comment">// 这里创建了一个字节管道</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再去看看  Connection 类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventThread</span> : <span class="keyword">public</span> Thread, <span class="keyword">private</span> VSyncSource::Callback &#123;</span><br><span class="line">    <span class="comment">//【1】Connection 是内部类，实现了 BnDisplayEventConnection，具有跨进程能力；</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Connection</span> : <span class="keyword">public</span> BnDisplayEventConnection &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Connection</span>(<span class="type">const</span> sp&lt;EventThread&gt;&amp; eventThread);</span><br><span class="line">        <span class="function"><span class="type">status_t</span> <span class="title">postEvent</span><span class="params">(<span class="type">const</span> DisplayEventReceiver::Event&amp; event)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// count &gt;= 1 : continuous event. count is the vsync rate</span></span><br><span class="line">        <span class="comment">// count == 0 : one-shot event that has not fired</span></span><br><span class="line">        <span class="comment">// count ==-1 : one-shot event that fired this round / disabled</span></span><br><span class="line">        <span class="type">int32_t</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Connection</span>();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onFirstRef</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> sp&lt;BitTube&gt; <span class="title">getDataChannel</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setVsyncRate</span><span class="params">(<span class="type">uint32_t</span> count)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">requestNextVsync</span><span class="params">()</span></span>;    <span class="comment">// asynchronous</span></span><br><span class="line">        sp&lt;EventThread&gt; <span class="type">const</span> mEventThread; <span class="comment">// mEventThread 实例的引用；</span></span><br><span class="line">        sp&lt;BitTube&gt; <span class="type">const</span> mChannel; <span class="comment">// BitTube 实例的引用；</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>创建完成 Connection 后，紧接着就会触发 onFirstRef 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> EventThread::Connection::<span class="built_in">onFirstRef</span>() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn&#x27;t hold a strong reference on us</span></span><br><span class="line">    <span class="comment">// 注册 connection 到 EventThread 中：</span></span><br><span class="line">    mEventThread-&gt;<span class="built_in">registerDisplayEventConnection</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onFirstRef 属于其父类 RefBase，该函数在强引用 sp 新增引用计数时调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThread::registerDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mDisplayEventConnections.<span class="built_in">add</span>(connection); <span class="comment">// 添加到 mDisplayEventConnections 中去；</span></span><br><span class="line">    mCondition.<span class="built_in">broadcast</span>();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们先看这么多，后续再分析；</p>
<p>而对于 <code>sp&lt;BitTube&gt; mDataChannel</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;BitTube&gt; EventThread::Connection::<span class="built_in">getDataChannel</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 BitTube 给了 app 进程；</span></span><br><span class="line">    <span class="keyword">return</span> mChannel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-6-2-initCheck"><a href="#5-6-2-initCheck" class="headerlink" title="[5..6].2 initCheck"></a>[5..6].2 initCheck</h2><p>初始化检查，判断 mDataChannel 是否创建；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">DisplayEventReceiver::initCheck</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDataChannel != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    <span class="keyword">return</span> NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-6-3-getFd"><a href="#5-6-3-getFd" class="headerlink" title="[5..6].3 getFd"></a>[5..6].3 getFd</h2><p>获取 DataChannel 对应的文件描述符 fd </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisplayEventReceiver::getFd</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDataChannel == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mDataChannel-&gt;<span class="built_in">getFd</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-6-4-requestNextVsync"><a href="#5-6-4-requestNextVsync" class="headerlink" title="[5..6].4 requestNextVsync"></a>[5..6].4 requestNextVsync</h2><p>请求下一个 Vsync 信号；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">DisplayEventReceiver::requestNextVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventConnection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是通过 EventConnection 请求下一个 Vsync 信号；</span></span><br><span class="line">        mEventConnection-&gt;<span class="built_in">requestNextVsync</span>();</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-6-5-getEvents"><a href="#5-6-5-getEvents" class="headerlink" title="[5..6].5 getEvents"></a>[5..6].5 getEvents</h2><p>我们来看下 getEvents 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">DisplayEventReceiver::getEvents</span><span class="params">(DisplayEventReceiver::Event* events,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】从 BitTube 中读取 Vsync 事件；</span></span><br><span class="line">    <span class="comment">// 这里的 mDataChannel 就是上面创建的；</span></span><br><span class="line">    <span class="keyword">return</span> DisplayEventReceiver::<span class="built_in">getEvents</span>(mDataChannel, events, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">DisplayEventReceiver::getEvents</span><span class="params">(<span class="type">const</span> sp&lt;BitTube&gt;&amp; dataChannel,</span></span></span><br><span class="line"><span class="params"><span class="function">        Event* events, <span class="type">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BitTube::<span class="built_in">recvObjects</span>(dataChannel, events, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来一切都串起来了呀～～</p>
<h1 id="6-FrameHandler"><a href="#6-FrameHandler" class="headerlink" title="6 FrameHandler"></a>6 FrameHandler</h1><p>FrameHandler 主要用于处理内部消息，触发响应机制：</p>
<h2 id="6-1-new-FrameHandler"><a href="#6-1-new-FrameHandler" class="headerlink" title="6.1 new FrameHandler"></a>6.1 new FrameHandler</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FrameHandler</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_FRAME: </span><br><span class="line">                <span class="comment">//【1】这个消息是没有开启 VSYNC 的时候，java 层通过延迟模拟 Vsync 信号；</span></span><br><span class="line">                <span class="comment">// 延迟发送 doFrame 消息；</span></span><br><span class="line">                <span class="comment">//【--&gt;7.2】处理这一帧；</span></span><br><span class="line">                doFrame(System.nanoTime(), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                <span class="comment">//【2】这个消息用于请求 Vsync 信号；</span></span><br><span class="line">                <span class="comment">//【--&gt;7.1】请求 Vsync 信号；</span></span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                doScheduleCallback(msg.arg1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-Choreographer-back"><a href="#7-Choreographer-back" class="headerlink" title="7 Choreographer - back"></a>7 Choreographer - back</h1><p>这里我们再次回到了 Choreographer：</p>
<h2 id="7-1-doScheduleVsync"><a href="#7-1-doScheduleVsync" class="headerlink" title="7.1 doScheduleVsync"></a>7.1 doScheduleVsync</h2><p>doScheduleVsync 方法只是再次调用 scheduleVsyncLocked 方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doScheduleVsync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrameScheduled) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;3.4.1】涛声依旧&lt;sub&gt;&lt;/sub&gt;</span></span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h2 id="7-2-doFrame"><a href="#7-2-doFrame" class="headerlink" title="7.2 doFrame"></a>7.2 doFrame</h2><p>处理当前帧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> startNanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//【1】如果 mFrameScheduled 为 false，则不需要处理当前帧；</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_JANK &amp;&amp; mDebugPrintNextFrameTimeDelta) &#123;</span><br><span class="line">            mDebugPrintNextFrameTimeDelta = <span class="literal">false</span>;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;Frame time delta: &quot;</span></span><br><span class="line">                    + ((frameTimeNanos - mLastFrameTimeNanos) * <span class="number">0.000001f</span>) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">intendedFrameTimeNanos</span> <span class="operator">=</span> frameTimeNanos; <span class="comment">// 预期帧时间</span></span><br><span class="line">        startNanos = System.nanoTime();</span><br><span class="line">        <span class="comment">//【2】计算时间差值：当前时间 - 帧触发的时间；</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> startNanos - frameTimeNanos;</span><br><span class="line">        <span class="comment">//【3】判断时间差值是否超过 mFrameIntervalNanos，说明此时已经不满足 16ms 一帧了；</span></span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="comment">//【3.1】计算下跳过了多少帧。</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">skippedFrames</span> <span class="operator">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;Skipped &quot;</span> + skippedFrames + <span class="string">&quot; frames!  &quot;</span></span><br><span class="line">                        + <span class="string">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【3.2】余下的偏移量；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">lastFrameOffset</span> <span class="operator">=</span> jitterNanos % mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Missed vsync by &quot;</span> + (jitterNanos * <span class="number">0.000001f</span>) + <span class="string">&quot; ms &quot;</span></span><br><span class="line">                        + <span class="string">&quot;which is more than the frame interval of &quot;</span></span><br><span class="line">                        + (mFrameIntervalNanos * <span class="number">0.000001f</span>) + <span class="string">&quot; ms!  &quot;</span></span><br><span class="line">                        + <span class="string">&quot;Skipping &quot;</span> + skippedFrames + <span class="string">&quot; frames and setting frame &quot;</span></span><br><span class="line">                        + <span class="string">&quot;time to &quot;</span> + (lastFrameOffset * <span class="number">0.000001f</span>) + <span class="string">&quot; ms in the past.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【3.3】当前时间 - 余下的偏移量，作为本帧的实际时间；</span></span><br><span class="line">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【4】如果帧触发时间比上一帧的时间早，那就要重新请求 Vsync 信号；</span></span><br><span class="line">        <span class="keyword">if</span> (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Frame time appears to be going backwards.  May be due to a &quot;</span></span><br><span class="line">                        + <span class="string">&quot;previously skipped frame.  Waiting for next vsync.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【--&gt;3.4.1】重新请求 Vsync 信号；</span></span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFPSDivisor &gt; <span class="number">1</span>) &#123; <span class="comment">// 针对于低 FPs 的情况，这里没看懂；</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">timeSinceVsync</span> <span class="operator">=</span> frameTimeNanos - mLastFrameTimeNanos;</span><br><span class="line">            <span class="keyword">if</span> (timeSinceVsync &lt; (mFrameIntervalNanos * mFPSDivisor) &amp;&amp; timeSinceVsync &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【--&gt;8.2】保存帧信息（预期帧时间, 实际帧时间）</span></span><br><span class="line">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">        <span class="comment">//【4】设置 mFrameScheduled 为 false；</span></span><br><span class="line">        mFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//【5】保存当前帧时间到 mLastFrameTimeNanos；</span></span><br><span class="line">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【6】核心来了，这里会执行 CallbackQueue 中的 CallbackRecord！</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Choreographer#doFrame&quot;</span>);</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//【--&gt;8.3】标记 input 处理，动画开始，PerformTraversals 开始的时间</span></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        <span class="comment">//【--&gt;7.3】执行 CALLBACK_INPUT 类型的 CallbackQueue 中的 CallbackRecord！</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markAnimationsStart(); <span class="comment">// same;</span></span><br><span class="line">        <span class="comment">//【--&gt;7.3】执行 CALLBACK_ANIMATION 类型的 CallbackQueue 中的 CallbackRecord！</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart(); <span class="comment">// same;</span></span><br><span class="line">        <span class="comment">//【--&gt;7.3】执行 CALLBACK_TRAVERSAL 类型的 CallbackQueue 中的 CallbackRecord！</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AnimationUtils.unlockAnimationClock();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">endNanos</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Frame &quot;</span> + frame + <span class="string">&quot;: Finished, took &quot;</span></span><br><span class="line">                + (endNanos - startNanos) * <span class="number">0.000001f</span> + <span class="string">&quot; ms, latency &quot;</span></span><br><span class="line">                + (startNanos - frameTimeNanos) * <span class="number">0.000001f</span> + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FrameInfo 表示帧信息，是编舞者的内部成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FrameInfo</span> <span class="variable">mFrameInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FrameInfo</span>();</span><br></pre></td></tr></table></figure>
<p>这里看到有一个对帧时间调整的操作：</p>
<ul>
<li>预期帧时间，就是 Vsync 触发的时间，但是对于实际帧时间，可能因为做一些耗时操作，导致延后，错过多个帧时间周期；</li>
<li>jitterNanos = startNanos - frameTimeNanos，就是计算错过的总时间；</li>
<li>skippedFrames = jitterNanos / mFrameIntervalNanos，计算出了实际错过了帧数；</li>
<li>lastFrameOffset = jitterNanos % mFrameIntervalNanos，计算出余下的不满一帧的时间，然后要做调整；</li>
<li>frameTimeNanos = startNanos - lastFrameOffset，当前时间减去不满一帧的时间，保证相同的时间周期；</li>
</ul>
<p>接下来就是核心了，和前面看的一样， 执行 CallbackQueue 中的 CallbackRecord，次序：</p>
<ul>
<li>Choreographer.CALLBACK_INPUT；</li>
<li>Choreographer.CALLBACK_ANIMATION；</li>
<li>Choreographer.CALLBACK_TRAVERSAL；</li>
</ul>
<h2 id="7-3-doCallbacks"><a href="#7-3-doCallbacks" class="headerlink" title="7.3 doCallbacks"></a>7.3 doCallbacks</h2><p>执行 CallBack：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doCallbacks</span><span class="params">(<span class="type">int</span> callbackType, <span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">    CallbackRecord callbacks;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// We use &quot;now&quot; to determine when callbacks become due because it&#x27;s possible</span></span><br><span class="line">        <span class="comment">// for earlier processing phases in a frame to post callbacks that should run</span></span><br><span class="line">        <span class="comment">// in a following phase, such as an input event that causes an animation to start.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">//【--&gt;3.3.1】返回指定类型 callbackType 对应的 CallbackRecord，</span></span><br><span class="line">        <span class="comment">// 通过 last/next 两个指针，找到 CallbackRecord 所有执行时间早于 now 的（也就是已经到执行时间的）</span></span><br><span class="line">        <span class="comment">// CallbackRecord, 以链表形式返回（头结点，断开链表）</span></span><br><span class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(</span><br><span class="line">                now / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        <span class="keyword">if</span> (callbacks == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】讲 mCallbacksRunning 设置为 true；</span></span><br><span class="line">        mCallbacksRunning = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the frame time if necessary when committing the frame.</span></span><br><span class="line">        <span class="comment">// We only update the frame time if we are more than 2 frames late reaching</span></span><br><span class="line">        <span class="comment">// the commit phase.  This ensures that the frame time which is observed by the</span></span><br><span class="line">        <span class="comment">// callbacks will always increase from one frame to the next and never repeat.</span></span><br><span class="line">        <span class="comment">// We never want the next frame&#x27;s starting frame time to end up being less than</span></span><br><span class="line">        <span class="comment">// or equal to the previous frame&#x27;s commit frame time.  Keep in mind that the</span></span><br><span class="line">        <span class="comment">// next frame has most likely already been scheduled by now so we play it</span></span><br><span class="line">        <span class="comment">// safe by ensuring the commit time is always at least one frame behind.</span></span><br><span class="line">        <span class="comment">//【2】针对于最后一种类型 CALLBACK_COMMIT；会重新调整一次 mLastFrameTimeNanos。</span></span><br><span class="line">        <span class="comment">// CALLBACK_COMMIT 没有对应的 CallbackQueues；</span></span><br><span class="line">        <span class="keyword">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> now - frameTimeNanos;</span><br><span class="line">            Trace.traceCounter(Trace.TRACE_TAG_VIEW, <span class="string">&quot;jitterNanos&quot;</span>, (<span class="type">int</span>) jitterNanos);</span><br><span class="line">            <span class="keyword">if</span> (jitterNanos &gt;= <span class="number">2</span> * mFrameIntervalNanos) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">lastFrameOffset</span> <span class="operator">=</span> jitterNanos % mFrameIntervalNanos</span><br><span class="line">                        + mFrameIntervalNanos;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;Commit callback delayed by &quot;</span> + (jitterNanos * <span class="number">0.000001f</span>)</span><br><span class="line">                            + <span class="string">&quot; ms which is more than twice the frame interval of &quot;</span></span><br><span class="line">                            + (mFrameIntervalNanos * <span class="number">0.000001f</span>) + <span class="string">&quot; ms!  &quot;</span></span><br><span class="line">                            + <span class="string">&quot;Setting frame time to &quot;</span> + (lastFrameOffset * <span class="number">0.000001f</span>)</span><br><span class="line">                            + <span class="string">&quot; ms in the past.&quot;</span>);</span><br><span class="line">                    mDebugPrintNextFrameTimeDelta = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                frameTimeNanos = now - lastFrameOffset;</span><br><span class="line">                <span class="comment">//【2.1】更新 mLastFrameTimeNanos；</span></span><br><span class="line">                mLastFrameTimeNanos； = frameTimeNanos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);</span><br><span class="line">        <span class="comment">//【--&gt;3.3.2】遍历要执行的 CallbackRecord 链表，执行 run 方法；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">CallbackRecord</span> <span class="variable">c</span> <span class="operator">=</span> callbacks; c != <span class="literal">null</span>; c = c.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;RunCallback: type=&quot;</span> + callbackType</span><br><span class="line">                        + <span class="string">&quot;, action=&quot;</span> + c.action + <span class="string">&quot;, token=&quot;</span> + c.token</span><br><span class="line">                        + <span class="string">&quot;, latencyMillis=&quot;</span> + (SystemClock.uptimeMillis() - c.dueTime));</span><br><span class="line">            &#125;</span><br><span class="line">            c.run(frameTimeNanos); <span class="comment">// run</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            mCallbacksRunning = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//【3】回收子链表中的节点，其实就是逐个断开链接，置空属性，在 recycleCallbackLocked 方法中；</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">CallbackRecord</span> <span class="variable">next</span> <span class="operator">=</span> callbacks.next;</span><br><span class="line">                recycleCallbackLocked(callbacks);</span><br><span class="line">                callbacks = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (callbacks != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多数了。</p>
<p>现在我们回过头看回顾哪里，显然：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;5.7】开始遍历；</span></span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">TraversalRunnable</span> <span class="variable">mTraversalRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraversalRunnable</span>();</span><br></pre></td></tr></table></figure>
<p>开始遍历和绘制的操作这里就开始了；</p>
<h2 id="7-4-doScheduleCallback"><a href="#7-4-doScheduleCallback" class="headerlink" title="7.4 doScheduleCallback"></a>7.4 doScheduleCallback</h2><p>显然，这里依然从 CallbackQueues 判断 callbackType 是否有回调时间到了；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doScheduleCallback</span><span class="params">(<span class="type">int</span> callbackType)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">//【--&gt;3.3.2.3】判断时间是否到了；</span></span><br><span class="line">            <span class="keyword">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class="line">                <span class="comment">//【--&gt;3.4】 涛声依旧了~</span></span><br><span class="line">                scheduleFrameLocked(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了；</p>
<h1 id="8-FrameInfo"><a href="#8-FrameInfo" class="headerlink" title="8 FrameInfo"></a>8 FrameInfo</h1><p>用于表示帧的信息：</p>
<h2 id="8-1-new-FrameInfo"><a href="#8-1-new-FrameInfo" class="headerlink" title="8.1 new FrameInfo"></a>8.1 new FrameInfo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameInfo</span> &#123;</span><br><span class="line">    <span class="type">long</span>[] mFrameInfo = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">9</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部有一个数组：<strong>mFrameInfo</strong>，每一个元素的下标和存储的值得含义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTENDED_VSYNC</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 预期帧时间, 和 Vsync 相关，不受抖动调整；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VSYNC</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// 实际帧时间，会被抖动调整，是动画和绘图系统的时间输入</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OLDEST_INPUT_EVENT</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// 最旧的输入事件的时间；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEWEST_INPUT_EVENT</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// 最新的输入事件的时间；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HANDLE_INPUT_START</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 输入事件开始处理时的时间；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ANIMATION_START</span> <span class="operator">=</span> <span class="number">6</span>; <span class="comment">// 动画评估开始的时间；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PERFORM_TRAVERSALS_START</span> <span class="operator">=</span> <span class="number">7</span>; <span class="comment">// ViewRootImpl#performTraversals() 开始的时间； </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DRAW_START</span> <span class="operator">=</span> <span class="number">8</span>; <span class="comment">// Draw 方法开始的时间；</span></span><br></pre></td></tr></table></figure>
<h2 id="8-2-setVsync"><a href="#8-2-setVsync" class="headerlink" title="8.2 setVsync"></a>8.2 setVsync</h2><p>设置同步信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVsync</span><span class="params">(<span class="type">long</span> intendedVsync, <span class="type">long</span> usedVsync)</span> &#123;</span><br><span class="line">    mFrameInfo[INTENDED_VSYNC] = intendedVsync;</span><br><span class="line">    mFrameInfo[VSYNC] = usedVsync;</span><br><span class="line">    mFrameInfo[OLDEST_INPUT_EVENT] = Long.MAX_VALUE;</span><br><span class="line">    mFrameInfo[NEWEST_INPUT_EVENT] = <span class="number">0</span>;</span><br><span class="line">    mFrameInfo[FLAGS] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-3-markInputHandlingStart-Animations-PerformTraversals"><a href="#8-3-markInputHandlingStart-Animations-PerformTraversals" class="headerlink" title="8.3 markInputHandlingStart (Animations/PerformTraversals)"></a>8.3 markInputHandlingStart (Animations/PerformTraversals)</h2><p>标记 input 处理，动画开始，PerformTraversals 开始的时间：<strong>System.nanoTime</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markInputHandlingStart</span><span class="params">()</span> &#123;</span><br><span class="line">    mFrameInfo[HANDLE_INPUT_START] = System.nanoTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markAnimationsStart</span><span class="params">()</span> &#123;</span><br><span class="line">    mFrameInfo[ANIMATION_START] = System.nanoTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markPerformTraversalsStart</span><span class="params">()</span> &#123;</span><br><span class="line">    mFrameInfo[PERFORM_TRAVERSALS_START] = System.nanoTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h1><p>我们来看下整个流程：</p>
<h2 id="9-1-图示"><a href="#9-1-图示" class="headerlink" title="9.1 图示"></a>9.1 图示</h2><ul>
<li><strong>创建编舞者</strong></li>
</ul>
<p>流程图如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl -&gt; Choreographer: getInstance (线程单例)</span><br><span class="line"></span><br><span class="line">Choreographer -&gt; Choreographer: 2.new Choreographer</span><br><span class="line">Choreographer -&gt; FrameHandler: 3.new FrameHandler（ui 线程 Handler）</span><br><span class="line">Choreographer -&gt; FrameDisplayEventReceiver: 4.new FrameDisplayEventReceiver（用于请求 Vsync）</span><br><span class="line"></span><br><span class="line">Note over FrameDisplayEventReceiver,NativeDisplayEventReceiver: Java 这之间隔着一层 jni 调用层(...) Native</span><br><span class="line"></span><br><span class="line">FrameDisplayEventReceiver -&gt; FrameDisplayEventReceiver: 5.nativeInit</span><br><span class="line"></span><br><span class="line">Note right of NativeDisplayEventReceiver: 创建时，会获取 java MQ 对应的 \n native MQ，以及 native Looper</span><br><span class="line">FrameDisplayEventReceiver -&gt; NativeDisplayEventReceiver: 6.new NativeDisplayEventReceiver</span><br><span class="line">NativeDisplayEventReceiver --&gt; FrameDisplayEventReceiver: 6.return NativeDisplayEventReceiver</span><br><span class="line">FrameDisplayEventReceiver -&gt; NativeDisplayEventReceiver: 7.initialize （监听 mReceiver.getFd 返回的文件句柄）</span><br><span class="line"></span><br><span class="line">Choreographer --&gt; ViewRootImpl: return Choreographer</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>请求 Vsync 信号</strong></li>
</ul>
<p>流程图如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl -&gt; Choreographer: 5.postCallback（请求 Vsync）</span><br><span class="line">Choreographer -&gt; Choreographer: 6.postCallbackDelayed</span><br><span class="line">Choreographer -&gt; Choreographer: 7.postCallbackDelayedInternal</span><br><span class="line"></span><br><span class="line">Choreographer -&gt; CallbackQueue: 8.addCallbackLocked (将回调根据 type 加入到不同 CallbackQueue 中)</span><br><span class="line"></span><br><span class="line">CallbackQueue -&gt; CallbackQueue: 9.obtainCallbackLocked (创建新的/使用缓存)</span><br><span class="line">CallbackQueue -&gt; CallbackRecord: 10.new CallbackRecord</span><br><span class="line">CallbackRecord --&gt; CallbackQueue: 10.return CallbackRecord/temp one</span><br><span class="line"></span><br><span class="line">Choreographer -&gt; Choreographer : 11.scheduleFrameLocked (调度帧操作)</span><br><span class="line">Choreographer -&gt; Choreographer : 12.scheduleVsyncLocked</span><br><span class="line">Choreographer -&gt; FrameDisplayEventReceiver: 13.scheduleVsync</span><br><span class="line">FrameDisplayEventReceiver -&gt; FrameDisplayEventReceiver: 14.nativeScheduleVsync</span><br><span class="line">FrameDisplayEventReceiver -&gt; [extends DisplayEventDispatcher] \n NativeDisplayEventReceiver : 15.scheduleVsync (最后进入 native 层请求 Vsync)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>触发 Callback</strong></li>
</ul>
<p>流程图如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NativeDisplayEventReceiver -&gt; NativeDisplayEventReceiver : 1.handleEvent（Looper 监听到 fd 变化回调） </span><br><span class="line">NativeDisplayEventReceiver -&gt; NativeDisplayEventReceiver : 2.processPendingEvents </span><br><span class="line">NativeDisplayEventReceiver -&gt; NativeDisplayEventReceiver : 3.dispatchVsync </span><br><span class="line"></span><br><span class="line">Note over FrameDisplayEventReceiver, NativeDisplayEventReceiver: Native 这之间隔着一层 jni 调用层(...) Java</span><br><span class="line">NativeDisplayEventReceiver -&gt; FrameDisplayEventReceiver : 4.dispatchVsync </span><br><span class="line">FrameDisplayEventReceiver -&gt; FrameHandler : 5.sendMessageAtTime（将自己作为 runnable 传过去） </span><br><span class="line">FrameHandler --&gt; FrameDisplayEventReceiver : 6.run</span><br><span class="line"></span><br><span class="line">FrameDisplayEventReceiver -&gt; Choreographer : 7.doFrame</span><br><span class="line"></span><br><span class="line">Choreographer -&gt; FrameInfo : 8.setVsync (设置帧信息)</span><br><span class="line">Choreographer -&gt; Choreographer : 9.doCallbacks</span><br></pre></td></tr></table></figure>
<h2 id="9-2-EventThread-线程"><a href="#9-2-EventThread-线程" class="headerlink" title="9.2 EventThread 线程"></a>9.2 EventThread 线程</h2><p>这里简单的总结下 EventThread 线程：</p>
<h3 id="9-2-1-threadLoop"><a href="#9-2-1-threadLoop" class="headerlink" title="9.2.1  threadLoop"></a>9.2.1  threadLoop</h3><p>EventThread 启动后会进入 loop 循环，等待 Vsync 事件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EventThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DisplayEventReceiver::Event event;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    <span class="comment">//【1】等待 Vsync 事件，waitForEvent 内部是一个 do while 循环，但是，并不是无限循环下去；</span></span><br><span class="line">    signalConnections = <span class="built_in">waitForEvent</span>(&amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】分发 Vsync 事件给监听器：</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> count = signalConnections.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> sp&lt;Connection&gt;&amp; <span class="title">conn</span><span class="params">(signalConnections[i])</span></span>;</span><br><span class="line">        <span class="comment">//【1】分发 Vsync 事件，这里</span></span><br><span class="line">        <span class="type">status_t</span> err = conn-&gt;<span class="built_in">postEvent</span>(event);</span><br><span class="line">        <span class="keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="comment">// The destination doesn&#x27;t accept events anymore, it&#x27;s probably</span></span><br><span class="line">            <span class="comment">// full. For now, we just drop the events on the floor.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">FIXME:</span> Note that some events cannot be dropped and would have</span></span><br><span class="line">            <span class="comment">// to be re-sent later.</span></span><br><span class="line">            <span class="comment">// Right-now we don&#x27;t have the ability to do this.</span></span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;EventThread: dropping event (%08x) for connection %p&quot;</span>,</span><br><span class="line">                    event.header.type, conn.<span class="built_in">get</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// handle any other error on the pipe as fatal. the only</span></span><br><span class="line">            <span class="comment">// reasonable thing to do is to clean-up this connection.</span></span><br><span class="line">            <span class="comment">// The most common error we&#x27;ll get here is -EPIPE.</span></span><br><span class="line">            <span class="built_in">removeDisplayEventConnection</span>(signalConnections[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看到当监听到 Vsync 信号后，会调用 Connection::postEvent 方法将 event 分发出去！</p>
<h4 id="9-2-1-1-Connection-postEvent"><a href="#9-2-1-1-Connection-postEvent" class="headerlink" title="9.2.1.1  Connection::postEvent"></a>9.2.1.1  Connection::postEvent</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">status_t</span> EventThread::Connection::<span class="built_in">postEvent</span>(</span><br><span class="line">        <span class="type">const</span> DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line">    <span class="comment">//【1】这里是通过 DisplayEventReceiver 的方法，发送 Vsync 事件；</span></span><br><span class="line">    <span class="type">ssize_t</span> size = DisplayEventReceiver::<span class="built_in">sendEvents</span>(mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="built_in">status_t</span>(size) : <span class="built_in">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-1-1-DisplayEventReceiver-sendEvents"><a href="#9-2-1-1-DisplayEventReceiver-sendEvents" class="headerlink" title="9.2.1.1  DisplayEventReceiver::sendEvents"></a>9.2.1.1  DisplayEventReceiver::sendEvents</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">DisplayEventReceiver::sendEvents</span><span class="params">(<span class="type">const</span> sp&lt;BitTube&gt;&amp; dataChannel,</span></span></span><br><span class="line"><span class="params"><span class="function">        Event <span class="type">const</span>* events, <span class="type">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//【1】这里我们看到他是通过 BitTube 字节管道发送 Vsync 事件，给 app 进程；</span></span><br><span class="line">    <span class="comment">// 参数 dataChannel 从上面看，就是创建 connection 对象的时候，创建的 BitTube 实例；</span></span><br><span class="line">    <span class="keyword">return</span> BitTube::<span class="built_in">sendObjects</span>(dataChannel, events, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，这里用到了另外一个进程间通讯的机制：BitTube，这里我们不探讨</p>
<h3 id="9-2-2-waitForEvent"><a href="#9-2-2-waitForEvent" class="headerlink" title="9.2.2 waitForEvent"></a>9.2.2 waitForEvent</h3><p>等待 event 事件，这里我们先关注下核心的代码（一些注释我们先放着）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This will return when (1) a vsync event has been received, and (2) there was</span></span><br><span class="line"><span class="comment">// at least one connection interested in receiving it when we started waiting.</span></span><br><span class="line">Vector&lt; sp&lt;EventThread::Connection&gt; &gt; EventThread::<span class="built_in">waitForEvent</span>(</span><br><span class="line">        DisplayEventReceiver::Event* event)</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnxections;</span><br><span class="line">    <span class="comment">//【1】这里是一个 do whidle 循环，条件是 signalConnections 为空；</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">bool</span> eventPending = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> waitForVSync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> vsyncCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">nsecs_t</span> timestamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int32_t</span> i=<span class="number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">            timestamp = mVSyncEvent[i].header.timestamp;</span><br><span class="line">            <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">                <span class="comment">// we have a vsync event to dispatch</span></span><br><span class="line">                *event = mVSyncEvent[i];</span><br><span class="line">                mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line">                vsyncCount = mVSyncEvent[i].vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!timestamp) &#123;</span><br><span class="line">            <span class="comment">// no vsync event, see if there are some other event</span></span><br><span class="line">            eventPending = !mPendingEvents.<span class="built_in">isEmpty</span>();</span><br><span class="line">            <span class="keyword">if</span> (eventPending) &#123;</span><br><span class="line">                <span class="comment">// we have some other event to dispatch</span></span><br><span class="line">                *event = mPendingEvents[<span class="number">0</span>];</span><br><span class="line">                mPendingEvents.<span class="built_in">removeAt</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】找到所有的监听 Vsync 事件的 connections 对象，实际上这里就是我们前面 DisplayEventReceiver 创建的链接对象；</span></span><br><span class="line">        <span class="type">size_t</span> count = mDisplayEventConnections.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">            <span class="function">sp&lt;Connection&gt; <span class="title">connection</span><span class="params">(mDisplayEventConnections[i].promote())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="type">bool</span> added = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (connection-&gt;count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//【1.1】将其设置为 true，表示有 connection 在等待 Vsync 信号；</span></span><br><span class="line">                    waitForVSync = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">                        <span class="comment">// we consume the event only if it&#x27;s time</span></span><br><span class="line">                        <span class="comment">// (ie: we received a vsync event)</span></span><br><span class="line">                        <span class="keyword">if</span> (connection-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// fired this time around</span></span><br><span class="line">                            connection-&gt;count = <span class="number">-1</span>;</span><br><span class="line">                            signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection-&gt;count == <span class="number">1</span> ||</span><br><span class="line">                                (vsyncCount % connection-&gt;count) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// continuous event, and time to report it</span></span><br><span class="line">                            signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123;</span><br><span class="line">                    <span class="comment">// we don&#x27;t have a vsync event to process</span></span><br><span class="line">                    <span class="comment">// (timestamp==0), but we have some pending</span></span><br><span class="line">                    <span class="comment">// messages.</span></span><br><span class="line">                    signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we couldn&#x27;t promote this reference, the connection has</span></span><br><span class="line">                <span class="comment">// died, so clean-up!</span></span><br><span class="line">                mDisplayEventConnections.<span class="built_in">removeAt</span>(i);</span><br><span class="line">                --i; --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here we figure out if we need to enable or disable vsyncs</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &amp;&amp; !waitForVSync) &#123;</span><br><span class="line">            <span class="comment">// we received a VSYNC but we have no clients</span></span><br><span class="line">            <span class="comment">// don&#x27;t report it, and disable VSYNC events</span></span><br><span class="line">            <span class="built_in">disableVSyncLocked</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timestamp &amp;&amp; waitForVSync) &#123;</span><br><span class="line">            <span class="comment">// we have at least one client, so we want vsync enabled</span></span><br><span class="line">            <span class="comment">// (<span class="doctag">TODO:</span> this function is called right after we finish</span></span><br><span class="line">            <span class="comment">// notifying clients of a vsync, so this call will be made</span></span><br><span class="line">            <span class="comment">// at the vsync rate, e.g. 60fps.  If we can accurately</span></span><br><span class="line">            <span class="comment">// track the current state we could avoid making this call</span></span><br><span class="line">            <span class="comment">// so often.)</span></span><br><span class="line">            <span class="built_in">enableVSyncLocked</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// note: !timestamp implies signalConnections.isEmpty(), because we</span></span><br><span class="line">        <span class="comment">// don&#x27;t populate signalConnections if there&#x27;s no vsync pending</span></span><br><span class="line">        <span class="keyword">if</span> (!timestamp &amp;&amp; !eventPending) &#123;</span><br><span class="line">            <span class="comment">// wait for something to happen</span></span><br><span class="line">            <span class="keyword">if</span> (waitForVSync) &#123;</span><br><span class="line">                <span class="comment">// This is where we spend most of our time, waiting</span></span><br><span class="line">                <span class="comment">// for vsync events and new client registrations.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// If the screen is off, we can&#x27;t use h/w vsync, so we</span></span><br><span class="line">                <span class="comment">// use a 16ms timeout instead.  It doesn&#x27;t need to be</span></span><br><span class="line">                <span class="comment">// precise, we just need to keep feeding our clients.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// We don&#x27;t want to stall if there&#x27;s a driver bug, so we</span></span><br><span class="line">                <span class="comment">// use a (long) timeout when waiting for h/w vsync, and</span></span><br><span class="line">                <span class="comment">// generate fake events when necessary.</span></span><br><span class="line">                <span class="type">bool</span> softwareSync = mUseSoftwareVSync;</span><br><span class="line">                <span class="type">nsecs_t</span> timeout = softwareSync ? <span class="built_in">ms2ns</span>(<span class="number">16</span>) : <span class="built_in">ms2ns</span>(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">if</span> (mCondition.<span class="built_in">waitRelative</span>(mLock, timeout) == TIMED_OUT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!softwareSync) &#123;</span><br><span class="line">                        <span class="built_in">ALOGW</span>(<span class="string">&quot;Timed out waiting for hw vsync; faking it&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> how do we decide which display id the fake</span></span><br><span class="line">                    <span class="comment">// vsync came from ?</span></span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.id = DisplayDevice::DISPLAY_PRIMARY;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.timestamp = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].vsync.count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有人对 vsync 感兴趣，所以我们只想睡觉。h/w vsync 会被禁用，线程会进入等待状态，直到我们</span></span><br><span class="line">                <span class="comment">// 获取新连接，或现有连接变为有兴趣再次接收 vsync。</span></span><br><span class="line">                mCondition.<span class="built_in">wait</span>(mLock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (signalConnections.<span class="built_in">isEmpty</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// here we&#x27;re guaranteed to have a timestamp and some connections to signal</span></span><br><span class="line">    <span class="comment">// (The connections might have dropped out of mDisplayEventConnections</span></span><br><span class="line">    <span class="comment">// while we were asleep, but we&#x27;ll still have strong references to them.)</span></span><br><span class="line">    <span class="keyword">return</span> signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当没有 vsync 信号的时候，EventThread 是进入等待队列的，而不是无限的 while 循环下去；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mCondition.<span class="built_in">wait</span>(mLock);</span><br></pre></td></tr></table></figure>
<h2 id="9-3-BitTube"><a href="#9-3-BitTube" class="headerlink" title="9.3 BitTube"></a>9.3 BitTube</h2><p>这里我们看下 BitTube 的发送和接收方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 tube-&gt;write</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">BitTube::sendObjects</span><span class="params">(<span class="type">const</span> sp&lt;BitTube&gt;&amp; tube,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span> <span class="type">const</span>* events, <span class="type">size_t</span> count, <span class="type">size_t</span> objSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* vaddr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(events);</span><br><span class="line">    <span class="type">ssize_t</span> size = tube-&gt;<span class="built_in">write</span>(vaddr, count*objSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should never happen because of SOCK_SEQPACKET</span></span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>((size &gt;= <span class="number">0</span>) &amp;&amp; (size % <span class="built_in">static_cast</span>&lt;<span class="type">ssize_t</span>&gt;(objSize)),</span><br><span class="line">            <span class="string">&quot;BitTube::sendObjects(count=%zu, size=%zu), res=%zd (partial events were sent!)&quot;</span>,</span><br><span class="line">            count, objSize, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ALOGE_IF(size&lt;0, &quot;error %d sending %d events&quot;, size, count);</span></span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? size : size / <span class="built_in">static_cast</span>&lt;<span class="type">ssize_t</span>&gt;(objSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 tube-&gt;read</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">BitTube::recvObjects</span><span class="params">(<span class="type">const</span> sp&lt;BitTube&gt;&amp; tube,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span>* events, <span class="type">size_t</span> count, <span class="type">size_t</span> objSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* vaddr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(events);</span><br><span class="line">    <span class="type">ssize_t</span> size = tube-&gt;<span class="built_in">read</span>(vaddr, count*objSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should never happen because of SOCK_SEQPACKET</span></span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>((size &gt;= <span class="number">0</span>) &amp;&amp; (size % <span class="built_in">static_cast</span>&lt;<span class="type">ssize_t</span>&gt;(objSize)),</span><br><span class="line">            <span class="string">&quot;BitTube::recvObjects(count=%zu, size=%zu), res=%zd (partial events were received!)&quot;</span>,</span><br><span class="line">            count, objSize, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ALOGE_IF(size&lt;0, &quot;error %d receiving %d events&quot;, size, count);</span></span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? size : size / <span class="built_in">static_cast</span>&lt;<span class="type">ssize_t</span>&gt;(objSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line">&#125;; <span class="comment">// namespace android</span></span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Li Shuaiqi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lishuaiqi.top/2018/07/15/Choreographer-1-choreographerAnalysize/">https://lishuaiqi.top/2018/07/15/Choreographer-1-choreographerAnalysize/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lishuaiqi.top">Li Shuaiqi's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Choreographer/">Choreographer</a></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/23/PMS8-installThroughtPackageInstaller/"><i class="fa fa-chevron-left">  </i><span>PMS 第 8 篇 - 通过 PackageInstaller 分析 Install 过程</span></a></div><div class="next-post pull-right"><a href="/2018/06/21/ViewDraw-3-performTraversals/"><span>ViewDraw 第三篇 performTraversals 流程分析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  id: md5(decodeURI(location.pathname)),
  owner: '',
  repo: '',
  oauth: {
    client_id: '7b4efbcd7027d15749d6',
    client_secret: '14b5d7e8580ee29f7aeca733a25c000795967448'
  }
})
gitment.render('gitment-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2025 By Li Shuaiqi</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>